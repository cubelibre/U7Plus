commit f54632e736cb8b347213e614b5f18d049d47a46f
Author: yj <yangjie@rock-chips.com>
Date:   Tue Sep 25 11:10:39 2012 +0800

    	3066b+610 dupl display patch

diff --git a/drivers/mfd/rk610-core.c b/drivers/mfd/rk610-core.c
index d82e627..9aed240 100755
--- a/drivers/mfd/rk610-core.c
+++ b/drivers/mfd/rk610-core.c
@@ -26,7 +26,7 @@
 #endif
 
 static struct i2c_client *rk610_control_client = NULL;
-#ifdef CONFIG_RK610_LCD
+#ifdef  CONFIG_RK610_LVDS
 extern int rk610_lcd_init(struct rk610_core_info *rk610_core_info);
 #else
 int rk610_lcd_init(struct rk610_core_info *rk610_core_info){}
diff --git a/drivers/video/display/Kconfig b/drivers/video/display/Kconfig
old mode 100644
new mode 100755
index 98ea049..ab04081
--- a/drivers/video/display/Kconfig
+++ b/drivers/video/display/Kconfig
@@ -23,6 +23,8 @@ comment "Display hardware drivers"
 	depends on DISPLAY_SUPPORT
 source "drivers/video/display/screen/Kconfig"
 source "drivers/video/display/lcd/Kconfig"
+source "drivers/video/display/transmitter/Kconfig"
+source "drivers/video/display/lcd/Kconfig"
 source "drivers/video/display/tve/Kconfig"
 
 endmenu
diff --git a/drivers/video/display/Makefile b/drivers/video/display/Makefile
old mode 100644
new mode 100755
index ad3bc7f..d2f58d4
--- a/drivers/video/display/Makefile
+++ b/drivers/video/display/Makefile
@@ -4,5 +4,5 @@ display-objs				:= display-sys.o
 
 obj-$(CONFIG_DISPLAY_SUPPORT)		+= display.o
 obj-$(CONFIG_DISPLAY_SUPPORT)	    += screen/
-obj-y								+= lcd/
-obj-y								+= tve/
\ No newline at end of file
+obj-$(CONFIG_RK610_LVDS)	    += transmitter/
+obj-y								+= tve/
diff --git a/drivers/video/display/lcd/Kconfig b/drivers/video/display/lcd/Kconfig
deleted file mode 100644
index 3d15a66..0000000
--- a/drivers/video/display/lcd/Kconfig
+++ /dev/null
@@ -1,6 +0,0 @@
-config RK610_LCD
-	bool "RK610(Jetta) lcd support"
-	depends on MFD_RK610
-	default y if MFD_RK610
-	help
-		Support Jetta(RK610) to output LCD1 and LVDS.
diff --git a/drivers/video/display/lcd/Makefile b/drivers/video/display/lcd/Makefile
deleted file mode 100644
index a124d84..0000000
--- a/drivers/video/display/lcd/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-#
-# Makefile for the jetta tv control.
-#
-obj-$(CONFIG_RK610_LCD)			+= rk610_lcd.o
diff --git a/drivers/video/display/lcd/rk610_lcd.c b/drivers/video/display/lcd/rk610_lcd.c
deleted file mode 100644
index 9ffac8d..0000000
--- a/drivers/video/display/lcd/rk610_lcd.c
+++ /dev/null
@@ -1,414 +0,0 @@
-#include <linux/fb.h>
-#include <linux/delay.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include <mach/board.h>
-
-#include <linux/hdmi.h>
-#include "rk610_lcd.h"
-#include <linux/mfd/rk610_core.h>
-#include "../../rk29_fb.h"
-static struct rk610_lcd_info *g_lcd_inf = NULL;
-//static int rk610_scaler_read_p0_reg(struct i2c_client *client, char reg, char *val)
-//{
-	//return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
-//}
-
-static int rk610_scaler_write_p0_reg(struct i2c_client *client, char reg, char *val)
-{
-	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
-}
-static void rk610_scaler_pll_enable(struct i2c_client *client)
-{
-    char c;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-
-    g_lcd_inf->scl_inf.pll_pwr = ENABLE;
-    
-    c = S_PLL_PWR(0)|S_PLL_RESET(0)|S_PLL_BYPASS(0);
-	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
-}
-static void rk610_scaler_pll_disable(struct i2c_client *client)
-{
-    char c;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    
-    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
-
-    c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
-	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
-}
-static void rk610_scaler_enable(struct i2c_client *client)
-{
-    char c;
-    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    g_lcd_inf->scl_inf.scl_pwr = ENABLE;
-    #ifdef CONFIG_HDMI_DUAL_DISP
-    if(g_lcd_inf->screen !=NULL){
-        den_inv = g_lcd_inf->screen->s_den_inv;
-        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
-        clk_inv = g_lcd_inf->screen->s_clk_inv;
-    }
-    #endif
-    c= SCL_BYPASS(0) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(ENABLE);  
-	rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
-}
-static void rk610_scaler_disable(struct i2c_client *client)
-{
-    char c;
-    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    
-    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
-    #ifdef CONFIG_HDMI_DUAL_DISP
-    if(g_lcd_inf->screen !=NULL){
-        den_inv = g_lcd_inf->screen->s_den_inv;
-        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
-        clk_inv = g_lcd_inf->screen->s_clk_inv;
-    }
-    #endif
-    c= SCL_BYPASS(1) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(DISABLE); 
-    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
-}
-
-static int rk610_output_config(struct i2c_client *client,struct rk29fb_screen *screen,int mode)
-{
-    char c=0;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-     if(SCREEN_LVDS == screen->type){
-        if(mode == LCD_OUT_SCL || mode == LCD_OUT_BYPASS){
-            c = LVDS_OUT_CLK_PIN(0) |LVDS_OUT_CLK_PWR_PIN(1) |LVDS_PLL_PWR_PIN(0) \
-                |LVDS_LANE_IN_FORMAT(DATA_D0_MSB) |LVDS_INPUT_SOURCE(FROM_LCD0_OR_SCL) \
-                |LVDS_OUTPUT_FORMAT(screen->hw_format) | LVDS_BIASE_PWR(1); 
-	        rk610_scaler_write_p0_reg(client, LVDS_CON0, &c);
-            c = LVDS_OUT_ENABLE(0x0) |LVDS_TX_PWR_ENABLE(0x0); 
-	        rk610_scaler_write_p0_reg(client, LVDS_CON1, &c);
-	    }
-	    else{
-	        c = LVDS_OUT_CLK_PIN(0) |LVDS_OUT_CLK_PWR_PIN(0) |LVDS_PLL_PWR_PIN(1) \
-                |LVDS_LANE_IN_FORMAT(DATA_D0_MSB) |LVDS_INPUT_SOURCE(FROM_LCD0_OR_SCL) \
-                |LVDS_OUTPUT_FORMAT(screen->hw_format) | LVDS_BIASE_PWR(0); 
-	        rk610_scaler_write_p0_reg(client, LVDS_CON0, &c);
-            c = LVDS_OUT_ENABLE(0xf) |LVDS_TX_PWR_ENABLE(0xf); 
-	        rk610_scaler_write_p0_reg(client, LVDS_CON1, &c);
-             
-	    }
-	}else if(SCREEN_RGB == screen->type){
-	    if(mode == LCD_OUT_SCL || mode == LCD_OUT_BYPASS){
-            c = LCD1_OUT_ENABLE(LCD1_AS_OUT) | LCD1_OUT_SRC((mode == LCD_OUT_SCL)?LCD1_FROM_SCL : LCD1_FROM_LCD0);
-	        rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
-	    }
-	    else {
-            c = LCD1_OUT_ENABLE(LCD1_AS_IN);
-	        rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
-	    }
-	}
-	return 0;
-}
-#ifdef CONFIG_HDMI_DUAL_DISP
-static int rk610_scaler_pll_set(struct i2c_client *client,struct rk29fb_screen *screen,u32 clkin )
-{
-    char c=0;
-    char M=0,N=0,OD=0;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-	/***************SET SCALER PLL FROM CLKIN ,DIV 0*/
-    if(screen->s_pixclock != 0){
-        OD = (screen->s_pixclock)&0x3;
-        N = (screen->s_pixclock >>4)&0xf;
-        M = (screen->s_pixclock >>8)&0xff;
-    }else {
-        RK610_ERR(&client->dev,"RK610 Scaler pll not support rate \n");
-    }
-    c = S_PLL_FROM_DIV<<3 | S_PLL_DIV(0);
-	rk610_scaler_write_p0_reg(client, CLOCK_CON0, &c);
-    
-    c = S_DIV_N(N)| S_DIV_OD(OD);
-	rk610_scaler_write_p0_reg(client, S_PLL_CON0, &c);
-    c = S_DIV_M(M);
-    rk610_scaler_write_p0_reg(client, S_PLL_CON1, &c);
-    rk610_scaler_pll_enable(client);
-	return 0;
-}
-
-
-static int  scale_hv_factor(struct i2c_client *client ,u32 Hin_act, u32 Hout_act, u32 Vin_act, u32 Vout_act)
-   {
-    char c;
-  	u32 hfactor_f,vfactor_f,scl_factor_f;
-	int  hfactor;
-	int  vfactor;
-	struct scl_hv_info  HV2;
-	hfactor_f = ((Hin_act-1)*4096)/(Hout_act-1);
-    if(hfactor_f==4096)
-	    {hfactor = 0x1000;}
- 	else if(hfactor_f>(int)hfactor_f)
-	  	{hfactor = (int)hfactor_f+1;}
-	else
-	  	{hfactor = (int)hfactor_f;}
-	  
-	scl_factor_f = Vin_act/Vout_act;
-	if(scl_factor_f<2)
-	    {vfactor_f = ((Vin_act-1)*4096)/(Vout_act-1);}
-	else
-	  	{vfactor_f = ((Vin_act-2)*4096)/(Vout_act-1);} 
-	if(vfactor_f==4096)
-	    {vfactor = 0x1000;}
-	else if(vfactor_f>(int)vfactor_f)
-	  	{vfactor = (int)vfactor_f+1;}
-	else
-	  	{vfactor = (int)vfactor_f;}
-	  
-    HV2.scl_h= hfactor;
-    HV2.scl_v= vfactor; 
-           /*       SCL FACTOR          */
-    c = SCL_H_FACTOR_LSB(HV2.scl_h);
-	rk610_scaler_write_p0_reg(client, SCL_CON1, &c);
-    c = SCL_H_FACTOR_MSB(HV2.scl_h);
-	rk610_scaler_write_p0_reg(client, SCL_CON2, &c);
-
-    c = SCL_V_FACTOR_LSB(HV2.scl_v);
-	rk610_scaler_write_p0_reg(client, SCL_CON3, &c);
-    c = SCL_V_FACTOR_MSB(HV2.scl_v);
-	rk610_scaler_write_p0_reg(client, SCL_CON4, &c);
-  	return 0;
-   }
-
-static int rk610_scaler_fator_config(struct i2c_client *client ,struct rk29fb_screen *screen)
-{
-    switch(screen->hdmi_resolution){
-        case HDMI_1920x1080p_60Hz:
-        case HDMI_1920x1080p_50Hz:
-            rk610_scaler_pll_set(client,screen,148500000);
-            /***************set scaler factor********************/
-            scale_hv_factor(client,1920,screen->x_res,1080,screen->y_res);
-            break;
-        case HDMI_1280x720p_60Hz:
-        case HDMI_1280x720p_50Hz:
-            rk610_scaler_pll_set(client,screen,74250000);
-            /***************set scaler factor********************/
-            scale_hv_factor(client,1280,screen->x_res,720,screen->y_res);
-        break;
-        case HDMI_720x576p_50Hz_16x9:
-        case HDMI_720x576p_50Hz_4x3:
-            rk610_scaler_pll_set(client,screen,27000000);
-            /***************set scaler factor********************/
-            scale_hv_factor(client,720,screen->x_res,576,screen->y_res);
-            break;
-        case HDMI_720x480p_60Hz_16x9:
-        case HDMI_720x480p_60Hz_4x3:
-            rk610_scaler_pll_set(client,screen,27000000);
-            /***************set scaler factor********************/
-            scale_hv_factor(client,720,screen->x_res,480,screen->y_res);
-        break;
-    default :
-        RK610_ERR(&client->dev,"RK610 not support dual display at hdmi resolution=%d \n",screen->hdmi_resolution); 
-        return -1;
-        break;
-    }
-    return 0;
-}
-static int rk610_scaler_output_timing_config(struct i2c_client *client,struct rk29fb_screen *screen)
-{
-    char c;
-    int h_st = screen->s_hsync_st;
-    int hs_end = screen->s_hsync_len;
-    int h_act_st = hs_end + screen->s_left_margin;
-    int xres = screen->x_res;
-    int h_act_end = h_act_st + xres;
-    int h_total = h_act_end + screen->s_right_margin;
-    int v_st = screen->s_vsync_st;
-    int vs_end = screen->s_vsync_len;
-    int v_act_st = vs_end + screen->s_upper_margin;
-    int yres = screen->y_res;    
-    int v_act_end = v_act_st + yres;
-    int v_total = v_act_end + screen->s_lower_margin;
-
-    /*      SCL display Frame start point   */
-    c = SCL_DSP_HST_LSB(h_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON5, &c);
-    c = SCL_DSP_HST_MSB(h_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON6, &c);
-
-    c = SCL_DSP_VST_LSB(v_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON7, &c);
-    c = SCL_DSP_VST_MSB(v_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON8, &c);
-    /*      SCL output timing       */
-
-    c = SCL_DSP_HTOTAL_LSB(h_total);
-	rk610_scaler_write_p0_reg(client, SCL_CON9, &c);
-    c = SCL_DSP_HTOTAL_MSB(h_total);
-	rk610_scaler_write_p0_reg(client, SCL_CON10, &c);
-
-    c = SCL_DSP_HS_END(hs_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON11, &c);
-
-    c = SCL_DSP_HACT_ST_LSB(h_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON12, &c);
-    c = SCL_DSP_HACT_ST_MSB(h_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON13, &c);
-
-    c = SCL_DSP_HACT_END_LSB(h_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON14, &c);
-    c = SCL_DSP_HACT_END_MSB(h_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON15, &c);
-
-    c = SCL_DSP_VTOTAL_LSB(v_total);
-	rk610_scaler_write_p0_reg(client, SCL_CON16, &c);
-    c = SCL_DSP_VTOTAL_MSB(v_total);
-	rk610_scaler_write_p0_reg(client, SCL_CON17, &c);
-
-    c = SCL_DSP_VS_END(vs_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON18, &c);
-
-    c = SCL_DSP_VACT_ST(v_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON19, &c);
-
-    c = SCL_DSP_VACT_END_LSB(v_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON20, &c);
-    c = SCL_DSP_VACT_END_MSB(v_act_end); 
-	rk610_scaler_write_p0_reg(client, SCL_CON21, &c);
- 
-    c = SCL_H_BORD_ST_LSB(h_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON22, &c);
-    c = SCL_H_BORD_ST_MSB(h_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON23, &c);
-
-    c = SCL_H_BORD_END_LSB(h_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON24, &c);
-    c = SCL_H_BORD_END_MSB(h_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON25, &c);
-
-    c = SCL_V_BORD_ST(v_act_st);
-	rk610_scaler_write_p0_reg(client, SCL_CON26, &c);
-
-    c = SCL_V_BORD_END_LSB(v_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON27, &c);
-    c = SCL_V_BORD_END_MSB(v_act_end);
-	rk610_scaler_write_p0_reg(client, SCL_CON28, &c);
-	
-	return 0;
-}
-static int rk610_scaler_chg(struct i2c_client *client ,struct rk29fb_screen *screen)
-{
-
-    RK610_DBG(&client->dev,"%s screen->hdmi_resolution=%d\n",__FUNCTION__,screen->hdmi_resolution);
-    rk610_scaler_fator_config(client,screen);
-    rk610_scaler_enable(client);
-    rk610_scaler_output_timing_config(client,screen); 
-    
-    return 0;
-
-}
-#endif
-static int rk610_lcd_scaler_bypass(struct i2c_client *client,bool enable)//enable:0 bypass 1: scale
-{
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    
-    rk610_scaler_disable(client);       
-    rk610_scaler_pll_disable(client);
-    
-    return 0;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void rk610_lcd_early_suspend(struct early_suspend *h)
-{
-    struct i2c_client *client = g_lcd_inf->client;
-    char c;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    if(g_lcd_inf->screen != NULL){
-        rk610_output_config(client,g_lcd_inf->screen,LCD_OUT_DISABLE);
-    }
-
-    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
-        c= SCL_BYPASS(1) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(DISABLE); 
-        rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
-    }
-    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
-        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
-	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
-    }
-}
-
-static void rk610_lcd_early_resume(struct early_suspend *h)
-{
-    struct i2c_client *client = g_lcd_inf->client;
-    char c;
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-
-    if(g_lcd_inf->screen != NULL){
-        rk610_output_config(client,g_lcd_inf->screen,g_lcd_inf->disp_mode);
-    }
-    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
-        c= SCL_BYPASS(0) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(ENABLE);  
-	    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
-    }
-    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
-        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
-	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
-    }
-}
-#endif
-int rk610_lcd_scaler_set_param(struct rk29fb_screen *screen,bool enable )//enable:0 bypass 1: scale
-{
-    int ret=0;
-    struct i2c_client *client = g_lcd_inf->client;
-    if(client == NULL){
-        printk("%s client == NULL FAIL\n",__FUNCTION__);
-        return -1;
-    }
-    if(screen == NULL){
-        printk("%s screen == NULL FAIL\n",__FUNCTION__);
-        return -1;
-    }
-    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
-    
-    g_lcd_inf->screen = screen;
-    
-#ifdef CONFIG_HDMI_DUAL_DISP
-    if(enable == 1){
-        g_lcd_inf->disp_mode = LCD_OUT_SCL;
-        rk610_output_config(client,screen,LCD_OUT_SCL);
-        ret = rk610_scaler_chg(client,screen);
-	}
-	else 
-#endif
-	{
-	    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
-	    rk610_output_config(client,screen,LCD_OUT_BYPASS);
-	    ret = rk610_lcd_scaler_bypass(client,enable);
-	}
-	return ret;
-}
-int rk610_lcd_init(struct rk610_core_info *rk610_core_info)
-{
-    if(rk610_core_info->client == NULL){
-        printk("%s client == NULL FAIL\n",__FUNCTION__);
-        return -1;
-    }
-    RK610_DBG(&rk610_core_info->client->dev,"%s \n",__FUNCTION__);
-
-    g_lcd_inf = kmalloc(sizeof(struct rk610_lcd_info), GFP_KERNEL);
-    if(!g_lcd_inf)
-    {
-        dev_err(&rk610_core_info->client->dev, ">> rk610 inf kmalloc fail!");
-        return -ENOMEM;
-    }
-    memset(g_lcd_inf, 0, sizeof(struct rk610_lcd_info));
-
-    g_lcd_inf->client= rk610_core_info->client;
-    
-    rk610_core_info->lcd_pdata = (void *)g_lcd_inf;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	g_lcd_inf->early_suspend.suspend = rk610_lcd_early_suspend;
-	g_lcd_inf->early_suspend.resume = rk610_lcd_early_resume;
-	g_lcd_inf->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB- 1;
-	register_early_suspend(&g_lcd_inf->early_suspend);
-#endif
-    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
-    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
-    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
-    return 0;
-}
diff --git a/drivers/video/display/lcd/rk610_lcd.h b/drivers/video/display/lcd/rk610_lcd.h
deleted file mode 100644
index 8cdeef6..0000000
--- a/drivers/video/display/lcd/rk610_lcd.h
+++ /dev/null
@@ -1,214 +0,0 @@
-#ifndef _RK610_LCD_H
-#define _RK610_LCD_H
-#include <linux/mfd/rk610_core.h>
-#include "../screen/screen.h"
-#include <linux/earlysuspend.h>
-#define ENABLE      1
-#define DISABLE     0
-
-/*      LVDS config         */
-/*                  LVDS 外部连线接法                       */
-/*          LVDS_8BIT_1    LVDS_8BIT_2     LVDS_8BIT_3     LVDS_6BIT
-----------------------------------------------------------------------
-    TX0     R0              R2              R2              R0
-    TX1     R1              R3              R3              R1
-    TX2     R2              R4              R4              R2
-Y   TX3     R3              R5              R5              R3
-0   TX4     R4              R6              R6              R4
-    TX6     R5              R7              R7              R5
-    TX7     G0              G2              G2              G0
-----------------------------------------------------------------------
-    TX8     G1              G3              G3              G1
-    TX9     G2              G4              G4              G2
-Y   TX12    G3              G5              G5              G3
-1   TX13    G4              G6              G6              G4
-    TX14    G5              G7              G7              G5
-    TX15    B0              B2              B2              B0
-    TX18    B1              B3              B3              B1
-----------------------------------------------------------------------
-    TX19    B2              B4              B4              B2
-    TX20    B3              B5              B5              B3
-    TX21    B4              B6              B6              B4
-Y   TX22    B5              B7              B7              B5
-2   TX24    HSYNC           HSYNC           HSYNC           HSYNC
-    TX25    VSYNC           VSYNC           VSYNC           VSYNC
-    TX26    ENABLE          ENABLE          ENABLE          ENABLE
-----------------------------------------------------------------------    
-    TX27    R6              R0              GND             GND
-    TX5     R7              R1              GND             GND
-    TX10    G6              G0              GND             GND
-Y   TX11    G7              G1              GND             GND
-3   TX16    B6              B0              GND             GND
-    TX17    B7              B1              GND             GND
-    TX23    RSVD            RSVD            RSVD            RSVD
-----------------------------------------------------------------------        
-*/
-#define LVDS_8BIT_1     0x00
-#define LVDS_8BIT_2     0x01
-#define LVDS_8BIT_3     0x10
-#define LVDS_6BIT       0x11
-//LVDS lane input format
-#define DATA_D0_MSB         0
-#define DATA_D7_MSB         1
-//LVDS input source
-#define FROM_LCD1           0
-#define FROM_LCD0_OR_SCL    1
-
-/*      LCD1 config         */
-#define LCD1_AS_IN      0
-#define LCD1_AS_OUT     1
-
-//LCD1 output source
-#define LCD1_FROM_LCD0  0
-#define LCD1_FROM_SCL   1
-
-//SCALER config
-#define NOBYPASS    0
-#define BYPASS      1
-
-//SCALER PLL config
-#define S_PLL_PWR_ON    0
-#define S_PLL_PWR_DOWN  1
-
-/*      clock config        */
-#define S_PLL_FROM_DIV      0
-#define S_PLL_FROM_CLKIN    1
-#define S_PLL_DIV(x)        ((x)&0x7)
-/*********S_PLL_CON************/
-//S_PLL_CON0
-#define S_DIV_N(x)              (((x)&0xf)<<4)
-#define S_DIV_OD(x)             (((x)&3)<<0)
-//S_PLL_CON1
-#define S_DIV_M(x)              ((x)&0xff)
-//S_PLL_CON2
-#define S_PLL_UNLOCK            (0<<7)    //0:unlock 1:pll_lock
-#define S_PLL_LOCK              (1<<7)    //0:unlock 1:pll_lock
-#define S_PLL_PWR(x)            (((x)&1)<<2)    //0:POWER UP 1:POWER DOWN
-#define S_PLL_RESET(x)          (((x)&1)<<1)    //0:normal  1:reset M/N dividers
-#define S_PLL_BYPASS(x)          (((x)&1)<<0)    //0:normal  1:bypass
-//LVDS_CON0
-#define LVDS_OUT_CLK_PIN(x)     (((x)&1)<<7)    //clk enable pin, 0: enable
-#define LVDS_OUT_CLK_PWR_PIN(x) (((x)&1)<<6)    //clk pwr enable pin, 1: enable 
-#define LVDS_PLL_PWR_PIN(x)     (((x)&1)<<5)    //pll pwr enable pin, 0:enable 
-#define LVDS_BIASE_PWR(x)       (((x)&1)<<4)    //0: power down     1: normal work
-#define LVDS_LANE_IN_FORMAT(x)  (((x)&1)<<3)    //0: msb on D0  1:msb on D7
-#define LVDS_INPUT_SOURCE(x)    (((x)&1)<<2)    //0: from lcd1  1:from lcd0 or scaler
-#define LVDS_OUTPUT_FORMAT(x)   (((x)&3)<<0)    //00:8bit format-1  01:8bit format-2  10:8bit format-3   11:6bit format  
-//LVDS_CON1
-#define LVDS_OUT_ENABLE(x)      (((x)&0xf)<<4)  //0:output enable 1:output disable
-#define LVDS_TX_PWR_ENABLE(x)   (((x)&0xf)<<0)  //0:working mode  1:power down
-//LCD1_CON
-#define LCD1_OUT_ENABLE(x)      (((x)&1)<<1)    //0:lcd1 as input 1:lcd1 as output
-#define LCD1_OUT_SRC(x)         (((x)&1)<<0)    //0:from lcd0   1:from scaler
-//SCL_CON0
-#define SCL_BYPASS(x)           (((x)&1)<<4)    //0:not bypass  1:bypass
-#define SCL_DEN_INV(x)          (((x)&1)<<3)    //scl_den_inv
-#define SCL_H_V_SYNC_INV(x)     (((x)&1)<<2)    //scl_sync_inv
-#define SCL_OUT_CLK_INV(x)      (((x)&1)<<1)    //scl_dclk_inv
-#define SCL_ENABLE(x)           (((x)&1)<<0)    //scaler enable
-//SCL_CON1
-#define SCL_H_FACTOR_LSB(x)     ((x)&0xff)      //scl_h_factor[7:0]
-//SCL_CON2
-#define SCL_H_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_h_factor[13:8]
-//SCL_CON3
-#define SCL_V_FACTOR_LSB(x)     ((x)&0xff)      //scl_v_factor[7:0]
-//SCL_CON4
-#define SCL_V_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_v_factor[13:8]
-//SCL_CON5
-#define SCL_DSP_HST_LSB(x)      ((x)&0xff)      //dsp_frame_hst[7:0]
-//SCL_CON6
-#define SCL_DSP_HST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_hst[11:8]
-//SCL_CON7
-#define SCL_DSP_VST_LSB(x)      ((x)&0xff)      //dsp_frame_vst[7:0]
-//SCL_CON8
-#define SCL_DSP_VST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_vst[11:8]
-//SCL_CON9
-#define SCL_DSP_HTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_htotal[7:0]
-//SCL_CON10
-#define SCL_DSP_HTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
-//SCL_CON11
-#define SCL_DSP_HS_END(x)       ((x)&0xff)      //dsp_hs_end
-//SCL_CON12
-#define SCL_DSP_HACT_ST_LSB(x)      ((x)&0xff)      //dsp_hact_st[7:0]
-//SCL_CON13
-#define SCL_DSP_HACT_ST_MSB(x)      (((x)>>8)&0x3)      //dsp_hact_st[9:8]
-//SCL_CON14
-#define SCL_DSP_HACT_END_LSB(x)   ((x)&0xff)      //dsp_hact_end[7:0]
-//SCL_CON15
-#define SCL_DSP_HACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
-//SCL_CON16
-#define SCL_DSP_VTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_vtotal[7:0]
-//SCL_CON17
-#define SCL_DSP_VTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
-//SCL_CON18
-#define SCL_DSP_VS_END(x)       ((x)&0xff)      //dsp_vs_end
-//SCL_CON19
-#define SCL_DSP_VACT_ST(x)      ((x)&0xff)      //dsp_vact_st[7:0]
-//SCL_CON20
-#define SCL_DSP_VACT_END_LSB(x)   ((x)&0xff)      //dsp_vact_end[7:0]
-//SCL_CON21
-#define SCL_DSP_VACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
-//SCL_CON22
-#define SCL_H_BORD_ST_LSB(x)        ((x)&0xff)      //dsp_hbord_st[7:0]
-//SCL_CON23
-#define SCL_H_BORD_ST_MSB(x)        (((x)>>8)&0x3)      //dsp_hbord_st[9:8]
-//SCL_CON24
-#define SCL_H_BORD_END_LSB(x)        ((x)&0xff)      //dsp_hbord_end[7:0]
-//SCL_CON25
-#define SCL_H_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_hbord_end[11:8]
-//SCL_CON26
-#define SCL_V_BORD_ST(x)            ((x)&0xff)      //dsp_vbord_st[7:0]
-//SCL_CON27
-#define SCL_V_BORD_END_LSB(x)              ((x)&0xff)      //dsp_vbord_end[7:0]
-//SCL_CON25
-#define SCL_V_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_vbord_end[11:8]
-
-enum {
-    LCD_OUT_SCL,
-    LCD_OUT_BYPASS,
-    LCD_OUT_DISABLE,
-};
-struct rk610_pll_info{
-    u32 parent_rate;
-    u32 rate;
-    int m;
-    int n;
-    int od;
-};
-struct lcd_mode_inf{
-	int h_pw;
-	int h_bp;
-	int h_vd;
-	int h_fp;
-	int v_pw;
-	int v_bp;
-	int v_vd;
-	int v_fp;
-	int f_hst;
-	int f_vst;
-    struct rk610_pll_info pllclk;
-};
-struct scl_hv_info{
-    int scl_h ;
-    int scl_v;
-    };
-
-struct scl_info{
-    bool pll_pwr;
-    bool scl_pwr;
-    struct scl_hv_info scl_hv;
-};
-struct rk610_lcd_info{
-    int disp_mode;
-    
-    struct rk29fb_screen *screen;
-    struct scl_info scl_inf;
-    struct i2c_client *client;
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend		early_suspend;
-#endif
-};
-extern int rk610_lcd_init(struct rk610_core_info *rk610_core_info);
-extern int rk610_lcd_scaler_set_param(struct rk29fb_screen *screen,bool enable );
-#endif
diff --git a/drivers/video/display/screen/lcd_hsd07pfw1.c b/drivers/video/display/screen/lcd_hsd07pfw1.c
index 631b1a7..76a97e9 100755
--- a/drivers/video/display/screen/lcd_hsd07pfw1.c
+++ b/drivers/video/display/screen/lcd_hsd07pfw1.c
@@ -1,46 +1,294 @@
 #include <linux/fb.h>
 #include <linux/delay.h>
-#include "../../rk29_fb.h"
+#include <linux/rk_fb.h>
 #include <mach/gpio.h>
 #include <mach/iomux.h>
 #include <mach/board.h>
+#include "../../rockchip/hdmi/rk_hdmi.h"
 #include "screen.h"
 
+#ifdef CONFIG_RK610_LVDS
+#include "../transmitter/rk610_lcd.h"
+#endif
+
 
 /* Base */
-#define OUT_TYPE		SCREEN_RGB
+#ifdef CONFIG_RK610_LVDS
+#define OUT_TYPE	    	SCREEN_LVDS
+#define OUT_FORMAT      	LVDS_8BIT_1
+#else
+#define OUT_TYPE	    SCREEN_RGB
+#endif
 
 //#define OUT_FACE		OUT_D888_P666  
 #define OUT_FACE		OUT_P888  
-#define OUT_CLK			 45000000        // 65000000
+#define OUT_CLK			 50000000        // 65000000
 #define LCDC_ACLK        312000000//312000000           //29 lcdc axi DMA 频率
 
 /* Timing */
-#define H_PW			3
-#define H_BP			176
+#define H_PW			20
+#define H_BP			20
 #define H_VD			1024
-#define H_FP			0
+#define H_FP			280
 
-#define V_PW			1
-#define V_BP			25
+#define V_PW			2
+#define V_BP			2
 #define V_VD			600
-#define V_FP			0
+#define V_FP			34
 
 #define LCD_WIDTH       154//1024
 #define LCD_HEIGHT      91//600
 /* Other */
-#define DCLK_POL		0
+#define DCLK_POL		1
 #define SWAP_RB			0   
 
+int dsp_lut[256] ={
+		0x00000000, 0x00010101, 0x00020202, 0x00030303, 0x00040404, 0x00050505, 0x00060606, 0x00070707, 
+		0x00080808, 0x00090909, 0x000a0a0a, 0x000b0b0b, 0x000c0c0c, 0x000d0d0d, 0x000e0e0e, 0x000f0f0f, 
+		0x00101010, 0x00111111, 0x00121212, 0x00131313, 0x00141414, 0x00151515, 0x00161616, 0x00171717, 
+		0x00181818, 0x00191919, 0x001a1a1a, 0x001b1b1b, 0x001c1c1c, 0x001d1d1d, 0x001e1e1e, 0x001f1f1f, 
+		0x00202020, 0x00212121, 0x00222222, 0x00232323, 0x00242424, 0x00252525, 0x00262626, 0x00272727, 
+		0x00282828, 0x00292929, 0x002a2a2a, 0x002b2b2b, 0x002c2c2c, 0x002d2d2d, 0x002e2e2e, 0x002f2f2f, 
+		0x00303030, 0x00313131, 0x00323232, 0x00333333, 0x00343434, 0x00353535, 0x00363636, 0x00373737, 
+		0x00383838, 0x00393939, 0x003a3a3a, 0x003b3b3b, 0x003c3c3c, 0x003d3d3d, 0x003e3e3e, 0x003f3f3f, 
+		0x00404040, 0x00414141, 0x00424242, 0x00434343, 0x00444444, 0x00454545, 0x00464646, 0x00474747, 
+		0x00484848, 0x00494949, 0x004a4a4a, 0x004b4b4b, 0x004c4c4c, 0x004d4d4d, 0x004e4e4e, 0x004f4f4f, 
+		0x00505050, 0x00515151, 0x00525252, 0x00535353, 0x00545454, 0x00555555, 0x00565656, 0x00575757, 
+		0x00585858, 0x00595959, 0x005a5a5a, 0x005b5b5b, 0x005c5c5c, 0x005d5d5d, 0x005e5e5e, 0x005f5f5f, 
+		0x00606060, 0x00616161, 0x00626262, 0x00636363, 0x00646464, 0x00656565, 0x00666666, 0x00676767, 
+		0x00686868, 0x00696969, 0x006a6a6a, 0x006b6b6b, 0x006c6c6c, 0x006d6d6d, 0x006e6e6e, 0x006f6f6f, 
+		0x00707070, 0x00717171, 0x00727272, 0x00737373, 0x00747474, 0x00757575, 0x00767676, 0x00777777, 
+		0x00787878, 0x00797979, 0x007a7a7a, 0x007b7b7b, 0x007c7c7c, 0x007d7d7d, 0x007e7e7e, 0x007f7f7f, 
+		0x00808080, 0x00818181, 0x00828282, 0x00838383, 0x00848484, 0x00858585, 0x00868686, 0x00878787, 
+		0x00888888, 0x00898989, 0x008a8a8a, 0x008b8b8b, 0x008c8c8c, 0x008d8d8d, 0x008e8e8e, 0x008f8f8f, 
+		0x00909090, 0x00919191, 0x00929292, 0x00939393, 0x00949494, 0x00959595, 0x00969696, 0x00979797, 
+		0x00989898, 0x00999999, 0x009a9a9a, 0x009b9b9b, 0x009c9c9c, 0x009d9d9d, 0x009e9e9e, 0x009f9f9f, 
+		0x00a0a0a0, 0x00a1a1a1, 0x00a2a2a2, 0x00a3a3a3, 0x00a4a4a4, 0x00a5a5a5, 0x00a6a6a6, 0x00a7a7a7, 
+		0x00a8a8a8, 0x00a9a9a9, 0x00aaaaaa, 0x00ababab, 0x00acacac, 0x00adadad, 0x00aeaeae, 0x00afafaf, 
+		0x00b0b0b0, 0x00b1b1b1, 0x00b2b2b2, 0x00b3b3b3, 0x00b4b4b4, 0x00b5b5b5, 0x00b6b6b6, 0x00b7b7b7, 
+		0x00b8b8b8, 0x00b9b9b9, 0x00bababa, 0x00bbbbbb, 0x00bcbcbc, 0x00bdbdbd, 0x00bebebe, 0x00bfbfbf, 
+		0x00c0c0c0, 0x00c1c1c1, 0x00c2c2c2, 0x00c3c3c3, 0x00c4c4c4, 0x00c5c5c5, 0x00c6c6c6, 0x00c7c7c7, 
+		0x00c8c8c8, 0x00c9c9c9, 0x00cacaca, 0x00cbcbcb, 0x00cccccc, 0x00cdcdcd, 0x00cecece, 0x00cfcfcf, 
+		0x00d0d0d0, 0x00d1d1d1, 0x00d2d2d2, 0x00d3d3d3, 0x00d4d4d4, 0x00d5d5d5, 0x00d6d6d6, 0x00d7d7d7, 
+		0x00d8d8d8, 0x00d9d9d9, 0x00dadada, 0x00dbdbdb, 0x00dcdcdc, 0x00dddddd, 0x00dedede, 0x00dfdfdf, 
+		0x00e0e0e0, 0x00e1e1e1, 0x00e2e2e2, 0x00e3e3e3, 0x00e4e4e4, 0x00e5e5e5, 0x00e6e6e6, 0x00e7e7e7, 
+		0x00e8e8e8, 0x00e9e9e9, 0x00eaeaea, 0x00ebebeb, 0x00ececec, 0x00ededed, 0x00eeeeee, 0x00efefef, 
+		0x00f0f0f0, 0x00f1f1f1, 0x00f2f2f2, 0x00f3f3f3, 0x00f4f4f4, 0x00f5f5f5, 0x00f6f6f6, 0x00f7f7f7, 
+		0x00f8f8f8, 0x00f9f9f9, 0x00fafafa, 0x00fbfbfb, 0x00fcfcfc, 0x00fdfdfd, 0x00fefefe, 0x00ffffff, 
+};
+
+#if  defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& defined(CONFIG_RK610_LVDS)
+
+/* scaler Timing    */
+//1920*1080*60
+
+#define S_OUT_CLK		SCALE_RATE(148500000,42187500) //m=16 n=9 no=4
+#define S_H_PW			10
+#define S_H_BP			10
+#define S_H_VD			1024
+#define S_H_FP			81
+
+#define S_V_PW			5
+#define S_V_BP			5
+#define S_V_VD			600
+#define S_V_FP			15
+
+#define S_H_ST			0	
+#define S_V_ST		    15 
+
+//1920*1080*50
+#define S1_OUT_CLK		SCALE_RATE(148500000,41250000)  //m=17 n=11 no=4 
+#define S1_H_PW			100
+#define S1_H_BP			100
+#define S1_H_VD			1024
+#define S1_H_FP			96
+
+#define S1_V_PW			5
+#define S1_V_BP			5
+#define S1_V_VD			600
+#define S1_V_FP			15
+
+#define S1_H_ST		    0	
+#define S1_V_ST			15
+
+//1024*720*60
+#define S2_OUT_CLK		SCALE_RATE(74250000,42187500)  //m=32 n=9 no=4
+#define S2_H_PW			10
+#define S2_H_BP			10
+#define S2_H_VD			1024
+#define S2_H_FP			81
+
+#define S2_V_PW			5
+#define S2_V_BP			5
+#define S2_V_VD			600
+#define S2_V_FP			15
+
+#define S2_H_ST			440
+#define S2_V_ST			19
+
+//1024*720*50
+
+#define S3_OUT_CLK		SCALE_RATE(74250000,41250000)   // m=34 n=11 no=4
+#define S3_H_PW			100
+#define S3_H_BP			100
+#define S3_H_VD			1024
+#define S3_H_FP			96
+
+#define S3_V_PW		5
+#define S3_V_BP			5
+#define S3_V_VD			600
+#define S3_V_FP		15
+
+#define S3_H_ST			459
+#define S3_V_ST			19
+
+//720*576*50
+#define S4_OUT_CLK		SCALE_RATE(27000000,42187500)  //m=75 n=4 no=8
+#define S4_H_PW			100
+#define S4_H_BP			100
+#define S4_H_VD			1024
+#define S4_H_FP		72
+
+#define S4_V_PW			10
+#define S4_V_BP			10
+#define S4_V_VD			600
+#define S4_V_FP			31
+
+#define S4_H_ST			81
+#define S4_V_ST			37
+
+//720*480*60
+#define S5_OUT_CLK		SCALE_RATE(27000000,45000000)  //m=100 n=9 no=4
+#define S5_H_PW			50
+#define S5_H_BP			50
+#define S5_H_VD			1024
+#define S5_H_FP			20
+
+#define S5_V_PW			10
+#define S5_V_BP			10
+#define S5_V_VD			600
+#define S5_V_FP			35
+
+#define S5_H_ST			476
+#define S5_V_ST			31
+
+#define S_DCLK_POL       0
+
+static int set_scaler_info(struct rk29fb_screen *screen, u8 hdmi_resolution)
+{
+    screen->s_clk_inv = S_DCLK_POL;
+    screen->s_den_inv = 0;
+    screen->s_hv_sync_inv = 0;
+    switch(hdmi_resolution){
+    case HDMI_1920x1080p_60Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S_OUT_CLK;
+	        screen->s_hsync_len = S_H_PW;
+	        screen->s_left_margin = S_H_BP;
+	        screen->s_right_margin = S_H_FP;
+	        screen->s_hsync_len = S_H_PW;
+	        screen->s_upper_margin = S_V_BP;
+	        screen->s_lower_margin = S_V_FP;
+	        screen->s_vsync_len = S_V_PW;
+	        screen->s_hsync_st = S_H_ST;
+	        screen->s_vsync_st = S_V_ST;
+	        break;
+	case HDMI_1920x1080p_50Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S1_OUT_CLK;
+	        screen->s_hsync_len = S1_H_PW;
+	        screen->s_left_margin = S1_H_BP;
+	        screen->s_right_margin = S1_H_FP;
+	        screen->s_hsync_len = S1_H_PW;
+	        screen->s_upper_margin = S1_V_BP;
+	        screen->s_lower_margin = S1_V_FP;
+	        screen->s_vsync_len = S1_V_PW;
+	        screen->s_hsync_st = S1_H_ST;
+	        screen->s_vsync_st = S1_V_ST;
+	        break;
+	case HDMI_1280x720p_60Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S2_OUT_CLK;
+	        screen->s_hsync_len = S2_H_PW;
+	        screen->s_left_margin = S2_H_BP;
+	        screen->s_right_margin = S2_H_FP;
+	        screen->s_hsync_len = S2_H_PW;
+	        screen->s_upper_margin = S2_V_BP;
+	        screen->s_lower_margin = S2_V_FP;
+	        screen->s_vsync_len = S2_V_PW;
+	        screen->s_hsync_st = S2_H_ST;
+	        screen->s_vsync_st = S2_V_ST;
+	        break;
+    case HDMI_1280x720p_50Hz:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S3_OUT_CLK;
+	        screen->s_hsync_len = S3_H_PW;
+	        screen->s_left_margin = S3_H_BP;
+	        screen->s_right_margin = S3_H_FP;
+	        screen->s_hsync_len = S3_H_PW;
+	        screen->s_upper_margin = S3_V_BP;
+	        screen->s_lower_margin = S3_V_FP;
+	        screen->s_vsync_len = S3_V_PW;
+	        screen->s_hsync_st = S3_H_ST;
+	        screen->s_vsync_st = S3_V_ST;
+	        break;
+    case HDMI_720x576p_50Hz_4_3:
+    case HDMI_720x576p_50Hz_16_9:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S4_OUT_CLK;
+	        screen->s_hsync_len = S4_H_PW;
+	        screen->s_left_margin = S4_H_BP;
+	        screen->s_right_margin = S4_H_FP;
+	        screen->s_hsync_len = S4_H_PW;
+	        screen->s_upper_margin = S4_V_BP;
+	        screen->s_lower_margin = S4_V_FP;
+	        screen->s_vsync_len = S4_V_PW;
+	        screen->s_hsync_st = S4_H_ST;
+	        screen->s_vsync_st = S4_V_ST;
+	        break;
+    case HDMI_720x480p_60Hz_16_9:
+    case HDMI_720x480p_60Hz_4_3:
+                /* Scaler Timing    */
+            screen->hdmi_resolution = hdmi_resolution;
+	        screen->s_pixclock = S5_OUT_CLK;
+	        screen->s_hsync_len = S5_H_PW;
+	        screen->s_left_margin = S5_H_BP;
+	        screen->s_right_margin = S5_H_FP;
+	        screen->s_hsync_len = S5_H_PW;
+	        screen->s_upper_margin = S5_V_BP;
+	        screen->s_lower_margin = S5_V_FP;
+	        screen->s_vsync_len = S5_V_PW;
+	        screen->s_hsync_st = S5_H_ST;
+	        screen->s_vsync_st = S5_V_ST;
+	        break;
+    default :
+            printk("%s lcd not support dual display at this hdmi resolution %d \n",__func__,hdmi_resolution);
+            return -1;
+	        break;
+	}
+	
+	return 0;
+}
+#else
+#define set_scaler_info  NULL
+#endif
 void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
 {
-    /* screen type & face */
-    screen->type = OUT_TYPE;
-    screen->face = OUT_FACE;
-
-    /* Screen size */
-    screen->x_res = H_VD;
-    screen->y_res = V_VD;
+	/* screen type & face */
+	screen->face = OUT_FACE;
+	screen->type = OUT_TYPE;
+#ifdef CONFIG_RK610_LVDS
+	screen->hw_format = OUT_FORMAT;
+#endif
+	
+	/* Screen size */
+	screen->x_res = H_VD;
+	screen->y_res = V_VD;
 
     screen->width = LCD_WIDTH;
     screen->height = LCD_HEIGHT;
@@ -68,9 +316,14 @@ void set_lcd_info(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info )
     screen->swap_delta = 0;
     screen->swap_dumy = 0;
 
-    /* Operation function*/
-    screen->init = NULL;
-    screen->standby = NULL;
+	/* Operation function*/
+	screen->init = NULL;
+	screen->standby = NULL;
+	//screen->dsp_lut = dsp_lut;
+	screen->sscreen_get = set_scaler_info;
+#ifdef CONFIG_RK610_LVDS
+    screen->sscreen_set = rk610_lcd_scaler_set_param;
+#endif
 }
 
 
diff --git a/drivers/video/display/transmitter/Kconfig b/drivers/video/display/transmitter/Kconfig
new file mode 100755
index 0000000..5565f72
--- /dev/null
+++ b/drivers/video/display/transmitter/Kconfig
@@ -0,0 +1,6 @@
+config RK610_LVDS
+	bool "RK610(Jetta) lvds transmitter support"
+	depends on MFD_RK610
+	default y if MFD_RK610
+	help
+		Support Jetta(RK610) to output LCD1 and LVDS.
diff --git a/drivers/video/display/transmitter/Makefile b/drivers/video/display/transmitter/Makefile
new file mode 100755
index 0000000..75adab5
--- /dev/null
+++ b/drivers/video/display/transmitter/Makefile
@@ -0,0 +1,4 @@
+#
+# Makefile for the jetta tv control.
+#
+obj-$(CONFIG_RK610_LVDS)			+= rk610_lcd.o
diff --git a/drivers/video/display/transmitter/rk610_lcd.c b/drivers/video/display/transmitter/rk610_lcd.c
new file mode 100755
index 0000000..e787f6d
--- /dev/null
+++ b/drivers/video/display/transmitter/rk610_lcd.c
@@ -0,0 +1,410 @@
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <mach/board.h>
+#include "rk610_lcd.h"
+#include <linux/mfd/rk610_core.h>
+#include <linux/rk_fb.h>
+#include "../../rockchip/hdmi/rk_hdmi.h"
+
+static struct rk610_lcd_info *g_lcd_inf = NULL;
+//static int rk610_scaler_read_p0_reg(struct i2c_client *client, char reg, char *val)
+//{
+	//return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+//}
+
+static int rk610_scaler_write_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+static void rk610_scaler_pll_enable(struct i2c_client *client)
+{
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+
+    g_lcd_inf->scl_inf.pll_pwr = ENABLE;
+    
+    c = S_PLL_PWR(0)|S_PLL_RESET(0)|S_PLL_BYPASS(0);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+}
+static void rk610_scaler_pll_disable(struct i2c_client *client)
+{
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
+
+    c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+}
+static void rk610_scaler_enable(struct i2c_client *client)
+{
+    char c;
+    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    g_lcd_inf->scl_inf.scl_pwr = ENABLE;
+    #if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(g_lcd_inf->screen !=NULL){
+        den_inv = g_lcd_inf->screen->s_den_inv;
+        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
+        clk_inv = g_lcd_inf->screen->s_clk_inv;
+    }
+    #endif
+    c= SCL_BYPASS(0) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(ENABLE);  
+	rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+}
+static void rk610_scaler_disable(struct i2c_client *client)
+{
+    char c;
+    bool den_inv = 0,hv_sync_inv = 0,clk_inv = 0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
+    #if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(g_lcd_inf->screen !=NULL){
+        den_inv = g_lcd_inf->screen->s_den_inv;
+        hv_sync_inv = g_lcd_inf->screen->s_hv_sync_inv;
+        clk_inv = g_lcd_inf->screen->s_clk_inv;
+    }
+    #endif
+    c= SCL_BYPASS(1) |SCL_DEN_INV(den_inv) |SCL_H_V_SYNC_INV(hv_sync_inv) |SCL_OUT_CLK_INV(clk_inv) |SCL_ENABLE(DISABLE); 
+    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+}
+
+static int rk610_output_config(struct i2c_client *client, u16 screen_type, bool enable)
+{
+    char c=0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+     if(SCREEN_LVDS == screen_type){
+        c = LVDS_OUT_CLK_PIN(enable) |LVDS_OUT_CLK_PWR_PIN(!
+enable) |LVDS_PLL_PWR_PIN(enable) \
+            |LVDS_LANE_IN_FORMAT(DATA_D0_MSB) |LVDS_INPUT_SOURCE(FROM_LCD0_OR_SCL) \
+            |LVDS_OUTPUT_FORMAT(0) | LVDS_BIASE_PWR(1);
+	    rk610_scaler_write_p0_reg(client, LVDS_CON0, &c);
+c = LVDS_OUT_ENABLE(enable? 0xff:0x0) |LVDS_TX_PWR_ENABLE(enable? 0xff:0x0);
+	    rk610_scaler_write_p0_reg(client, LVDS_CON1, &c);
+	}else if(SCREEN_RGB == screen_type){
+        c = LCD1_OUT_ENABLE(LCD1_AS_OUT) | LCD1_OUT_SRC(enable?LCD1_FROM_SCL : LCD1_FROM_LCD0);
+	    rk610_scaler_write_p0_reg(client, LCD1_CON, &c);
+	}
+	return 0;
+}
+#if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+static int rk610_scaler_pll_set(struct i2c_client *client,struct rk29fb_screen *screen,u32 clkin )
+{
+    char c=0;
+    char M=0,N=0,OD=0;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+	/***************SET SCALER PLL FROM CLKIN ,DIV 0*/
+    if(screen->s_pixclock != 0){
+        OD = (screen->s_pixclock)&0x3;
+        N = (screen->s_pixclock >>4)&0xf;
+        M = (screen->s_pixclock >>8)&0xff;
+    }else {
+        RK610_ERR(&client->dev,"RK610 Scaler pll not support rate \n");
+    }
+    c = S_PLL_FROM_DIV<<3 | S_PLL_DIV(0);
+	rk610_scaler_write_p0_reg(client, CLOCK_CON0, &c);
+    
+    c = S_DIV_N(N)| S_DIV_OD(OD);
+	rk610_scaler_write_p0_reg(client, S_PLL_CON0, &c);
+    c = S_DIV_M(M);
+    rk610_scaler_write_p0_reg(client, S_PLL_CON1, &c);
+    rk610_scaler_pll_enable(client);
+	return 0;
+}
+
+
+static int  scale_hv_factor(struct i2c_client *client ,u32 Hin_act, u32 Hout_act, u32 Vin_act, u32 Vout_act)
+   {
+    char c;
+  	u32 hfactor_f,vfactor_f,scl_factor_f;
+	int  hfactor;
+	int  vfactor;
+	struct scl_hv_info  HV2;
+	hfactor_f = ((Hin_act-1)*4096)/(Hout_act-1);
+    if(hfactor_f==4096)
+	    {hfactor = 0x1000;}
+ 	else if(hfactor_f>(int)hfactor_f)
+	  	{hfactor = (int)hfactor_f+1;}
+	else
+	  	{hfactor = (int)hfactor_f;}
+	  
+	scl_factor_f = Vin_act/Vout_act;
+	if(scl_factor_f<2)
+	    {vfactor_f = ((Vin_act-1)*4096)/(Vout_act-1);}
+	else
+	  	{vfactor_f = ((Vin_act-2)*4096)/(Vout_act-1);} 
+	if(vfactor_f==4096)
+	    {vfactor = 0x1000;}
+	else if(vfactor_f>(int)vfactor_f)
+	  	{vfactor = (int)vfactor_f+1;}
+	else
+	  	{vfactor = (int)vfactor_f;}
+	  
+    HV2.scl_h= hfactor;
+    HV2.scl_v= vfactor; 
+           /*       SCL FACTOR          */
+    c = SCL_H_FACTOR_LSB(HV2.scl_h);
+	rk610_scaler_write_p0_reg(client, SCL_CON1, &c);
+    c = SCL_H_FACTOR_MSB(HV2.scl_h);
+	rk610_scaler_write_p0_reg(client, SCL_CON2, &c);
+
+    c = SCL_V_FACTOR_LSB(HV2.scl_v);
+	rk610_scaler_write_p0_reg(client, SCL_CON3, &c);
+    c = SCL_V_FACTOR_MSB(HV2.scl_v);
+	rk610_scaler_write_p0_reg(client, SCL_CON4, &c);
+  	return 0;
+   }
+
+static int rk610_scaler_fator_config(struct i2c_client *client ,struct rk29fb_screen *screen)
+{
+    switch(screen->hdmi_resolution){
+        case HDMI_1920x1080p_60Hz:
+        case HDMI_1920x1080p_50Hz:
+            rk610_scaler_pll_set(client,screen,148500000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,1920,screen->x_res,1080,screen->y_res);
+            break;
+        case HDMI_1280x720p_60Hz:
+        case HDMI_1280x720p_50Hz:
+            rk610_scaler_pll_set(client,screen,74250000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,1280,screen->x_res,720,screen->y_res);
+        break;
+        case HDMI_720x576p_50Hz_16_9:
+        case HDMI_720x576p_50Hz_4_3:
+            rk610_scaler_pll_set(client,screen,27000000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,720,screen->x_res,576,screen->y_res);
+            break;
+        case HDMI_720x480p_60Hz_16_9:
+        case HDMI_720x480p_60Hz_4_3:
+            rk610_scaler_pll_set(client,screen,27000000);
+            /***************set scaler factor********************/
+            scale_hv_factor(client,720,screen->x_res,480,screen->y_res);
+        break;
+    default :
+        RK610_ERR(&client->dev,"RK610 not support dual display at hdmi resolution=%d \n",screen->hdmi_resolution); 
+        return -1;
+        break;
+    }
+    return 0;
+}
+static int rk610_scaler_output_timing_config(struct i2c_client *client,struct rk29fb_screen *screen)
+{
+    char c;
+    int h_st = screen->s_hsync_st;
+    int hs_end = screen->s_hsync_len;
+    int h_act_st = hs_end + screen->s_left_margin;
+    int xres = screen->x_res;
+    int h_act_end = h_act_st + xres;
+    int h_total = h_act_end + screen->s_right_margin;
+    int v_st = screen->s_vsync_st;
+    int vs_end = screen->s_vsync_len;
+    int v_act_st = vs_end + screen->s_upper_margin;
+    int yres = screen->y_res;    
+    int v_act_end = v_act_st + yres;
+    int v_total = v_act_end + screen->s_lower_margin;
+
+    /*      SCL display Frame start point   */
+    c = SCL_DSP_HST_LSB(h_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON5, &c);
+    c = SCL_DSP_HST_MSB(h_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON6, &c);
+
+    c = SCL_DSP_VST_LSB(v_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON7, &c);
+    c = SCL_DSP_VST_MSB(v_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON8, &c);
+    /*      SCL output timing       */
+
+    c = SCL_DSP_HTOTAL_LSB(h_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON9, &c);
+    c = SCL_DSP_HTOTAL_MSB(h_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON10, &c);
+
+    c = SCL_DSP_HS_END(hs_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON11, &c);
+
+    c = SCL_DSP_HACT_ST_LSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON12, &c);
+    c = SCL_DSP_HACT_ST_MSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON13, &c);
+
+    c = SCL_DSP_HACT_END_LSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON14, &c);
+    c = SCL_DSP_HACT_END_MSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON15, &c);
+
+    c = SCL_DSP_VTOTAL_LSB(v_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON16, &c);
+    c = SCL_DSP_VTOTAL_MSB(v_total);
+	rk610_scaler_write_p0_reg(client, SCL_CON17, &c);
+
+    c = SCL_DSP_VS_END(vs_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON18, &c);
+
+    c = SCL_DSP_VACT_ST(v_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON19, &c);
+
+    c = SCL_DSP_VACT_END_LSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON20, &c);
+    c = SCL_DSP_VACT_END_MSB(v_act_end); 
+	rk610_scaler_write_p0_reg(client, SCL_CON21, &c);
+ 
+    c = SCL_H_BORD_ST_LSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON22, &c);
+    c = SCL_H_BORD_ST_MSB(h_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON23, &c);
+
+    c = SCL_H_BORD_END_LSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON24, &c);
+    c = SCL_H_BORD_END_MSB(h_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON25, &c);
+
+    c = SCL_V_BORD_ST(v_act_st);
+	rk610_scaler_write_p0_reg(client, SCL_CON26, &c);
+
+    c = SCL_V_BORD_END_LSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON27, &c);
+    c = SCL_V_BORD_END_MSB(v_act_end);
+	rk610_scaler_write_p0_reg(client, SCL_CON28, &c);
+	
+	return 0;
+}
+static int rk610_scaler_chg(struct i2c_client *client ,struct rk29fb_screen *screen)
+{
+
+    RK610_DBG(&client->dev,"%s screen->hdmi_resolution=%d\n",__FUNCTION__,screen->hdmi_resolution);
+    rk610_scaler_fator_config(client,screen);
+    rk610_scaler_enable(client);
+    rk610_scaler_output_timing_config(client,screen); 
+    
+    return 0;
+
+}
+#endif
+static int rk610_lcd_scaler_bypass(struct i2c_client *client,bool enable)//enable:0 bypass 1: scale
+{
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    rk610_scaler_disable(client);       
+    rk610_scaler_pll_disable(client);
+    
+    return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void rk610_lcd_early_suspend(struct early_suspend *h)
+{
+    struct i2c_client *client = g_lcd_inf->client;
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+  //  if(g_lcd_inf->screen != NULL){
+		printk("%s..suspend\n",__FUNCTION__);
+        rk610_output_config(client, SCREEN_LVDS, 1);
+  //  }
+
+#if 0
+    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
+        c= SCL_BYPASS(1) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(DISABLE); 
+        rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+    }
+    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
+        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+    }
+#endif
+}
+
+static void rk610_lcd_early_resume(struct early_suspend *h)
+{
+    struct i2c_client *client = g_lcd_inf->client;
+    char c;
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+
+   // if(g_lcd_inf->screen != NULL){
+		printk("%s..resuem\n",__FUNCTION__);
+        rk610_output_config(client, SCREEN_LVDS, 0);
+  //  }
+#if 0
+    if(ENABLE == g_lcd_inf->scl_inf.scl_pwr){
+        c= SCL_BYPASS(0) |SCL_DEN_INV(0) |SCL_H_V_SYNC_INV(0) |SCL_OUT_CLK_INV(0) |SCL_ENABLE(ENABLE);  
+	    rk610_scaler_write_p0_reg(client, SCL_CON0, &c);
+    }
+    if(ENABLE == g_lcd_inf->scl_inf.pll_pwr ){
+        c = S_PLL_PWR(1) |S_PLL_RESET(0) |S_PLL_BYPASS(1);
+	    rk610_scaler_write_p0_reg(client, S_PLL_CON2, &c);
+    }
+#endif
+}
+#endif
+int rk610_lcd_scaler_set_param(struct rk29fb_screen *screen,bool enable )//enable:0 bypass 1: scale
+{
+    int ret=0;
+    struct i2c_client *client = g_lcd_inf->client;
+    if(client == NULL){
+        printk("%s client == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    if(screen == NULL){
+        printk("%s screen == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    RK610_DBG(&client->dev,"%s \n",__FUNCTION__);
+    
+    g_lcd_inf->screen = screen;
+    
+#if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+    if(enable == 1){
+        g_lcd_inf->disp_mode = LCD_OUT_SCL;
+        //rk610_output_config(client,screen,LCD_OUT_SCL);
+        //rk610_output_config(client,screen,1);
+        ret = rk610_scaler_chg(client,screen);
+	}
+	else 
+#endif
+	{
+	    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
+	    //rk610_output_config(client,screen,LCD_OUT_BYPASS);
+	    //rk610_output_config(client,screen,0);
+	    ret = rk610_lcd_scaler_bypass(client,enable);
+	}
+	return ret;
+}
+int rk610_lcd_init(struct rk610_core_info *rk610_core_info)
+{
+	int ret=0;
+    if(rk610_core_info->client == NULL){
+        printk("%s client == NULL FAIL\n",__FUNCTION__);
+        return -1;
+    }
+    RK610_DBG(&rk610_core_info->client->dev,"%s \n",__FUNCTION__);
+
+    g_lcd_inf = kmalloc(sizeof(struct rk610_lcd_info), GFP_KERNEL);
+    if(!g_lcd_inf)
+    {
+        dev_err(&rk610_core_info->client->dev, ">> rk610 inf kmalloc fail!");
+        return -ENOMEM;
+    }
+    memset(g_lcd_inf, 0, sizeof(struct rk610_lcd_info));
+
+    g_lcd_inf->client= rk610_core_info->client;
+    
+    rk610_core_info->lcd_pdata = (void *)g_lcd_inf;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	g_lcd_inf->early_suspend.suspend = rk610_lcd_early_suspend;
+	g_lcd_inf->early_suspend.resume = rk610_lcd_early_resume;
+	g_lcd_inf->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB- 1;
+	register_early_suspend(&g_lcd_inf->early_suspend);
+#endif
+    g_lcd_inf->scl_inf.pll_pwr = DISABLE;
+    g_lcd_inf->scl_inf.scl_pwr = DISABLE;
+    g_lcd_inf->disp_mode = LCD_OUT_BYPASS;
+
+    rk610_output_config(rk610_core_info->client,SCREEN_LVDS,0);
+	ret = rk610_lcd_scaler_bypass(rk610_core_info->client,0);
+    return ret;
+}
diff --git a/drivers/video/display/transmitter/rk610_lcd.h b/drivers/video/display/transmitter/rk610_lcd.h
new file mode 100755
index 0000000..83dd0b9
--- /dev/null
+++ b/drivers/video/display/transmitter/rk610_lcd.h
@@ -0,0 +1,270 @@
+#ifndef _RK610_LCD_H
+#define _RK610_LCD_H
+#include <linux/mfd/rk610_core.h>
+#include "../screen/screen.h"
+#include <linux/earlysuspend.h>
+#define ENABLE      1
+#define DISABLE     0
+
+/*      LVDS config         */
+/*                  LVDS 外部连线接法                       */
+/*          LVDS_8BIT_1    LVDS_8BIT_2     LVDS_8BIT_3     LVDS_6BIT
+----------------------------------------------------------------------
+    TX0     R0              R2              R2              R0
+    TX1     R1              R3              R3              R1
+    TX2     R2              R4              R4              R2
+Y   TX3     R3              R5              R5              R3
+0   TX4     R4              R6              R6              R4
+    TX6     R5              R7              R7              R5
+    TX7     G0              G2              G2              G0
+----------------------------------------------------------------------
+    TX8     G1              G3              G3              G1
+    TX9     G2              G4              G4              G2
+Y   TX12    G3              G5              G5              G3
+1   TX13    G4              G6              G6              G4
+    TX14    G5              G7              G7              G5
+    TX15    B0              B2              B2              B0
+    TX18    B1              B3              B3              B1
+----------------------------------------------------------------------
+    TX19    B2              B4              B4              B2
+    TX20    B3              B5              B5              B3
+    TX21    B4              B6              B6              B4
+Y   TX22    B5              B7              B7              B5
+2   TX24    HSYNC           HSYNC           HSYNC           HSYNC
+    TX25    VSYNC           VSYNC           VSYNC           VSYNC
+    TX26    ENABLE          ENABLE          ENABLE          ENABLE
+----------------------------------------------------------------------    
+    TX27    R6              R0              GND             GND
+    TX5     R7              R1              GND             GND
+    TX10    G6              G0              GND             GND
+Y   TX11    G7              G1              GND             GND
+3   TX16    B6              B0              GND             GND
+    TX17    B7              B1              GND             GND
+    TX23    RSVD            RSVD            RSVD            RSVD
+----------------------------------------------------------------------        
+*/
+#define LVDS_8BIT_1     0x00
+#define LVDS_8BIT_2     0x01
+#define LVDS_8BIT_3     0x10
+#define LVDS_6BIT       0x11
+//LVDS lane input format
+#define DATA_D0_MSB         0
+#define DATA_D7_MSB         1
+//LVDS input source
+#define FROM_LCD1           0
+#define FROM_LCD0_OR_SCL    1
+
+/*      LCD1 config         */
+#define LCD1_AS_IN      0
+#define LCD1_AS_OUT     1
+
+//LCD1 output source
+#define LCD1_FROM_LCD0  0
+#define LCD1_FROM_SCL   1
+
+//SCALER config
+#define NOBYPASS    0
+#define BYPASS      1
+
+//SCALER PLL config
+#define S_PLL_PWR_ON    0
+#define S_PLL_PWR_DOWN  1
+
+/*      clock config        */
+#define S_PLL_FROM_DIV      0
+#define S_PLL_FROM_CLKIN    1
+#define S_PLL_DIV(x)        ((x)&0x7)
+/*********S_PLL_CON************/
+//S_PLL_CON0
+#define S_DIV_N(x)              (((x)&0xf)<<4)
+#define S_DIV_OD(x)             (((x)&3)<<0)
+//S_PLL_CON1
+#define S_DIV_M(x)              ((x)&0xff)
+//S_PLL_CON2
+#define S_PLL_UNLOCK            (0<<7)    //0:unlock 1:pll_lock
+#define S_PLL_LOCK              (1<<7)    //0:unlock 1:pll_lock
+#define S_PLL_PWR(x)            (((x)&1)<<2)    //0:POWER UP 1:POWER DOWN
+#define S_PLL_RESET(x)          (((x)&1)<<1)    //0:normal  1:reset M/N dividers
+#define S_PLL_BYPASS(x)          (((x)&1)<<0)    //0:normal  1:bypass
+//LVDS_CON0
+#define LVDS_OUT_CLK_PIN(x)     (((x)&1)<<7)    //clk enable pin, 0: enable
+#define LVDS_OUT_CLK_PWR_PIN(x) (((x)&1)<<6)    //clk pwr enable pin, 1: enable 
+#define LVDS_PLL_PWR_PIN(x)     (((x)&1)<<5)    //pll pwr enable pin, 0:enable 
+#define LVDS_BIASE_PWR(x)       (((x)&1)<<4)    //0: power down     1: normal work
+#define LVDS_LANE_IN_FORMAT(x)  (((x)&1)<<3)    //0: msb on D0  1:msb on D7
+#define LVDS_INPUT_SOURCE(x)    (((x)&1)<<2)    //0: from lcd1  1:from lcd0 or scaler
+#define LVDS_OUTPUT_FORMAT(x)   (((x)&3)<<0)    //00:8bit format-1  01:8bit format-2  10:8bit format-3   11:6bit format  
+//LVDS_CON1
+#define LVDS_OUT_ENABLE(x)      (((x)&0xf)<<4)  //0:output enable 1:output disable
+#define LVDS_TX_PWR_ENABLE(x)   (((x)&0xf)<<0)  //0:working mode  1:power down
+//LCD1_CON
+#define LCD1_OUT_ENABLE(x)      (((x)&1)<<1)    //0:lcd1 as input 1:lcd1 as output
+#define LCD1_OUT_SRC(x)         (((x)&1)<<0)    //0:from lcd0   1:from scaler
+//SCL_CON0
+#define SCL_BYPASS(x)           (((x)&1)<<4)    //0:not bypass  1:bypass
+#define SCL_DEN_INV(x)          (((x)&1)<<3)    //scl_den_inv
+#define SCL_H_V_SYNC_INV(x)     (((x)&1)<<2)    //scl_sync_inv
+#define SCL_OUT_CLK_INV(x)      (((x)&1)<<1)    //scl_dclk_inv
+#define SCL_ENABLE(x)           (((x)&1)<<0)    //scaler enable
+//SCL_CON1
+#define SCL_H_FACTOR_LSB(x)     ((x)&0xff)      //scl_h_factor[7:0]
+//SCL_CON2
+#define SCL_H_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_h_factor[13:8]
+//SCL_CON3
+#define SCL_V_FACTOR_LSB(x)     ((x)&0xff)      //scl_v_factor[7:0]
+//SCL_CON4
+#define SCL_V_FACTOR_MSB(x)     (((x)>>8)&0x3f)      //scl_v_factor[13:8]
+//SCL_CON5
+#define SCL_DSP_HST_LSB(x)      ((x)&0xff)      //dsp_frame_hst[7:0]
+//SCL_CON6
+#define SCL_DSP_HST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_hst[11:8]
+//SCL_CON7
+#define SCL_DSP_VST_LSB(x)      ((x)&0xff)      //dsp_frame_vst[7:0]
+//SCL_CON8
+#define SCL_DSP_VST_MSB(x)      (((x)>>8)&0xf)       //dsp_frame_vst[11:8]
+//SCL_CON9
+#define SCL_DSP_HTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_htotal[7:0]
+//SCL_CON10
+#define SCL_DSP_HTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
+//SCL_CON11
+#define SCL_DSP_HS_END(x)       ((x)&0xff)      //dsp_hs_end
+//SCL_CON12
+#define SCL_DSP_HACT_ST_LSB(x)      ((x)&0xff)      //dsp_hact_st[7:0]
+//SCL_CON13
+#define SCL_DSP_HACT_ST_MSB(x)      (((x)>>8)&0x3)      //dsp_hact_st[9:8]
+//SCL_CON14
+#define SCL_DSP_HACT_END_LSB(x)   ((x)&0xff)      //dsp_hact_end[7:0]
+//SCL_CON15
+#define SCL_DSP_HACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_htotal[11:8]
+//SCL_CON16
+#define SCL_DSP_VTOTAL_LSB(x)   ((x)&0xff)      //dsp_frame_vtotal[7:0]
+//SCL_CON17
+#define SCL_DSP_VTOTAL_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
+//SCL_CON18
+#define SCL_DSP_VS_END(x)       ((x)&0xff)      //dsp_vs_end
+//SCL_CON19
+#define SCL_DSP_VACT_ST(x)      ((x)&0xff)      //dsp_vact_st[7:0]
+//SCL_CON20
+#define SCL_DSP_VACT_END_LSB(x)   ((x)&0xff)      //dsp_vact_end[7:0]
+//SCL_CON21
+#define SCL_DSP_VACT_END_MSB(x)   (((x)>>8)&0xf)       //dsp_frame_vtotal[11:8]
+//SCL_CON22
+#define SCL_H_BORD_ST_LSB(x)        ((x)&0xff)      //dsp_hbord_st[7:0]
+//SCL_CON23
+#define SCL_H_BORD_ST_MSB(x)        (((x)>>8)&0x3)      //dsp_hbord_st[9:8]
+//SCL_CON24
+#define SCL_H_BORD_END_LSB(x)        ((x)&0xff)      //dsp_hbord_end[7:0]
+//SCL_CON25
+#define SCL_H_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_hbord_end[11:8]
+//SCL_CON26
+#define SCL_V_BORD_ST(x)            ((x)&0xff)      //dsp_vbord_st[7:0]
+//SCL_CON27
+#define SCL_V_BORD_END_LSB(x)              ((x)&0xff)      //dsp_vbord_end[7:0]
+//SCL_CON25
+#define SCL_V_BORD_END_MSB(x)        (((x)>>8)&0xf)      //dsp_vbord_end[11:8]
+
+/* Scaler PLL CONFIG */
+#define S_PLL_NO_1	0
+#define S_PLL_NO_2	1
+#define S_PLL_NO_4	2
+#define S_PLL_NO_8	3
+#define S_PLL_M(x)  (((x)&0xff)<<8)
+#define S_PLL_N(x)  (((x)&0xf)<<4)
+#define S_PLL_NO(x) ((S_PLL_NO_##x)&0x3)
+
+enum{
+    HDMI_RATE_148500000,
+    HDMI_RATE_74250000,
+    HDMI_RATE_27000000,
+};
+/*     Scaler   clk setting */
+#define SCALE_PLL(_parent_rate,_rate,_m,_n,_no) \
+        HDMI_RATE_ ## _parent_rate ##_S_RATE_ ## _rate \
+        =  S_PLL_M(_m) | S_PLL_N(_n) | S_PLL_NO(_no)    
+#define SCALE_RATE(_parent_rate , _rate) \
+        (HDMI_RATE_ ## _parent_rate ## _S_RATE_ ## _rate)
+        
+enum{
+    SCALE_PLL(148500000,    66000000,   16, 9,  4),
+    SCALE_PLL(148500000,    42187500,   25, 11  ,8),
+    SCALE_PLL(148500000,    41250000,   20,9,8),
+    SCALE_PLL(148500000,    57375000,   17, 11, 4),
+    SCALE_PLL(148500000,    48937500,   29, 11, 8),
+    SCALE_PLL(148500000,    54000000,   16, 11, 4),    
+    SCALE_PLL(148500000,    33000000,   16, 9,  8),
+    SCALE_PLL(148500000,    30375000,   18, 11, 8),
+    SCALE_PLL(148500000,    29700000,   16, 10, 8),
+    SCALE_PLL(148500000,    25312500,   15, 11, 8),
+    SCALE_PLL(148500000,    74250000,   12, 6, 4),
+
+    SCALE_PLL(74250000,     66000000,   32, 9,  4),
+    SCALE_PLL(74250000,     57375000,   34, 11, 4),
+    SCALE_PLL(74250000,     54000000,   32, 11, 4),
+    SCALE_PLL(74250000,     33000000,   32, 9,  8),
+    SCALE_PLL(74250000,     30375000,   36, 11, 8),
+    SCALE_PLL(74250000,     25312500,   30, 11, 8),
+    SCALE_PLL(74250000,     74250000,   12, 3, 4),
+    SCALE_PLL(74250000,     42187500 ,   50, 11, 8),
+    SCALE_PLL(74250000,     41250000,   40, 9, 8),
+    SCALE_PLL(74250000,    67500000,   40, 11, 4),
+
+    SCALE_PLL(27000000,     75000000,   100, 9,  4),
+    SCALE_PLL(27000000,     42187500,   25, 2,  8),
+    SCALE_PLL(27000000,     45000000,   40, 3,  8),
+    SCALE_PLL(27000000,     72000000,   32, 3,  4),
+    SCALE_PLL(27000000,     63281250,   75, 4,  8),
+    SCALE_PLL(27000000,     54375000,   145, 9,  8),
+    SCALE_PLL(27000000,     31500000,   28, 3,  8),
+    SCALE_PLL(27000000,     30000000,   80, 9,  8),
+    SCALE_PLL(27000000,     70312500,   125, 6,  8)
+};
+
+enum {
+    LCD_OUT_SCL,
+    LCD_OUT_BYPASS,
+    LCD_OUT_DISABLE,
+};
+struct rk610_pll_info{
+    u32 parent_rate;
+    u32 rate;
+    int m;
+    int n;
+    int od;
+};
+struct lcd_mode_inf{
+	int h_pw;
+	int h_bp;
+	int h_vd;
+	int h_fp;
+	int v_pw;
+	int v_bp;
+	int v_vd;
+	int v_fp;
+	int f_hst;
+	int f_vst;
+    struct rk610_pll_info pllclk;
+};
+struct scl_hv_info{
+    int scl_h ;
+    int scl_v;
+    };
+
+struct scl_info{
+    bool pll_pwr;
+    bool scl_pwr;
+    struct scl_hv_info scl_hv;
+};
+struct rk610_lcd_info{
+    int disp_mode;
+    
+    struct rk29fb_screen *screen;
+    struct scl_info scl_inf;
+    struct i2c_client *client;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend		early_suspend;
+#endif
+};
+extern int rk610_lcd_init(struct rk610_core_info *rk610_core_info);
+extern int rk610_lcd_scaler_set_param(struct rk29fb_screen *screen,bool enable );
+#endif
diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index 06cd988..b186fe7 100644
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -35,11 +35,17 @@ config LCDC1_RK30
            Support rk30 lcdc1 if you say y here
 
 config DUAL_DISP_IN_KERNEL
-	bool "implement dual display in kernel"
-	depends on FB_ROCKCHIP
-	default y if HDMI_RK30
-	help
-	  select y will implement dual screen display in kernel
+        bool "implement dual display in kernel"
+        depends on FB_ROCKCHIP
+        default y if HDMI_RK30
+        help
+          select y will implement dual screen display in kernel
+config ONE_LCDC_DUAL_OUTPUT_INF
+        bool "one lcdc dual output display interface support"
+       depends on FB_ROCKCHIP
+        default y if ARCH_RK2928
+        help
+          select y if on platform like rk2928 which have one lcdc but two output interface
 
 config THREE_FB_BUFFER
 	bool "Three fb buffer support"
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 1697861..9e8e508 100644
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_FB_ROCKCHIP) += rk_fb.o rkfb_sysfs.o
 obj-$(CONFIG_FB_WIMO) +=wimo.o
-obj-$(CONFIG_LCDC_RK30) += chips/rk30_lcdc.o  
+obj-$(CONFIG_LCDC_RK30) += lcdc/rk30_lcdc.o  
 obj-$(CONFIG_RGA_RK30) += rga/
-obj-$(CONFIG_HDMI_RK30) += hdmi/
+obj-$(CONFIG_RK_HDMI) += hdmi/
diff --git a/drivers/video/rockchip/chips/rk30_lcdc.c b/drivers/video/rockchip/chips/rk30_lcdc.c
deleted file mode 100644
index 21a1c4e..0000000
--- a/drivers/video/rockchip/chips/rk30_lcdc.c
+++ /dev/null
@@ -1,1016 +0,0 @@
-/*
- * drivers/video/rockchip/chips/rk30_lcdc.c
- *
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *Author:yzq<yzq@rock-chips.com>
- *	yxj<yxj@rock-chips.com>
- *This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-#include <linux/earlysuspend.h>
-#include <asm/div64.h>
-#include <asm/uaccess.h>
-#include "rk30_lcdc.h"
-
-
-
-
-
-
-static int dbg_thresd = 0;
-module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
-#define DBG(level,x...) do { if(unlikely(dbg_thresd > level)) printk(KERN_INFO x); } while (0)
-
-
-static int init_rk30_lcdc(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	if(lcdc_dev->id == 0) //lcdc0
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
-	}
-	else if(lcdc_dev->id == 1)
-	{
-		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
-		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
-		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
-		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
-	}
-	else
-	{
-		printk(KERN_ERR "invalid lcdc device!\n");
-		return -EINVAL;
-	}
-	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
-    	{
-       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
-   	}
-	clk_enable(lcdc_dev->pd);
-	clk_enable(lcdc_dev->hclk);  //enable aclk and hclk for register config
-	clk_enable(lcdc_dev->aclk);  
-	lcdc_dev->clk_on = 1;
-	LcdMskReg(lcdc_dev,SYS_CTRL0,m_HWC_CHANNEL_ID | m_WIN2_CHANNEL_ID | m_WIN1_CBR_CHANNEL_ID |
-		m_WIN1_YRGB_CHANNEL_ID | m_WIN0_CBR_CHANNEL1_ID | m_WIN0_YRGB_CHANNEL1_ID | 
-		m_WIN0_CBR_CHANNEL0_ID | m_WIN0_YRGB_CHANNEL0_ID,v_HWC_CHANNEL_ID(7) | 
-		v_WIN2_CHANNEL_ID(6) | v_WIN1_CBR_CHANNEL_ID(5) | v_WIN1_YRGB_CHANNEL_ID(4) | 
-		v_WIN0_CBR_CHANNEL1_ID(3) | v_WIN0_YRGB_CHANNEL1_ID(2) | v_WIN0_CBR_CHANNEL0_ID(1) |
-		v_WIN0_YRGB_CHANNEL0_ID(0));			//channel id ,just use default value
-	LcdSetBit(lcdc_dev,DSP_CTRL0, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
-	LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
-              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
-              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
-	LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-	return 0;
-}
-
-static int rk30_lcdc_deinit(struct rk30_lcdc_device *lcdc_dev)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		LcdMskReg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
-			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
-			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
-		LcdSetBit(lcdc_dev,SYS_CTRL0,m_LCDC_STANDBY);
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else   //clk already disabled 
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	mdelay(1);
-	
-	return 0;
-}
-
-static int rk30_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
-{
-	int ret = -EINVAL;
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	rk_screen *screen = lcdc_dev->screen;
-	u64 ft;
-	int fps;
-	u16 face;
-	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
-	u16 right_margin = screen->right_margin;
-	u16 lower_margin = screen->lower_margin;
-	u16 x_res = screen->x_res, y_res = screen->y_res;
-
-	// set the rgb or mcu
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(screen->type==SCREEN_MCU)
-		{
-	    		LcdMskReg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
-			// set out format and mcu timing
-	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
-	    		if(mcu_total>31)    
-				mcu_total = 31;
-	   		if(mcu_total<3)    
-				mcu_total = 3;
-	    		mcu_rwstart = (mcu_total+1)/4 - 1;
-	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
-	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
-	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
-
-	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
-	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
-
-			// set horizontal & vertical out timing
-		
-		    	right_margin = x_res/6; 
-			screen->pixclock = 150000000; //mcu fix to 150 MHz
-			LcdMskReg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
-	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
-	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
-	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
-	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
-	
-		}
-
-		switch (screen->face)
-		{
-	        	case OUT_P565:
-	            		face = OUT_P565;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_P666:
-	            		face = OUT_P666;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_D888_P565:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	case OUT_D888_P666:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
-	            		break;
-	        	case OUT_P888:
-	            		face = OUT_P888;
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		break;
-	        	default:
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
-	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
-	            		face = screen->face;
-	            		break;
-		}
-
-		//use default overlay,set vsyn hsync den dclk polarity
-		LcdMskReg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
-	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
-	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
-	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
-
-		//set background color to black,set swap according to the screen panel,disable blank mode
-		LcdMskReg(lcdc_dev, DSP_CTRL1, m_BG_COLOR | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | 
-		 	m_DUMMY_SWAP | m_BLANK_MODE,v_BG_COLOR(0x000000) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
-		 	v_OUTPUT_RG_SWAP(screen->swap_rg) | v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy) |
-		 	v_BLACK_MODE(0));
-
-		
-		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
-	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
-		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
-	             v_HASP(screen->hsync_len + screen->left_margin));
-
-		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
-	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
-		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
-	              v_VASP(screen->vsync_len + screen->upper_margin));
-		// let above to take effect
-		LCDC_REG_CFG_DONE();
-	}
- 	spin_unlock(&lcdc_dev->reg_lock);
-
-	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
-	if(ret)
-	{
-        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-	}
-    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-	clk_enable(lcdc_dev->dclk);
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-		(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps;
-    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
-
-    	if(screen->init)
-    	{
-    		screen->init();
-    	}
-	
-	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
-	return 0;
-}
-
-static int mcu_refresh(struct rk30_lcdc_device *lcdc_dev)
-{
-   
-    return 0;
-}
-
-
-
-//enable layer,open:1,enable;0 disable
-static int win0_open(struct rk30_lcdc_device *lcdc_dev,bool open)
-{
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[0]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W0_EN, v_W0_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		LCDC_REG_CFG_DONE();	
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-static int win1_open(struct rk30_lcdc_device *lcdc_dev,bool open)
-{
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		if(open)
-		{
-			if(!lcdc_dev->atv_layer_cnt)
-			{
-				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
-				LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-			}
-			lcdc_dev->atv_layer_cnt++;
-		}
-		else
-		{
-			lcdc_dev->atv_layer_cnt--;
-		}
-		lcdc_dev->driver.layer_par[1]->state = open;
-		
-		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W1_EN, v_W1_EN(open));
-		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
-		{
-			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
-			LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		}
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
-	return 0;
-}
-
-
-static int rk30_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
-{
-	struct rk30_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk30_lcdc_device ,driver);
-
-	printk(KERN_INFO "%s>>>>>%d\n",__func__, blank_mode);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch(blank_mode)
-	    	{
-	    		case FB_BLANK_UNBLANK:
-	      			LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
-				break;
-	    		case FB_BLANK_NORMAL:
-	         		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-	    		default:
-				LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
-				break;
-		}
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-    	return 0;
-}
-
-static  int win0_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_YRGB_MST0, y_addr);
-	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST0, uv_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return 0;
-	
-}
-
-static  int win1_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
-{
-	u32 y_addr;
-	u32 uv_addr;
-	y_addr = par->smem_start + par->y_offset;
-    	uv_addr = par->cbr_start + par->c_offset;
-	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN1_YRGB_MST, y_addr);
-	    	LcdWrReg(lcdc_dev, WIN1_CBR_MST, uv_addr);
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return 0;
-}
-
-static  int win0_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-
-	xact = par->xact;			    //active (origin) picture window width/height		
-	yact = par->yact;
-	xvir = par->xvir;			   // virtual resolution		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-   
-	
-	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
-	ScaleYrgbY = CalScale(yact, par->ysize);
-	switch (par->format)
-	{
-		case YUV422:// yuv422
-			ScaleCbrX = CalScale((xact/2), par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		case YUV420: // yuv420
-			ScaleCbrX = CalScale(xact/2, par->xsize);
-		   	ScaleCbrY = CalScale(yact/2, par->ysize);
-		   	break;
-		case YUV444:// yuv444
-			ScaleCbrX = CalScale(xact, par->xsize);
-			ScaleCbrY = CalScale(yact, par->ysize);
-			break;
-		default:
-		   break;
-	}
-
-	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
-		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W0_FORMAT, v_W0_FORMAT(par->format));		//(inf->video_mode==0)
-		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
-		LcdMskReg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
-			v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format) 
-		{
-			case ARGB888:
-				LcdWrReg(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
-				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-			case RGB888:  //rgb888
-				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
-				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
-				break;
-			case RGB565:  //rgb565
-				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB565_VIRWIDTH(xvir));
-				break;
-			case YUV422:
-			case YUV420:   
-				LcdWrReg(lcdc_dev, WIN0_VIR,v_YUV_VIRWIDTH(xvir));
-				break;
-			default:
-				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
-				break;
-		}
-
-		LCDC_REG_CFG_DONE();
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-    return 0;
-
-}
-
-static int win1_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
-	struct layer_par *par )
-{
-	u32 xact, yact, xvir, yvir, xpos, ypos;
-	u32 ScaleYrgbX = 0x1000;
-	u32 ScaleYrgbY = 0x1000;
-	u32 ScaleCbrX = 0x1000;
-	u32 ScaleCbrY = 0x1000;
-	
-	xact = par->xact;			
-	yact = par->yact;
-	xvir = par->xvir;		
-	yvir = par->yvir;
-	xpos = par->xpos+screen->left_margin + screen->hsync_len;
-	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
-	
-	ScaleYrgbX = CalScale(xact, par->xsize);
-	ScaleYrgbY = CalScale(yact, par->ysize);
-	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
-		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
-
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		switch (par->format)
-	 	{
-			case YUV422:// yuv422
-				ScaleCbrX = CalScale((xact/2), par->xsize);
-				ScaleCbrY = CalScale(yact, par->ysize);
-				break;
-			case YUV420: // yuv420
-				ScaleCbrX = CalScale(xact/2, par->xsize);
-				ScaleCbrY = CalScale(yact/2, par->ysize);
-				break;
-			case YUV444:// yuv444
-				ScaleCbrX = CalScale(xact, par->xsize);
-				ScaleCbrY = CalScale(yact, par->ysize);
-				break;
-			default:
-				break;
-		}
-
-		LcdWrReg(lcdc_dev, WIN1_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
-		LcdWrReg(lcdc_dev, WIN1_SCL_FACTOR_CBR,  v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
-		LcdMskReg(lcdc_dev,SYS_CTRL1, m_W1_FORMAT, v_W1_FORMAT(par->format));
-		LcdWrReg(lcdc_dev, WIN1_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
-		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
-		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
-		// enable win1 color key and set the color to black(rgb=0)
-		LcdMskReg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
-		switch(par->format)
-	    	{
-		        case ARGB888:
-				LcdWrReg(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
-				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-		        case RGB888:  //rgb888
-				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
-				// LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
-				break;
-		        case RGB565:  //rgb565
-				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB565_VIRWIDTH(xvir));
-				break;
-		        case YUV422:
-		        case YUV420:   
-				LcdWrReg(lcdc_dev, WIN1_VIR,v_YUV_VIRWIDTH(xvir));
-				break;
-		        default:
-				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
-				break;
-	    	}
-		
-		LCDC_REG_CFG_DONE(); 
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-    return 0;
-}
-
-static int rk30_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	if(layer_id == 0)
-	{
-		win0_open(lcdc_dev,open);	
-	}
-	else if(layer_id == 1)
-	{
-		win1_open(lcdc_dev,open);
-	}
-
-	return 0;
-}
-
-static int rk30_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = lcdc_dev->screen;
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_set_par(lcdc_dev,screen,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_set_par(lcdc_dev,screen,par);
-	}
-	
-	return 0;
-}
-
-int rk30_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = NULL;
-	rk_screen *screen = lcdc_dev->screen;
-	unsigned long flags;
-	int timeout;
-	if(!screen)
-	{
-		printk(KERN_ERR "screen is null!\n");
-		return -ENOENT;	
-	}
-	if(layer_id==0)
-	{
-		par = dev_drv->layer_par[0];
-        	win0_display(lcdc_dev,par);
-	}
-	else if(layer_id==1)
-	{
-		par = dev_drv->layer_par[1];
-        	win1_display(lcdc_dev,par);
-	}
-	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
-	{
-		dev_drv->first_frame = 0;
-		LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
-			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
-		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
-		 
-	}
-
-	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
-	{
-		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
-		init_completion(&dev_drv->frame_done);
-		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
-		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->screen->ft+5));
-		if(!timeout&&(!dev_drv->frame_done.done))
-		{
-			printk(KERN_ERR "wait for new frame start time out!\n");
-			return -ETIMEDOUT;
-		}
-	}
-	
-	return 0;
-}
-
-int rk30_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	u32 panel_size[2];
-	void __user *argp = (void __user *)arg;
-	int ret = 0;
-	switch(cmd)
-	{
-		case FBIOGET_PANEL_SIZE:    //get panel size
-                	panel_size[0] = lcdc_dev->screen->x_res;
-                	panel_size[1] = lcdc_dev->screen->y_res;
-            		if(copy_to_user(argp, panel_size, 8)) 
-				return -EFAULT;
-			break;
-		default:
-			break;
-	}
-
-	return ret;
-}
-static int rk30_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	struct layer_par *par = dev_drv->layer_par[layer_id];
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(layer_id == 0)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CTRL1,m_W0_EN);
-		}
-		else if( layer_id == 1)
-		{
-			par->state = LcdReadBit(lcdc_dev,SYS_CTRL1,m_W1_EN);
-		}
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-	return par->state;
-	
-}
-
-/***********************************
-overlay manager
-swap:1 win0 on the top of win1
-        0 win1 on the top of win0
-set  : 1 set overlay 
-        0 get overlay state
-************************************/
-static int rk30_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	int ovl;
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->clk_on)
-	{
-		if(set)  //set overlay
-		{
-			LcdMskReg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
-			LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
-			LCDC_REG_CFG_DONE();
-			ovl = swap;
-		}
-		else  //get overlay
-		{
-			ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
-		}
-	}
-	else
-	{
-		ovl = -EPERM;
-	}
-	spin_unlock(&lcdc_dev->reg_lock);
-
-	return ovl;
-}
-static int rk30_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,int layer_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	return 0;
-}
-
-
-/*******************************************
-lcdc fps manager,set or get lcdc fps
-set:0 get
-     1 set
-********************************************/
-static int rk30_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	rk_screen * screen = dev_drv->screen;
-	u64 ft = 0;
-	u32 dotclk;
-	int ret;
-
-	if(set)
-	{
-		ft = div_u64(1000000000000llu,fps);
-		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
-		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
-		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
-		if(ret)
-		{
-	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
-		}
-	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
-			
-	}
-	
-	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
-	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
-	(dev_drv->pixclock);       // one frame time ,(pico seconds)
-	fps = div64_u64(1000000000000llu,ft);
-	screen->ft = 1000/fps ;  //one frame time in ms
-	return fps;
-}
-int rk30_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
-{
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	
-	spin_lock(&lcdc_dev->reg_lock);
-	if(likely(lcdc_dev->clk_on))
-	{
-		lcdc_dev->clk_on = 0;
-		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-		LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
-		LCDC_REG_CFG_DONE();
-		spin_unlock(&lcdc_dev->reg_lock);
-	}
-	else  //clk already disabled
-	{
-		spin_unlock(&lcdc_dev->reg_lock);
-		return 0;
-	}
-	
-		
-	mdelay(1);
-	clk_disable(lcdc_dev->dclk);
-	clk_disable(lcdc_dev->hclk);
-	clk_disable(lcdc_dev->aclk);
-	clk_disable(lcdc_dev->pd);
-
-	return 0;
-}
-
-
-int rk30_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
-{  
-	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
-	
-	if(!lcdc_dev->clk_on)
-	{
-		clk_enable(lcdc_dev->pd);
-		clk_enable(lcdc_dev->hclk);
-		clk_enable(lcdc_dev->dclk);
-		clk_enable(lcdc_dev->aclk);
-	}
-	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0xc4);  //resume reg
-
-	spin_lock(&lcdc_dev->reg_lock);
-	if(lcdc_dev->atv_layer_cnt)
-	{
-		LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
-		LCDC_REG_CFG_DONE();
-	}
-	lcdc_dev->clk_on = 1;
-	spin_unlock(&lcdc_dev->reg_lock);
-	
-    	return 0;
-}
-static irqreturn_t rk30_lcdc_isr(int irq, void *dev_id)
-{
-	struct rk30_lcdc_device *lcdc_dev = (struct rk30_lcdc_device *)dev_id;
-	
-	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
-	LCDC_REG_CFG_DONE();
-	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
- 
-	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
-	{
-		spin_lock(&(lcdc_dev->driver.cpl_lock));
-		complete(&(lcdc_dev->driver.frame_done));
-		spin_unlock(&(lcdc_dev->driver.cpl_lock));
-	}
-	return IRQ_HANDLED;
-}
-
-static struct layer_par lcdc_layer[] = {
-	[0] = {
-		.name  		= "win0",
-		.id		= 0,
-		.support_3d	= true,
-	},
-	[1] = {
-		.name  		= "win1",
-		.id		= 1,
-		.support_3d	= false,
-	},
-};
-
-static struct rk_lcdc_device_driver lcdc_driver = {
-	.name			= "lcdc",
-	.def_layer_par		= lcdc_layer,
-	.num_layer		= ARRAY_SIZE(lcdc_layer),
-	.open			= rk30_lcdc_open,
-	.init_lcdc		= init_rk30_lcdc,
-	.ioctl			= rk30_lcdc_ioctl,
-	.suspend		= rk30_lcdc_early_suspend,
-	.resume			= rk30_lcdc_early_resume,
-	.set_par       		= rk30_lcdc_set_par,
-	.blank         		= rk30_lcdc_blank,
-	.pan_display            = rk30_lcdc_pan_display,
-	.load_screen		= rk30_load_screen,
-	.get_layer_state	= rk30_lcdc_get_layer_state,
-	.ovl_mgr		= rk30_lcdc_ovl_mgr,
-	.get_disp_info		= rk30_lcdc_get_disp_info,
-	.fps_mgr		= rk30_lcdc_fps_mgr,
-};
-#ifdef CONFIG_PM
-static int rk30_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	return 0;
-}
-
-static int rk30_lcdc_resume(struct platform_device *pdev)
-{
-	return 0;
-}
-
-#else
-#define rk30_lcdc_suspend NULL
-#define rk30_lcdc_resume NULL
-#endif
-
-static int __devinit rk30_lcdc_probe (struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev=NULL;
-	rk_screen *screen;
-	struct rk29fb_info *screen_ctr_info;
-	struct resource *res = NULL;
-	struct resource *mem;
-	int ret = 0;
-	
-	/*************Malloc rk30lcdc_inf and set it to pdev for drvdata**********/
-	lcdc_dev = kzalloc(sizeof(struct rk30_lcdc_device), GFP_KERNEL);
-    	if(!lcdc_dev)
-    	{
-        	dev_err(&pdev->dev, ">>rk30 lcdc device kmalloc fail!");
-        	return -ENOMEM;
-    	}
-	platform_set_drvdata(pdev, lcdc_dev);
-	lcdc_dev->id = pdev->id;
-	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
-	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
-	if(!screen)
-	{
-		dev_err(&pdev->dev, ">>rk30 lcdc screen kmalloc fail!");
-        	ret =  -ENOMEM;
-		goto err0;
-	}
-	else
-	{
-		lcdc_dev->screen = screen;
-	}
-	/****************get lcdc0 reg  *************************/
-	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
-	if (res == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-    	lcdc_dev->reg_phy_base = res->start;
-	lcdc_dev->len = resource_size(res);
-    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
-    	if (mem == NULL)
-    	{
-        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
-        	ret = -ENOENT;
-		goto err1;
-    	}
-	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
-	if (lcdc_dev->reg_vir_base == NULL)
-	{
-		dev_err(&pdev->dev, "cannot map IO\n");
-		ret = -ENXIO;
-		goto err2;
-	}
-	
-    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
-	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
-	lcdc_dev->driver.dev=&pdev->dev;
-	lcdc_dev->driver.screen = screen;
-	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
-	spin_lock_init(&lcdc_dev->reg_lock);
-	lcdc_dev->irq = platform_get_irq(pdev, 0);
-	if(lcdc_dev->irq < 0)
-	{
-		dev_err(&pdev->dev, "cannot find IRQ\n");
-		goto err3;
-	}
-	ret = request_irq(lcdc_dev->irq, rk30_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
-	if (ret)
-	{
-	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
-	       ret = -EBUSY;
-	       goto err3;
-	}
-	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
-	if(ret < 0)
-	{
-		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
-		goto err4;
-	}
-	printk("rk30 lcdc%d probe ok!\n",lcdc_dev->id);
-
-	return 0;
-
-err4:
-	free_irq(lcdc_dev->irq,lcdc_dev);
-err3:	
-	iounmap(lcdc_dev->reg_vir_base);
-err2:
-	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
-err1:
-	kfree(screen);
-err0:
-	platform_set_drvdata(pdev, NULL);
-	kfree(lcdc_dev);
-	return ret;
-    
-}
-static int __devexit rk30_lcdc_remove(struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk_fb_unregister(&(lcdc_dev->driver));
-	rk30_lcdc_deinit(lcdc_dev);
-	iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);
-	return 0;
-}
-
-static void rk30_lcdc_shutdown(struct platform_device *pdev)
-{
-	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
-	rk_fb_unregister(&(lcdc_dev->driver));
-	rk30_lcdc_deinit(lcdc_dev);
-	/*iounmap(lcdc_dev->reg_vir_base);
-	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
-	kfree(lcdc_dev->screen);
-	kfree(lcdc_dev);*/
-}
-
-
-static struct platform_driver rk30lcdc_driver = {
-	.probe		= rk30_lcdc_probe,
-	.remove		= __devexit_p(rk30_lcdc_remove),
-	.driver		= {
-		.name	= "rk30-lcdc",
-		.owner	= THIS_MODULE,
-	},
-	.suspend	= rk30_lcdc_suspend,
-	.resume		= rk30_lcdc_resume,
-	.shutdown   = rk30_lcdc_shutdown,
-};
-
-static int __init rk30_lcdc_init(void)
-{
-    return platform_driver_register(&rk30lcdc_driver);
-}
-
-static void __exit rk30_lcdc_exit(void)
-{
-    platform_driver_unregister(&rk30lcdc_driver);
-}
-
-
-
-fs_initcall(rk30_lcdc_init);
-module_exit(rk30_lcdc_exit);
-
-
-
diff --git a/drivers/video/rockchip/chips/rk30_lcdc.h b/drivers/video/rockchip/chips/rk30_lcdc.h
deleted file mode 100644
index b986c3f..0000000
--- a/drivers/video/rockchip/chips/rk30_lcdc.h
+++ /dev/null
@@ -1,538 +0,0 @@
-#ifndef RK30_LCDC_H_
-#define RK30_LCDC_H_
-
-#include<linux/rk_fb.h>
-
-#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
-#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
-#define LcdRdReg(inf, addr)             (inf->preg->addr)
-#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
-#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
-#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
-#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
-#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
-
-/********************************************************************
-**                          结构定义                                *
-********************************************************************/
-/* LCDC的寄存器结构 */
-
-typedef volatile struct tagLCDC_REG
-{
-    /* offset 0x00~0xc0 */
-	unsigned int SYS_CTRL0;               //0x00 system control register 0
-	unsigned int SYS_CTRL1;				  //0x04 system control register 1
-	unsigned int DSP_CTRL0;				 //0x08 display control register 0
-	unsigned int DSP_CTRL1;				 //0x0c display control register 1
-	unsigned int INT_STATUS;             //0x10 Interrupt status register
-	unsigned int MCU_CTRL ;				 //0x14 MCU mode contol register
-	unsigned int BLEND_CTRL;             //0x18 Blending control register
-	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
-	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
-	unsigned int WIN2_COLOR_KEY_CTRL;     //0x24 Win2 blending control register
-	unsigned int WIN0_YRGB_MST0;           //0x28 Win0 active YRGB memory start address0
-	unsigned int WIN0_CBR_MST0;            //0x2c Win0 active Cbr memory start address0
-	unsigned int WIN0_YRGB_MST1;           //0x30 Win0 active YRGB memory start address1
-	unsigned int WIN0_CBR_MST1;            //0x34 Win0 active Cbr memory start address1
-	unsigned int WIN0_VIR;                //0x38 WIN0 virtual display width/height
-	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
-	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
-	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
-	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
-	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
-	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
-	unsigned int WIN1_YRGB_MST;           //0x54 Win1 active YRGB memory start address
-	unsigned int WIN1_CBR_MST;            //0x58 Win1 active Cbr memory start address
-	unsigned int WIN1_VIR;                //0x5c WIN1 virtual display width/height
-	unsigned int WIN1_ACT_INFO;           //0x60 Win1 active window width/height
-	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
-	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
-	unsigned int WIN1_SCL_FACTOR_YRGB;    //0x6c Win1 YRGB scaling  factor setting
-	unsigned int WIN1_SCL_FACTOR_CBR;     //0x70 Win1 YRGB scaling factor setting
-	unsigned int WIN1_SCL_OFFSET;         //0x74 Win1 Cbr scaling start point offset
-	unsigned int WIN2_MST;		 		  //0x78 win2 memort start address
-	unsigned int WIM2_VIR;				  //0x7c win2 virtual stride
-	unsigned int WIN2_DSP_INFO;           //0x80 Win2 display width/height on panel
-	unsigned int WIN2_DSP_ST;             //0x84 Win2 display start point on panel
-	unsigned int HWC_MST;                 //0x88 HWC memory start address
-	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
-	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2’b01 look up table 0
-	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2’b10 look up table 1
-	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2’b11 look up table 2
-	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
-	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
-	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
-	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
-	unsigned int DSP_VS_ST_END_F1;        //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
-	unsigned int DSP_VACT_ST_END_F1;      //0xb0 Vertical scanning active start/end point of even filed in interlace mode
-	unsigned int reserved0[(0xc0-0xb4)/4];
-	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
-	unsigned int reserved1[(0x100-0xc4)/4];
-	unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
-	unsigned int reserved2[(0x200-0x104)/4];
-	unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port   
-  
-} LCDC_REG, *pLCDC_REG;
-
-
-/* SYS_CONFIG */
-
-#define m_LCDC_DMA_STOP              (1<<0)
-#define m_LCDC_STANDBY               (1<<1)
-#define m_HWC_RELOAD_EN               (1<<2)
-#define m_W0_AXI_OUTSTANDING_DISABLE (1<<3) 
-#define m_W1_AXI_OUTSTANDING_DISABLE (1<<4)
-#define m_W2_AXI_OUTSTANDING_DISABLE (1<<5)
-#define m_DMA_BURST_LENGTH	      (3<<6)
-#define m_WIN0_YRGB_CHANNEL0_ID	      ((0x07)<<8)
-#define m_WIN0_CBR_CHANNEL0_ID	      ((0x07)<<11)
-#define m_WIN0_YRGB_CHANNEL1_ID	      ((0x07)<<14)
-#define m_WIN0_CBR_CHANNEL1_ID	      ((0x07)<<17)
-#define m_WIN1_YRGB_CHANNEL_ID	      ((0x07)<<20)
-#define m_WIN1_CBR_CHANNEL_ID	      ((0x07)<<23)
-#define m_WIN2_CHANNEL_ID	      ((0x07)<<26)
-#define m_HWC_CHANNEL_ID	      ((0x07)<<29)
-
-
-
-
-
-#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
-#define v_LCDC_STANDBY(x)              (((x)&1)<<1)
-#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
-#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
-#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
-#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
-#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
-#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
-#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
-#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
-#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
-#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
-#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
-#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
-#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
-
-
-
-//LCDC_SYS_CTRL1
-#define m_W0_EN          (1<<0)
-#define m_W1_EN          (1<<1)
-#define m_W2_EN         (1<<2)
-#define m_HWC_EN         (1<<3)
-#define m_W0_FORMAT          (7<<4)
-#define m_W1_FORMAT          (7<<7)
-#define m_W2_FORMAT          (7<<10)
-#define m_HWC_COLOR_MODE     (1<<13)
-#define m_HWC_SIZE_SELET     (1<<14)
-#define m_W0_3D_MODE_EN      (1<<15)
-#define m_W0_3D_MODE_SELET    (7<<16)
-#define m_W0_RGB_RB_SWAP      (1<<19)
-#define m_W0_RGB_ALPHA_SWAP   (1<<20)
-#define m_W0_YRGB_M8_SWAP     (1<<21)
-#define m_W0_CBCR_SWAP        (1<<22)
-#define m_W1_RGB_RB_SWAP      (1<<23)
-#define m_W1_RGB_ALPHA_SWAP   (1<<24)
-#define m_W1_YRGB_M8_SWAP     (1<<25)
-#define m_W1_CBCR_SWAP        (1<<26)
-#define m_W2_RGB_RB_SWAP      (1<<27)
-#define m_W2_RGB_ALPHA_SWAP   (1<<28)
-#define m_W2_8pp_PALETTE_ENDIAN_SELECT (1<<29)
-#define m_W2_LUT_RAM_EN       (1<<30)
-#define m_DSP_LUT_RAM_EN      (1<<31)
-
-#define v_W0_EN(x)          (((x)&1)<<0)
-#define v_W1_EN(x)          (((x)&1)<<1)
-#define v_W2_EN(x)          (((x)&1)<<2)
-#define v_HWC_EN(x)         (((x)&1)<<3)
-#define v_W0_FORMAT(x)      (((x)&7)<<4)
-#define v_W1_FORMAT(x)      (((x)&7)<<7)
-#define v_W2_FORMAT(x)      (((x)&7)<<10)
-#define v_HWC_COLOR_MODE(x)     (((x)&1)<<13)
-#define v_HWC_SIZE_SELET(x)     (((x)&1)<<14)
-#define v_W0_3D_MODE_EN(x)     (((x)&1)<<15)
-#define v_W0_3D_MODE_SELET(x)    (((x)&3)<<16)
-#define v_W0_RGB_RB_SWAP(x)      (((x)&1)<<19)
-#define v_W0_RGB_ALPHA_SWAP(x)   (((x)&1)<<20)
-#define v_W0_YRGB_M8_SWAP(x)     (((x)&1)<<21)
-#define v_W0_CBCR_SWAP(x)       (((x)&1)<<22)
-#define v_W1_RGB_RB_SWAP(x)      (((x)&1)<<23)
-#define v_W1_RGB_ALPHA_SWAP(x)   (((x)&1)<<24)
-#define v_W1_YRGB_M8_SWAP(x)     (((x)&1)<<25)
-#define v_W1_CBCR_SWAP(x)       (((x)&1)<<26)
-#define v_W2_RGB_RB_SWAP(x)      (((x)&1)<<27)
-#define v_W2_RGB_ALPHA_SWAP(x)   (((x)&1)<<28)
-#define v_W2_8pp_PALETTE_ENDIAN_SELECT (((x)&1)<<29)
-#define v_W2_LUT_RAM_EN(x)      (((x)&1)<<30)
-#define v_DSP_LUT_RAM_EN(x)　　　(((x)&1)<<31)
-
-
-//LCDC_DSP_CTRL_REG0
-#define m_DISPLAY_FORMAT             (0x0f<<0)
-#define m_HSYNC_POLARITY             (1<<4)
-#define m_VSYNC_POLARITY             (1<<5)
-#define m_DEN_POLARITY               (1<<6)
-#define m_DCLK_POLARITY              (1<<7)
-#define m_W0W1_POSITION_SWAP         (1<<8)
-#define m_DITHER_UP_EN               (1<<9)
-#define m_DITHER_DOWN_MODE           (1<<10)
-#define m_DITHER_DOWN_EN             (1<<11)
-#define m_INTERLACE_DSP_EN           (1<<12)
-#define m_INTERLACE_FIELD_POLARITY   (1<<13)
-#define m_W0_INTERLACE_READ_MODE     (1<<14)
-#define m_W1_INTERLACE_READ_MODE     (1<<15)
-#define m_W2_INTERLACE_READ_MODE     (1<<16)
-#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
-#define m_W0_CBR_DEFLICK_MODE        (1<<18)
-#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
-#define m_W1_CBR_DEFLICK_MODE        (1<<20)
-#define m_W0_ALPHA_MODE              (1<<21)
-#define m_W1_ALPHA_MODE              (1<<22)
-#define m_W2_ALPHA_MODE              (1<<23)
-#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
-#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
-#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
-#define m_YCRCB_CLIP_EN              (1<<29)
-#define m_CBR_FILTER_656             (1<<30)
-#define m_LCDC_AXICLK_AUTO_ENABLE 	(1<<31) //eanble for low power
-
-#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
-#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
-#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
-#define v_DEN_POLARITY(x)               (((x)&1)<<6)
-#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
-#define v_W0W1_POSITION_SWAP(x)			(((x)&1)<<8)		
-#define v_DITHER_UP_EN(x)               (((x)&1)<<9)
-#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<10)
-#define v_DITHER_DOWN_EN(x)             (((x)&1)<<11)
-#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
-#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
-#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
-#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
-#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
-#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
-#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
-#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
-#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
-#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
-#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
-#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
-#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
-#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
-#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
-#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
-#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
-#define v_LCDC_AXICLK_AUTO_ENABLE(x) 	(((x)&1)<<31) //eanble for low power
-
-//LCDC_DSP_CTRL_REG1
-#define m_BG_COLOR                    (0xffffff<<0)
-#define m_BG_B                        (0xff<<0)
-#define m_BG_G                        (0xff<<8)
-#define m_BG_R                        (0xff<<16)
-#define m_BLANK_MODE                  (1<<24)
-#define m_BLACK_MODE                  (1<<25)
-#define m_OUTPUT_BG_SWAP        	  (1<<26)
-#define m_OUTPUT_RB_SWAP        	  (1<<27)
-#define m_OUTPUT_RG_SWAP        	  (1<<28)
-#define m_DELTA_SWAP            	  (1<<29)
-#define m_DUMMY_SWAP            	  (1<<30)
-
-#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
-#define v_BG_B(x)                     (((x)&0xff)<<0)
-#define v_BG_G(x)                     (((x)&0xff)<<8)
-#define v_BG_R(x)                     (((x)&0xff)<<16)
-#define v_BLANK_MODE(x)               (((x)&1)<<24)
-#define v_BLACK_MODE(x)               (((x)&1)<<25)
-#define v_OUTPUT_BG_SWAP(x)        	  (((x)&1)<<26)
-#define v_OUTPUT_RB_SWAP(x)        	  (((x)&1)<<27)
-#define v_OUTPUT_RG_SWAP(x)        	  (((x)&1)<<28)
-#define v_DELTA_SWAP(x)            	  (((x)&1)<<29)
-#define v_DUMMY_SWAP(x)            	  (((x)&1)<<30)
-
-
-//LCDC_INT_STATUS
-#define v_HOR_START_INT_STA        (1<<0)  //status
-#define v_FRM_START_INT_STA        (1<<1)
-#define v_LINE_FLAG_INT_STA        (1<<2)
-#define v_BUS_ERR_INT_STA	   (1<<3)
-#define m_HOR_START_INT_EN     	   (1<<4)  //enable
-#define m_FRM_START_INT_EN          (1<<5)
-#define m_LINE_FLAG_INT_EN         (1<<6)
-#define m_BUS_ERR_INT_EN	   (1<<7)
-#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
-#define m_FRM_START_INT_CLEAR      (1<<9)
-#define m_LINE_FLAG_INT_CLEAR      (1<<10)
-#define m_BUS_ERR_INT_CLEAR        (1<<11)
-#define m_LINE_FLAG_NUM		   (0xfff<<12)
-#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
-#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
-#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
-#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
-#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
-#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
-#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
-#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
-#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
-
-
-
-//LCDC_MCU_TIMING_CTRL
-#define m_MCU_WRITE_PERIOD      (0x3f<<0)
-#define m_MCU_CS_ST             (0xf<<6)
-#define m_MCU_CS_END            (0x3f<<10)
-#define m_MCU_RW_ST             (0xf<<16)
-#define m_MCU_RW_END            (0x3f<<20)
-#define m_MCU_BPS_CLK_SEL		(1<<26)
-#define m_MCU_HOLDMODE_SELECT     (1<<27)
-#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
-#define m_MCU_RS_SELECT            (1<<29)
-#define m_MCU_BYPASSMODE_SELECT   (1<<30)
-#define m_MCU_OUTPUT_SELECT        (1<<31)
-#define v_MCU_WRITE_PERIOD(x)      (((x)&0x3f)<<0)
-#define v_MCU_CS_ST(x)          (((x)&0xf)<<6)
-#define v_MCU_CS_END(x)         (((x)&0x3f)<<10)
-#define v_MCU_RW_ST(x)          (((x)&0xf)<<16)
-#define v_MCU_RW_END(x)         (((x)&0x3f)<<20)
-#define v_MCU_BPS_CLK_SEL	(((x)&1)<<26)
-#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
-#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
-#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
-#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
-#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
-
-//LCDC_ BLEND_CTRL
-#define m_HWC_BLEND_EN         (1<<0)
-#define m_W2_BLEND_EN          (1<<1)
-#define m_W1_BLEND_EN          (1<<2)
-#define m_W0_BLEND_EN          (1<<3)
-#define m_HWC_BLEND_FACTOR     (15<<4)
-#define m_W2_BLEND_FACTOR     (0xff<<8)
-#define m_W1_BLEND_FACTOR     (0xff<<16)
-#define m_W0_BLEND_FACTOR     (0xff<<24)
-
-#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
-#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
-#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
-#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
-#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
-#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
-#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
-#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
-
-
-//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
-#define m_KEYCOLOR          (0xffffff<<0)
-#define m_KEYCOLOR_B          (0xff<<0)
-#define m_KEYCOLOR_G          (0xff<<8)
-#define m_KEYCOLOR_R          (0xff<<16)
-#define m_COLORKEY_EN         (1<<24)
-#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
-#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
-#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
-#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
-#define v_COLORKEY_EN(x)         (((x)&1)<<24)
-
-//LCDC_DEFLICKER_SCL_OFFSET
-#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
-#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
-#define m_W1_VSD_OFFSET           (0xff<<16)
-#define m_W1_VSP_OFFSET           (0xff<<24)
-#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
-#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
-#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
-#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
-
-
-
-
-
-//AXI MS ID
-#define m_W0_YRGB_CH_ID        (0xF<<0)
-#define m_W0_CBR_CH_ID         (0xF<<4)
-#define m_W1_YRGB_CH_ID        (0xF<<8)
-#define m_W2_CH_ID             (0xF<<12)
-#define m_HWC_CH_ID            (0xF<<16)
-#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
-#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
-#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
-#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
-#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
-
-
-/* Low Bits Mask */
-#define m_WORDLO            (0xffff<<0)
-#define m_WORDHI            (0xffff<<16)
-#define v_WORDLO(x)         (((x)&0xffff)<<0)
-#define v_WORDHI(x)         (((x)&0xffff)<<16)
-
-
-//LCDC_WINx_SCL_FACTOR_Y/CBCR
-#define v_X_SCL_FACTOR(x)  ((x)<<0)
-#define v_Y_SCL_FACTOR(x)  ((x)<<16)
-
-//LCDC_DSP_HTOTAL_HS_END
-#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
-#define v_HORPRD(x) ((x)<<16)   //horizontal period
-
-
-//LCDC_DSP_HACT_ST_END
-#define v_HAEP(x) ((x)<<0)  //horizontal active end point
-#define v_HASP(x) ((x)<<16) //horizontal active start point
-
-//LCDC_DSP_VTOTAL_VS_END
-#define v_VSYNC(x) ((x)<<0)
-#define v_VERPRD(x) ((x)<<16)
-
-//LCDC_DSP_VACT_ST_END
-#define v_VAEP(x) ((x)<<0)
-#define v_VASP(x) ((x)<<16)
-
-
-//LCDC_WINx_VIR ,x is number of words of win0 virtual width
-#define v_ARGB888_VIRWIDTH(x) (x)
-#define v_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
-#define v_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
-#define v_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
-
-#define m_ACTWIDTH       (0xffff<<0)
-#define m_ACTHEIGHT      (0xffff<<16)
-#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
-#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
-
-#define m_VIRST_X      (0xffff<<0)
-#define m_VIRST_Y      (0xffff<<16)
-#define v_VIRST_X(x)      (((x)&0xffff)<<0)
-#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
-
-#define m_PANELST_X      (0x3ff<<0)
-#define m_PANELST_Y      (0x3ff<<16)
-#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
-#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
-
-#define m_PANELWIDTH       (0x3ff<<0)
-#define m_PANELHEIGHT      (0x3ff<<16)
-#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
-#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
-
-#define m_HWC_B                 (0xff<<0)
-#define m_HWC_G                 (0xff<<8)
-#define m_HWC_R                 (0xff<<16)
-#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
-#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
-#define v_HWC_B(x)                 (((x)&0xff)<<0)
-#define v_HWC_G(x)                 (((x)&0xff)<<8)
-#define v_HWC_R(x)                 (((x)&0xff)<<16)
-#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
-#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
-
-//LCDC_WIN0_ACT_INFO
-#define v_ACT_WIDTH(x)     ((x-1)<<0)
-#define v_ACT_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_INFO
-#define v_DSP_WIDTH(x)     ((x-1)<<0)
-#define v_DSP_HEIGHT(x)    ((x-1)<<16)
-
-//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
-#define v_DSP_STX(x)      (x<<0)
-#define v_DSP_STY(x)      (x<<16)
-
-//Panel display scanning
-#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
-
-#define m_PANEL_END              (0x3ff<<0)
-#define m_PANEL_START            (0x3ff<<16)
-#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
-#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
-
-#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
-#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
-#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
-#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
-//-----------
-
-#define m_HSCALE_FACTOR        (0xffff<<0)
-#define m_VSCALE_FACTOR        (0xffff<<16)
-#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
-#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
-
-#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
-#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
-#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
-#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
-#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
-#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
-#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
-#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
-
-
-
-#define CalScale(x, y)	             (((u32)x*0x1000)/y)
-struct rk30_lcdc_device{
-	int id;
-	struct rk_lcdc_device_driver driver;
-	rk_screen *screen;
-	
-	LCDC_REG *preg;         // LCDC reg base address and backup reg 
-    	LCDC_REG regbak;
-
-	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
-	u32 reg_phy_base;       	// physical basic address of lcdc register
-	u32 len;               		// physical map length of lcdc register
-	spinlock_t  reg_lock;		//one time only one process allowed to config the register
-	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
-	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
-
-	unsigned int		irq;
-
-	struct clk		*pd;				//lcdc power domain
-	struct clk		*hclk;				//lcdc AHP clk
-	struct clk		*dclk;				//lcdc dclk
-	struct clk		*aclk;				//lcdc share memory frequency
-	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
-	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
-	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
-	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
-	struct clk		*pd_display;		// display power domain
-	u32	pixclock;
-};
-
-struct lcdc_info{
-/*LCD CLK*/
-	struct rk30_lcdc_device lcdc0;
-	struct rk30_lcdc_device lcdc1;
-
-};
-
-
-struct win_set {
-	volatile u32 y_offset;
-	volatile u32 c_offset;
-};
-
-struct win0_par {
-    u32 refcount;
-    u32	pseudo_pal[16];
-    u32 y_offset;
-    u32 c_offset;
-    u32 xpos;         //size in panel
-    u32 ypos;
-    u32 xsize;        //start point in panel
-    u32 ysize;
-    enum data_format format;
-
-    wait_queue_head_t wait;
-    struct win_set mirror;
-    struct win_set displ;
-    struct win_set done;
-
-    u8 par_seted;
-    u8 addr_seted;
-};
-
-#endif
-
-
diff --git a/drivers/video/rockchip/hdmi/Kconfig b/drivers/video/rockchip/hdmi/Kconfig
index 654bfa0..144b9a5 100755
--- a/drivers/video/rockchip/hdmi/Kconfig
+++ b/drivers/video/rockchip/hdmi/Kconfig
@@ -1,23 +1,22 @@
-menuconfig HDMI_RK30
-        bool "RK30 HDMI support"
-        depends on LCDC_RK30
-        select FB_MODE_HELPERS
-        help
-           Support rk30 hdmi if you say y here
+menuconfig RK_HDMI
+       bool "Rockchip HDMI support"
+       select FB_MODE_HELPERS
+       
+if RK_HDMI
+source "drivers/video/rockchip/hdmi/chips/Kconfig"
+endif
 
-config HDMI_RK30_CTL_CODEC
+config RK_HDMI_DEBUG
+		bool "Rockchip HDMI Debugging"
+        depends on RK_HDMI
+        default n
+		help
+		  Enableds verbose debugging the the HDMI drivers
+
+config RK_HDMI_CTL_CODEC
 		bool "Mute Codec When HDMI Actived"
-		depends on HDMI_RK30
+		depends on RK_HDMI
 		default n
 		help
 			If you say y heres, Codec will be mute when hdmi inserted,
 			and unmute when removed. 
-
-config HDMI_RK30_DEBUG
-		bool "RK30 HDMI Debugging"
-        depends on HDMI_RK30 && LCDC_RK30
-        default n
-		help
-		  Enableds verbose debugging the the HDMI drivers
-
-source "drivers/video/rockchip/hdmi/hdcp/Kconfig"
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/Makefile b/drivers/video/rockchip/hdmi/Makefile
index 4692311..ed00a16 100755
--- a/drivers/video/rockchip/hdmi/Makefile
+++ b/drivers/video/rockchip/hdmi/Makefile
@@ -2,7 +2,7 @@
 # Makefile for HDMI linux kernel module.
 #
 
-ccflags-$(CONFIG_HDMI_RK30_DEBUG) = -DDEBUG -DHDMI_DEBUG
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
 
-obj-$(CONFIG_HDMI_RK30) += rk30_hdmi_hw.o rk30_hdmi_edid.o rk30_hdmi_lcdc.o rk30_hdmi_task.o rk30_hdmi_sysfs.o rk30_hdmi.o
-obj-$(CONFIG_HDCP_RK30) += hdcp/
+obj-$(CONFIG_RK_HDMI) += rk_hdmi_edid.o rk_hdmi_lcdc.o rk_hdmi_task.o rk_hdmi_sysfs.o
+obj-$(CONFIG_RK_HDMI) += chips/
diff --git a/drivers/video/rockchip/hdmi/chips/Kconfig b/drivers/video/rockchip/hdmi/chips/Kconfig
new file mode 100755
index 0000000..5f5067b
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/Kconfig
@@ -0,0 +1,20 @@
+config  HDMI_RK30
+        bool "RK30 HDMI support"
+        depends on LCDC_RK30
+        help
+           Support rk30 hdmi if you say y here
+
+if HDMI_RK30
+source "drivers/video/rockchip/hdmi/chips/rk30/Kconfig"
+endif
+
+config  HDMI_RK610
+        bool "RK610 HDMI support"
+        depends on MFD_RK610
+        help
+           Support rk610 hdmi if you say y here
+
+if HDMI_RK610
+source "drivers/video/rockchip/hdmi/chips/rk610/Kconfig"
+endif
+
diff --git a/drivers/video/rockchip/hdmi/chips/Makefile b/drivers/video/rockchip/hdmi/chips/Makefile
new file mode 100755
index 0000000..38cb73e
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for HDMI linux kernel module.
+#
+
+ccflags-$(CONFIG_HDMI_RK30_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
+obj-$(CONFIG_HDMI_RK30) += rk30/
+obj-$(CONFIG_HDMI_RK2928) += rk2928/
+obj-$(CONFIG_HDMI_RK610) += rk610/
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/Kconfig b/drivers/video/rockchip/hdmi/chips/rk30/Kconfig
new file mode 100755
index 0000000..27edf41
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/Kconfig
@@ -0,0 +1 @@
+source "drivers/video/rockchip/hdmi/chips/rk30/hdcp/Kconfig"
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/Makefile b/drivers/video/rockchip/hdmi/chips/rk30/Makefile
new file mode 100755
index 0000000..0704c99
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for HDMI linux kernel module.
+#
+
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+
+obj-$(CONFIG_HDMI_RK30) += rk30_hdmi_hw.o rk30_hdmi.o
+obj-$(CONFIG_HDCP_RK30) += hdcp/
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Kconfig b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Kconfig
new file mode 100755
index 0000000..1bb3c3a
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Kconfig
@@ -0,0 +1,14 @@
+config HDCP_RK30
+	bool "RK30 HDCP support"
+        depends on LCDC_RK30 && HDMI_RK30
+        default n
+	help
+	  HDCP Interface. This adds the High Definition Content Protection Interface.
+	  See http://www.digital-cp.com/ for HDCP specification.
+
+config HDCP_RK30_DEBUG
+	bool "RK30 HDCP Debugging"
+        depends on HDCP_RK30
+        default n
+	help
+	  Enableds verbose debugging the the HDCP drivers
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Makefile b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Makefile
new file mode 100755
index 0000000..108b67c
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for HDCP linux kernel module.
+#
+
+ccflags-$(CONFIG_HDCP_RK30_DEBUG) = -DDEBUG -DHDCP_DEBUG
+
+obj-$(CONFIG_HDCP_RK30) += hdcp.o
+hdcp-y := rk30_hdcp.o rk30_hdmi_hdcp.o
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdcp.c b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdcp.c
new file mode 100755
index 0000000..68d0ac8
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdcp.c
@@ -0,0 +1,570 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include "../rk30_hdmi.h"
+#include "../rk30_hdmi_hw.h"
+#include "rk30_hdmi_hdcp.h"
+
+struct hdcp *hdcp = NULL;
+
+static void hdcp_work_queue(struct work_struct *work);
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_submit_work
+ *-----------------------------------------------------------------------------
+ */
+static struct delayed_work *hdcp_submit_work(int event, int delay)
+{
+	struct hdcp_delayed_work *work;
+
+	DBG("%s event %04x delay %d", __FUNCTION__, event, delay);
+	
+	work = kmalloc(sizeof(struct hdcp_delayed_work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
+		work->event = event;
+		queue_delayed_work(hdcp->workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+	} else {
+		printk(KERN_WARNING "HDCP: Cannot allocate memory to "
+				    "create work\n");
+		return 0;
+	}
+
+	return &work->work;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_cancel_work
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_cancel_work(struct delayed_work **work)
+{
+	int ret = 0;
+
+	if (*work) {
+		ret = cancel_delayed_work(*work);
+		if (ret != 1) {
+			ret = cancel_work_sync(&((*work)->work));
+			printk(KERN_INFO "Canceling work failed - "
+					 "cancel_work_sync done %d\n", ret);
+		}
+		kfree(*work);
+		*work = 0;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_failure
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_failure(void)
+{
+	if (hdcp->hdmi_state == HDMI_STOPPED) {
+		return;
+	}
+
+	rk30_hdcp_disable();
+	rk30_hdmi_control_output(false);
+	
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+
+	if (hdcp->retry_cnt && (hdcp->hdmi_state != HDMI_STOPPED)) {
+		if (hdcp->retry_cnt < HDCP_INFINITE_REAUTH) {
+			hdcp->retry_cnt--;
+			printk(KERN_INFO "HDCP: authentication failed - "
+					 "retrying, attempts=%d\n",
+							hdcp->retry_cnt);
+		} else
+			printk(KERN_INFO "HDCP: authentication failed - "
+					 "retrying\n");
+
+		hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+
+		hdcp->pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
+							 HDCP_REAUTH_DELAY);
+	} else {
+		printk(KERN_INFO "HDCP: authentication failed - "
+				 "HDCP disabled\n");
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+	}
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_start_authentication
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_start_authentication(void)
+{
+	int status = HDCP_OK;
+
+	hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+
+	DBG("HDCP: authentication start");
+
+	status = rk30_hdcp_start_authentication();
+
+	if (status != HDCP_OK) {
+		DBG("HDCP: authentication failed");
+		hdcp_wq_authentication_failure();
+	} else {
+		hdcp->hdcp_state = HDCP_WAIT_KSV_LIST;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_check_bksv
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_check_bksv(void)
+{
+	int status = HDCP_OK;
+
+	DBG("Check BKSV start");
+	
+	status = rk30_hdcp_check_bksv();
+
+	if (status != HDCP_OK) {
+		printk(KERN_INFO "HDCP: Check BKSV failed");
+		hdcp->retry_cnt = 0;
+		hdcp_wq_authentication_failure();
+	}
+	else {
+		DBG("HDCP: Check BKSV successful");
+
+		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+
+		/* Restore retry counter */
+		if(hdcp->retry_times == 0)
+			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+		else
+			hdcp->retry_cnt = hdcp->retry_times;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_sucess
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_sucess(void)
+{
+	printk(KERN_INFO "HDCP: authentication pass");
+	rk30_hdmi_control_output(true);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_disable
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_disable(int event)
+{
+	printk(KERN_INFO "HDCP: disabled");
+
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	rk30_hdcp_disable();
+	if(event == HDCP_DISABLE_CTL) {
+		hdcp->hdcp_state = HDCP_DISABLED;
+		if(hdcp->hdmi_state == HDMI_STARTED)
+			rk30_hdmi_control_output(true);			
+	}
+	else if(event == HDCP_STOP_FRAME_EVENT)
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_work_queue
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_work_queue(struct work_struct *work)
+{
+	struct hdcp_delayed_work *hdcp_w =
+		container_of(work, struct hdcp_delayed_work, work.work);
+	int event = hdcp_w->event;
+
+	mutex_lock(&hdcp->lock);
+	
+	DBG("hdcp_work_queue() - START - %u hdmi=%d hdcp=%d evt= %x %d",
+		jiffies_to_msecs(jiffies),
+		hdcp->hdmi_state,
+		hdcp->hdcp_state,
+		(event & 0xFF00) >> 8,
+		event & 0xFF);
+	
+	if(event == HDCP_STOP_FRAME_EVENT) {
+		hdcp->hdmi_state = HDMI_STOPPED;
+	}
+	
+	if (event == HDCP_DISABLE_CTL || event == HDCP_STOP_FRAME_EVENT) {
+		hdcp_wq_disable(event);
+	}
+	
+	if (event & HDCP_WORKQUEUE_SRC)
+		hdcp->pending_wq_event = 0;
+	
+	/* First handle HDMI state */
+	if (event == HDCP_START_FRAME_EVENT) {
+		hdcp->pending_start = 0;
+		hdcp->hdmi_state = HDMI_STARTED;
+	}
+	
+	/**********************/
+	/* HDCP state machine */
+	/**********************/
+	switch (hdcp->hdcp_state) {
+		case HDCP_DISABLED:
+			/* HDCP enable control or re-authentication event */
+			if (event == HDCP_ENABLE_CTL) {
+				if(hdcp->retry_times == 0)
+					hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+				else
+					hdcp->retry_cnt = hdcp->retry_times;
+				if (hdcp->hdmi_state == HDMI_STARTED)
+					hdcp_wq_start_authentication();
+				else
+					hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+			}
+			break;
+		
+		case HDCP_ENABLE_PENDING:
+			/* HDMI start frame event */
+			if (event == HDCP_START_FRAME_EVENT)
+				hdcp_wq_start_authentication();
+
+			break;
+		
+		case HDCP_AUTHENTICATION_START:
+			/* Re-authentication */
+			if (event == HDCP_AUTH_REATT_EVENT)
+				hdcp_wq_start_authentication();
+	
+			break;
+		
+		case HDCP_WAIT_KSV_LIST:
+			/* KSV failure */
+			if (event == HDCP_FAIL_EVENT) {
+				printk(KERN_INFO "HDCP: KSV switch failure\n");
+	
+				hdcp_wq_authentication_failure();
+			}
+			/* KSV list ready event */
+			else if (event == HDCP_KSV_LIST_RDY_EVENT)
+				hdcp_wq_check_bksv();
+			break;
+		
+		case HDCP_LINK_INTEGRITY_CHECK:
+			/* Ri failure */
+			if (event == HDCP_FAIL_EVENT) {
+				printk(KERN_INFO "HDCP: Ri check failure\n");
+				hdcp_wq_authentication_failure();
+			}
+			else if(event == HDCP_AUTH_PASS_EVENT)
+				hdcp_wq_authentication_sucess();
+			break;
+	
+		default:
+			printk(KERN_WARNING "HDCP: error - unknow HDCP state\n");
+			break;
+	}
+	
+	kfree(hdcp_w);
+	if(event == HDCP_STOP_FRAME_EVENT)
+		complete(&hdcp->complete);
+		
+	mutex_unlock(&hdcp->lock);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_start_frame_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_start_frame_cb(void)
+{
+	DBG("hdcp_start_frame_cb()");
+
+	/* Cancel any pending work */
+	if (hdcp->pending_start)
+		hdcp_cancel_work(&hdcp->pending_start);
+	if (hdcp->pending_wq_event)
+		hdcp_cancel_work(&hdcp->pending_wq_event);
+
+	hdcp->pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
+							HDCP_ENABLE_DELAY);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_irq_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_irq_cb(int interrupt)
+{
+	int value;
+	DBG("%s 0x%x", __FUNCTION__, interrupt);
+	if(interrupt & m_INT_HDCP_ERR)
+	{
+		value = HDMIRdReg(HDCP_ERROR);
+		HDMIWrReg(HDCP_ERROR, value);
+		printk(KERN_INFO "HDCP: Error 0x%02x\n", value);
+		
+		if( (hdcp->hdcp_state != HDCP_DISABLED) &&
+			(hdcp->hdcp_state != HDCP_ENABLE_PENDING) )
+		{	
+			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
+		}
+	}
+	else if(interrupt & (m_INT_BKSV_RPRDY | m_INT_BKSV_RCRDY))
+		hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
+	else if(interrupt & m_INT_AUTH_DONE)
+		hdcp_submit_work(HDCP_AUTH_PASS_EVENT, 0);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_on_cb
+ *-----------------------------------------------------------------------------
+ */
+static int hdcp_power_on_cb(void)
+{
+	DBG("%s", __FUNCTION__);
+	return rk30_hdcp_load_key2mem(hdcp->keys);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_off_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_power_off_cb(void)
+{
+	DBG("%s", __FUNCTION__);
+	if(!hdcp->enable)
+		return;
+	
+	hdcp_cancel_work(&hdcp->pending_start);
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	init_completion(&hdcp->complete);
+	/* Post event to workqueue */
+	if (hdcp_submit_work(HDCP_STOP_FRAME_EVENT, 0))	
+		wait_for_completion_interruptible_timeout(&hdcp->complete,
+							msecs_to_jiffies(2000));
+}
+
+// Load HDCP key to external HDCP memory
+static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
+{
+	if (!fw) {
+		pr_err("HDCP: failed to load keys\n");
+		return;
+	}
+	
+	if(fw->size < HDCP_KEY_SIZE) {
+		pr_err("HDCP: firmware wrong size %d\n", fw->size);
+		return;
+	}
+	
+	hdcp->keys =  kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
+	if(hdcp->keys == NULL) {
+		pr_err("HDCP: can't allocated space for keys\n");
+		return;
+	}
+	
+	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
+	
+	rk30_hdcp_load_key2mem(hdcp->keys);
+	printk(KERN_INFO "HDCP: loaded hdcp key success\n");
+
+	if(fw->size > HDCP_KEY_SIZE) {
+		DBG("%s invalid key size %d", __FUNCTION__, fw->size - HDCP_KEY_SIZE);
+		if((fw->size - HDCP_KEY_SIZE) % 5) {
+			pr_err("HDCP: failed to load invalid keys\n");
+			return;
+		}
+		hdcp->invalidkeys = kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
+		if(hdcp->invalidkeys == NULL) {
+			pr_err("HDCP: can't allocated space for invalid keys\n");
+			return;
+		}
+		memcpy(hdcp->invalidkeys, fw->data + HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
+		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE)/5;
+		printk(KERN_INFO "HDCP: loaded hdcp invalid key success\n");
+	}
+}
+
+static ssize_t hdcp_enable_read(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	int enable = 0;
+	
+	if(hdcp)
+		enable = hdcp->enable;
+		
+	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
+}
+
+static ssize_t hdcp_enable_write(struct device *device,
+			   struct device_attribute *attr, const char *buf, size_t count)
+{
+	int enable;
+
+	if(hdcp == NULL)
+		return -EINVAL;
+	
+	sscanf(buf, "%d", &enable);
+	if(hdcp->enable != enable)
+	{
+		/* Post event to workqueue */
+		if(enable) {
+			if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
+				return -EFAULT;
+		}
+		else {
+			hdcp_cancel_work(&hdcp->pending_start);
+			hdcp_cancel_work(&hdcp->pending_wq_event);
+		
+			/* Post event to workqueue */
+			if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
+				return -EFAULT;
+		}
+		hdcp->enable = 	enable;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR, hdcp_enable_read, hdcp_enable_write);
+
+static ssize_t hdcp_trytimes_read(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	int trytimes = 0;
+	
+	if(hdcp)
+		trytimes = hdcp->retry_times;
+		
+	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
+}
+
+static ssize_t hdcp_trytimes_wrtie(struct device *device,
+			   struct device_attribute *attr, const char *buf, size_t count)
+{
+	int trytimes;
+
+	if(hdcp == NULL)
+		return -EINVAL;
+	
+	sscanf(buf, "%d", &trytimes);
+	if(hdcp->retry_times != trytimes)
+		hdcp->retry_times = trytimes;
+	
+	return count;
+}
+
+
+static DEVICE_ATTR(trytimes, S_IRUGO|S_IWUSR, hdcp_trytimes_read, hdcp_trytimes_wrtie);
+
+
+static struct miscdevice mdev;
+
+static int __init rk30_hdcp_init(void)
+{
+	int ret;
+	
+	DBG("[%s] %u", __FUNCTION__, jiffies_to_msecs(jiffies));
+	
+	hdcp = kmalloc(sizeof(struct hdcp), GFP_KERNEL);
+	if(!hdcp)
+	{
+    	printk(KERN_ERR ">>HDCP: kmalloc fail!");
+    	ret = -ENOMEM;
+    	goto error0; 
+	}
+	memset(hdcp, 0, sizeof(struct hdcp));
+	mutex_init(&hdcp->lock);
+	
+	mdev.minor = MISC_DYNAMIC_MINOR;
+	mdev.name = "hdcp";
+	mdev.mode = 0666;
+	if (misc_register(&mdev)) {
+		printk(KERN_ERR "HDCP: Could not add character driver\n");
+		ret = HDMI_ERROR_FALSE;
+		goto error1;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_enable);
+    if(ret)
+    {
+        printk(KERN_ERR "HDCP: Could not add sys file enable\n");
+        ret = -EINVAL;
+        goto error2;
+    }
+    
+    ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
+    if(ret)
+    {
+        printk(KERN_ERR "HDCP: Could not add sys file trytimes\n");
+        ret = -EINVAL;
+        goto error3;
+    }
+    
+    hdcp->workqueue = create_singlethread_workqueue("hdcp");
+	if (hdcp->workqueue == NULL) {
+		printk(KERN_ERR "HDCP,: create workqueue failed.\n");
+		goto error4;
+	}
+    
+    
+    ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
+			      "hdcp.keys", mdev.this_device, GFP_KERNEL,
+			      hdcp, hdcp_load_keys_cb);
+	if (ret < 0) {
+		printk(KERN_ERR "HDCP: request_firmware_nowait failed: %d\n", ret);
+		goto error5;
+	}
+	
+	rk30_hdmi_register_hdcp_callbacks(	hdcp_start_frame_cb,
+										hdcp_irq_cb,
+										hdcp_power_on_cb,
+										hdcp_power_off_cb);
+										
+	DBG("%s success %u", __FUNCTION__, jiffies_to_msecs(jiffies));
+	return 0;
+	
+error5:
+	destroy_workqueue(hdcp->workqueue);
+error4:
+	device_remove_file(mdev.this_device, &dev_attr_trytimes);
+error3:
+	device_remove_file(mdev.this_device, &dev_attr_enable);
+error2:
+	misc_deregister(&mdev);
+error1:
+	if(hdcp->keys)
+		kfree(hdcp->keys);
+	if(hdcp->invalidkeys)
+		kfree(hdcp->invalidkeys);
+	kfree(hdcp);
+error0:
+	return ret;
+}
+
+static void __exit rk30_hdcp_exit(void)
+{
+	if(hdcp) {
+		mutex_lock(&hdcp->lock);
+		rk30_hdmi_register_hdcp_callbacks(0, 0, 0, 0);
+		device_remove_file(mdev.this_device, &dev_attr_enable);
+		misc_deregister(&mdev);
+		destroy_workqueue(hdcp->workqueue);
+		if(hdcp->keys)
+			kfree(hdcp->keys);
+		if(hdcp->invalidkeys)
+			kfree(hdcp->invalidkeys);
+		mutex_unlock(&hdcp->lock);
+		kfree(hdcp);
+	}
+}
+
+module_init(rk30_hdcp_init);
+module_exit(rk30_hdcp_exit);
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.c b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.c
new file mode 100755
index 0000000..1184989
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.c
@@ -0,0 +1,157 @@
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <mach/io.h>
+#include "../rk30_hdmi.h"
+#include "../rk30_hdmi_hw.h"
+#include "rk30_hdmi_hdcp.h"
+
+static void rk30_hdcp_write_mem(int addr_8, char value)
+{
+	int temp;
+	int addr_32 = addr_8 - addr_8%4;
+	int shift = (addr_8%4) * 8;
+	
+	temp = HDMIRdReg(addr_32);
+	temp &= ~(0xff << shift);
+	temp |= value << shift;
+//	printk("temp is %08x\n", temp);
+	HDMIWrReg(addr_32, temp);
+}
+
+int rk30_hdcp_load_key2mem(struct hdcp_keys *key)
+{
+	int i;
+	
+	if(key == NULL)	return	HDMI_ERROR_FALSE;
+	
+	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV);
+	
+	for(i = 0; i < 7; i++)
+		rk30_hdcp_write_mem(HDCP_RAM_KEY_KSV1 + i, key->KSV[i]);
+	for(i = 0; i < 7; i++)
+		rk30_hdcp_write_mem(HDCP_RAM_KEY_KSV2 + i, key->KSV[i]);
+	for(i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++)
+		rk30_hdcp_write_mem(HDCP_RAM_KEY_PRIVATE + i, key->DeviceKey[i]);
+	for(i = 0; i < HDCP_KEY_SHA_SIZE; i++)
+		rk30_hdcp_write_mem(HDCP_RAM_KEY_PRIVATE + HDCP_PRIVATE_KEY_SIZE + i, key->sha1[i]);
+	
+	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV | 0x20);
+	return HDCP_OK;
+}
+
+void rk30_hdcp_disable(void)
+{
+	int temp;
+	// Diable HDCP Interrupt
+	HDMIWrReg(INTR_MASK2, 0x00);
+	// Stop and Reset HDCP
+	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_FRAMED_ENCRYPED | m_HDCP_AUTH_STOP | m_HDCP_RESET, 
+		v_HDCP_FRAMED_ENCRYPED(0) | v_HDCP_AUTH_STOP(1) | v_HDCP_RESET(1) );
+}
+
+static int rk30_hdcp_load_key(void)
+{
+	int value, temp = 0;
+	
+	if(hdcp->keys == NULL) {
+		pr_err("[%s] HDCP key not loaded.\n", __FUNCTION__);
+		return HDCP_KEY_ERR;
+	}
+	
+	value = HDMIRdReg(HDCP_KEY_MEM_CTRL);
+	//Check HDCP key loaded from external HDCP memory
+	while((value & (m_KSV_VALID | m_KEY_VALID | m_KEY_READY)) != (m_KSV_VALID | m_KEY_VALID | m_KEY_READY)) {
+		if(temp > 10) {
+			pr_err("[%s] loaded hdcp key is incorrectable %02x\n", __FUNCTION__, value & 0xFF);
+			return HDCP_KEY_ERR;
+		}
+		//Load HDCP Key from external HDCP memory
+		HDMIWrReg(HDCP_KEY_ACCESS_CTRL2, m_LOAD_HDCP_KEY);
+		msleep(1);
+		value = HDMIRdReg(HDCP_KEY_MEM_CTRL);
+		temp++;
+	}
+	
+	return HDCP_OK;
+}
+
+
+int rk30_hdcp_start_authentication(void)
+{
+	int rc, temp;
+	
+	rc = rk30_hdcp_load_key();
+	if(rc != HDCP_OK)
+		return rc;
+	
+	// Set 100ms & 5 sec timer
+	switch(hdmi->vic)
+	{
+		case HDMI_720x576p_50Hz_4_3:
+		case HDMI_720x576p_50Hz_16_9:
+		case HDMI_1280x720p_50Hz:
+		case HDMI_1920x1080i_50Hz:
+		case HDMI_720x576i_50Hz_4_3:
+		case HDMI_720x576i_50Hz_16_9:
+		case HDMI_1920x1080p_50Hz:
+			HDMIWrReg(HDCP_TIMER_100MS, 5);
+			HDMIWrReg(HDCP_TIMER_5S, 250);
+			break;
+		
+		default:
+			HDMIWrReg(HDCP_TIMER_100MS, 0x26);
+			HDMIWrReg(HDCP_TIMER_5S, 0x2c);
+			break;
+	}
+	// Config DDC Clock
+	temp = (hdmi->tmdsclk/HDCP_DDC_CLK)/4;
+	HDMIWrReg(DDC_BUS_FREQ_L, temp & 0xFF);
+	HDMIWrReg(DDC_BUS_FREQ_H, (temp >> 8) & 0xFF);
+	// Enable HDCP Interrupt
+	HDMIWrReg(INTR_MASK2, m_INT_HDCP_ERR | m_INT_BKSV_RPRDY | m_INT_BKSV_RCRDY | m_INT_AUTH_DONE | m_INT_AUTH_READY);
+	// Start HDCP
+	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_AUTH_START | m_HDCP_FRAMED_ENCRYPED, v_HDCP_AUTH_START(1) | v_HDCP_FRAMED_ENCRYPED(0));
+	
+	return HDCP_OK;
+}
+
+int rk30_hdcp_check_bksv(void)
+{
+	int i, temp;
+	char bksv[5];
+	char *invalidkey;
+	
+	temp = HDMIRdReg(HDCP_BCAPS);
+	DBG("Receiver capacity is 0x%02x", temp);
+	
+#ifdef DEBUG	
+	if(temp & m_HDMI_RECEIVED)
+		DBG("Receiver support HDMI");
+	if(temp & m_REPEATER)
+		DBG("Receiver is a repeater");
+	if(temp & m_DDC_FAST)
+		DBG("Receiver support 400K DDC");
+	if(temp & m_1_1_FEATURE)
+		DBG("Receiver support 1.1 features, such as advanced cipher, EESS.");
+	if(temp & m_FAST_REAUTHENTICATION)
+		DBG("Receiver support fast reauthentication.");
+#endif
+		
+	for(i = 0; i < 5; i++) {
+		bksv[i] = HDMIRdReg(HDCP_KSV_BYTE0 + (4 - i)*4) & 0xFF;
+	}
+	
+	DBG("bksv is 0x%02x%02x%02x%02x%02x", bksv[0], bksv[1], bksv[2], bksv[3], bksv[4]);
+	
+	for(i = 0; i < hdcp->invalidkey; i++)
+	{
+		invalidkey = hdcp->invalidkeys + i *5;
+		if(memcmp(bksv, invalidkey, 5) == 0) {
+			printk(KERN_ERR "HDCP: BKSV was revocated!!!\n");
+			HDMIMskReg(temp, HDCP_CTRL, m_HDCP_BKSV_FAILED | m_HDCP_FRAMED_ENCRYPED, v_HDCP_BKSV_FAILED(1) | v_HDCP_FRAMED_ENCRYPED(0));
+			return HDCP_KSV_ERR;
+		}
+	}
+	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_BKSV_PASS | m_HDCP_FRAMED_ENCRYPED, v_HDCP_BKSV_PASS(1) | v_HDCP_FRAMED_ENCRYPED(1));
+	return HDCP_OK;
+}
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.h b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.h
new file mode 100755
index 0000000..0224d88
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/hdcp/rk30_hdmi_hdcp.h
@@ -0,0 +1,99 @@
+#ifndef __RK30_HDMI_HDCP_H__
+#define __RK30_HDMI_HDCP_H__
+
+/***************************/
+/* Definitions             */
+/***************************/
+
+/* Status / error codes */
+#define HDCP_OK			0
+#define HDCP_KEY_ERR	1
+#define HDCP_KSV_ERR	2
+
+/* Delays */
+#define HDCP_ENABLE_DELAY	300
+#define HDCP_REAUTH_DELAY	100
+
+/* Event source */
+#define HDCP_SRC_SHIFT		8
+#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
+#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
+#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
+#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
+
+/* Event */
+#define HDCP_ENABLE_CTL			(HDCP_IOCTL_SRC		| 0)
+#define HDCP_DISABLE_CTL		(HDCP_IOCTL_SRC		| 1)
+#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC		| 2)
+#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC		| 3)
+#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC		| 4)
+#define HDCP_FAIL_EVENT			(HDCP_IRQ_SRC		| 5)
+#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC		| 6)
+#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC	| 7)
+
+/* Key size */
+#define HDCP_KEY_SIZE			308	
+
+/* Authentication retry times */
+#define HDCP_INFINITE_REAUTH	0x100
+
+enum hdcp_states {
+	HDCP_DISABLED,
+	HDCP_ENABLE_PENDING,
+	HDCP_AUTHENTICATION_START,
+	HDCP_WAIT_KSV_LIST,
+	HDCP_LINK_INTEGRITY_CHECK,
+};
+
+enum hdmi_states {
+	HDMI_STOPPED,
+	HDMI_STARTED
+};
+
+#define HDCP_PRIVATE_KEY_SIZE	280
+#define HDCP_KEY_SHA_SIZE		20
+#define HDCP_DDC_CLK			100000
+
+struct hdcp_keys{
+	u8 KSV[8];
+	u8 DeviceKey[HDCP_PRIVATE_KEY_SIZE];
+	u8 sha1[HDCP_KEY_SHA_SIZE];
+};
+
+struct hdcp_delayed_work {
+	struct delayed_work work;
+	int event;
+};
+
+struct hdcp {
+	int	enable;
+	int retry_times;
+	struct hdcp_keys *keys;
+	int invalidkey;
+	char *invalidkeys;	
+	struct mutex lock;
+	struct completion	complete;
+	struct workqueue_struct *workqueue;
+	
+	enum hdmi_states hdmi_state;
+	enum hdcp_states hdcp_state;
+	
+	struct delayed_work *pending_start;
+	struct delayed_work *pending_wq_event;
+	int retry_cnt;
+};
+
+extern struct hdcp *hdcp;
+
+#ifdef HDCP_DEBUG
+#define DBG(format, ...) \
+		printk(KERN_INFO "HDCP: " format "\n", ## __VA_ARGS__)
+#else
+#define DBG(format, ...)
+#endif
+
+extern void rk30_hdcp_disable(void);
+extern int	rk30_hdcp_start_authentication(void);
+extern int	rk30_hdcp_check_bksv(void);
+extern int	rk30_hdcp_load_key2mem(struct hdcp_keys *key);
+#endif /* __RK30_HDMI_HDCP_H__ */
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.c b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.c
new file mode 100755
index 0000000..aab3ecb
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.c
@@ -0,0 +1,299 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <mach/board.h>
+#include <mach/io.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include "rk30_hdmi.h"
+#include "rk30_hdmi_hw.h"
+
+struct hdmi *hdmi = NULL;
+
+extern irqreturn_t hdmi_irq(int irq, void *priv);
+extern void hdmi_work(struct work_struct *work);
+extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
+extern void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent);
+extern void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
+
+int rk30_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void))
+{
+	if(hdmi == NULL)
+		return HDMI_ERROR_FALSE;
+
+	hdmi->hdcp_cb = hdcp_cb;
+	hdmi->hdcp_irq_cb = hdcp_irq_cb;
+	hdmi->hdcp_power_on_cb = hdcp_power_on_cb;
+	hdmi->hdcp_power_off_cb = hdcp_power_off_cb;
+	
+	return HDMI_ERROR_SUCESS;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hdmi_early_suspend(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi->pwr_mode, hdmi->state);
+	// When HDMI 1.1V and 2.5V power off, DDC channel will be pull down, current is produced
+	// from VCC_IO which is pull up outside soc. We need to switch DDC IO to GPIO.
+	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_GPIO0A2);
+	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_GPIO0A1);
+	flush_delayed_work(&hdmi->delay_work);	
+	mutex_lock(&hdmi->enable_mutex);
+	hdmi->suspend = 1;
+	if(!hdmi->enable) {
+		mutex_unlock(&hdmi->enable_mutex);
+		return;
+	}
+	disable_irq(hdmi->irq);
+	mutex_unlock(&hdmi->enable_mutex);
+	hdmi->command = HDMI_CONFIG_ENABLE;
+	init_completion(&hdmi->complete);
+	hdmi->wait = 1;
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+	wait_for_completion_interruptible_timeout(&hdmi->complete,
+							msecs_to_jiffies(5000));
+	flush_delayed_work(&hdmi->delay_work);
+	return;
+}
+
+static void hdmi_early_resume(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi exit early resume\n");
+	mutex_lock(&hdmi->enable_mutex);
+	
+	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_HDMI_I2C_SDA);
+	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_HDMI_I2C_SCL);
+	
+	hdmi->suspend = 0;
+	rk30_hdmi_initial();
+	if(hdmi->enable) {
+		enable_irq(hdmi->irq);
+	}
+	mutex_unlock(&hdmi->enable_mutex);
+	return;
+}
+#endif
+
+static inline void hdmi_io_remap(void)
+{
+	unsigned int value;
+	
+	// Remap HDMI IO Pin
+	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_HDMI_I2C_SDA);
+	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_HDMI_I2C_SCL);
+	rk30_mux_api_set(GPIO0A0_HDMIHOTPLUGIN_NAME, GPIO0A_HDMI_HOT_PLUG_IN);
+		
+	// Select LCDC0 as video source and enabled.
+	value = (HDMI_SOURCE_DEFAULT << 14) | (1 << 30);
+	writel(value, GRF_SOC_CON0 + RK30_GRF_BASE);
+}
+
+static int __devinit rk30_hdmi_probe (struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+	struct resource *mem;
+	
+	hdmi = kmalloc(sizeof(struct hdmi), GFP_KERNEL);
+	if(!hdmi)
+	{
+    	dev_err(&pdev->dev, ">>rk30 hdmi kmalloc fail!");
+    	return -ENOMEM;
+	}
+	memset(hdmi, 0, sizeof(struct hdmi));
+	hdmi->dev = &pdev->dev;
+	platform_set_drvdata(pdev, hdmi);
+
+	if(HDMI_SOURCE_DEFAULT == HDMI_SOURCE_LCDC0)
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
+	else
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
+	if(hdmi->lcdc == NULL)
+	{
+		dev_err(hdmi->dev, "can not connect to video source lcdc\n");
+		ret = -ENXIO;
+		goto err0;
+	}
+	hdmi->xscale = 95;
+	hdmi->yscale = 95;
+	
+	hdmi->hclk = clk_get(NULL,"hclk_hdmi");
+	if(IS_ERR(hdmi->hclk))
+	{
+		dev_err(hdmi->dev, "Unable to get hdmi hclk\n");
+		ret = -ENXIO;
+		goto err0;
+	}
+	clk_enable(hdmi->hclk);
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(hdmi->dev, "Unable to get register resource\n");
+		ret = -ENXIO;
+		goto err0;
+	}
+	hdmi->regbase_phy = res->start;
+	hdmi->regsize_phy = (res->end - res->start) + 1;
+	mem = request_mem_region(res->start, (res->end - res->start) + 1, pdev->name);
+	if (!mem)
+	{
+    	dev_err(hdmi->dev, "failed to request mem region for hdmi\n");
+    	ret = -ENOENT;
+    	goto err0;
+	}
+
+	
+	hdmi->regbase = (int)ioremap(res->start, (res->end - res->start) + 1);
+	if (!hdmi->regbase) {
+		dev_err(hdmi->dev, "cannot ioremap registers\n");
+		ret = -ENXIO;
+		goto err1;
+	}
+	
+	ret = rk30_hdmi_initial();
+	if(ret != HDMI_ERROR_SUCESS)
+		goto err1;
+		
+	hdmi_io_remap();
+	hdmi_sys_init();
+	
+	hdmi->workqueue = create_singlethread_workqueue("hdmi");
+	INIT_DELAYED_WORK(&(hdmi->delay_work), hdmi_work);
+
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	hdmi->early_suspend.suspend = hdmi_early_suspend;
+	hdmi->early_suspend.resume = hdmi_early_resume;
+	hdmi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 10;
+	register_early_suspend(&hdmi->early_suspend);
+	#endif
+		
+	hdmi_register_display_sysfs(hdmi, NULL);
+	#ifdef CONFIG_SWITCH
+	hdmi->switch_hdmi.name="hdmi";
+	switch_dev_register(&(hdmi->switch_hdmi));
+	#endif
+		
+	spin_lock_init(&hdmi->irq_lock);
+	mutex_init(&hdmi->enable_mutex);
+	
+	/* get the IRQ */
+	hdmi->irq = platform_get_irq(pdev, 0);
+	if(hdmi->irq <= 0) {
+		dev_err(hdmi->dev, "failed to get hdmi irq resource (%d).\n", hdmi->irq);
+		ret = -ENXIO;
+		goto err2;
+	}
+
+	/* request the IRQ */
+	ret = request_irq(hdmi->irq, hdmi_irq, 0, dev_name(&pdev->dev), hdmi);
+	if (ret)
+	{
+		dev_err(hdmi->dev, "hdmi request_irq failed (%d).\n", ret);
+		goto err2;
+	}
+
+	hdmi_dbg(hdmi->dev, "rk30 hdmi probe sucess.\n");
+	return 0;
+err2:
+	#ifdef CONFIG_SWITCH
+	switch_dev_unregister(&(hdmi->switch_hdmi));
+	#endif
+	hdmi_unregister_display_sysfs(hdmi);
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&hdmi->early_suspend);
+	#endif
+	iounmap((void*)hdmi->regbase);
+err1:
+	release_mem_region(res->start,(res->end - res->start) + 1);
+	clk_disable(hdmi->hclk);
+err0:
+	hdmi_dbg(hdmi->dev, "rk30 hdmi probe error.\n");
+	kfree(hdmi);
+	hdmi = NULL;
+	return ret;
+}
+
+static int __devexit rk30_hdmi_remove(struct platform_device *pdev)
+{
+	if(hdmi) {
+		mutex_lock(&hdmi->enable_mutex);
+		if(!hdmi->suspend && hdmi->enable)
+			disable_irq(hdmi->irq);
+		mutex_unlock(&hdmi->enable_mutex);
+		free_irq(hdmi->irq, NULL);
+		flush_workqueue(hdmi->workqueue);
+		destroy_workqueue(hdmi->workqueue);
+		#ifdef CONFIG_SWITCH
+		switch_dev_unregister(&(hdmi->switch_hdmi));
+		#endif
+		hdmi_unregister_display_sysfs(hdmi);
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+		iounmap((void*)hdmi->regbase);
+		release_mem_region(hdmi->regbase_phy, hdmi->regsize_phy);
+		clk_disable(hdmi->hclk);
+		fb_destroy_modelist(&hdmi->edid.modelist);
+		if(hdmi->edid.audio)
+			kfree(hdmi->edid.audio);
+		if(hdmi->edid.specs)
+		{
+			if(hdmi->edid.specs->modedb)
+				kfree(hdmi->edid.specs->modedb);
+			kfree(hdmi->edid.specs);
+		}
+		kfree(hdmi);
+		hdmi = NULL;
+	}
+	printk(KERN_INFO "rk30 hdmi removed.\n");
+	return 0;
+}
+
+static void rk30_hdmi_shutdown(struct platform_device *pdev)
+{
+	if(hdmi) {
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+	}
+	printk(KERN_INFO "rk30 hdmi shut down.\n");
+}
+
+static struct platform_driver rk30_hdmi_driver = {
+	.probe		= rk30_hdmi_probe,
+	.remove		= __devexit_p(rk30_hdmi_remove),
+	.driver		= {
+		.name	= "rk30-hdmi",
+		.owner	= THIS_MODULE,
+	},
+	.shutdown   = rk30_hdmi_shutdown,
+};
+
+static int __init rk30_hdmi_init(void)
+{
+    return platform_driver_register(&rk30_hdmi_driver);
+}
+
+static void __exit rk30_hdmi_exit(void)
+{
+    platform_driver_unregister(&rk30_hdmi_driver);
+}
+
+
+//fs_initcall(rk30_hdmi_init);
+module_init(rk30_hdmi_init);
+module_exit(rk30_hdmi_exit);
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.h b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.h
new file mode 100755
index 0000000..f0220d0
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi.h
@@ -0,0 +1,13 @@
+#ifndef __RK30_HDMI_H__
+#define __RK30_HDMI_H__
+
+#include "../../rk_hdmi.h"
+
+/* default HDMI video source */
+#define HDMI_SOURCE_DEFAULT		HDMI_SOURCE_LCDC1
+
+extern int rk30_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int  (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void));
+#endif /* __RK30_HDMI_H__ */
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.c b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.c
new file mode 100755
index 0000000..3e7ed56
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.c
@@ -0,0 +1,667 @@
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <mach/io.h>
+#include "rk30_hdmi.h"
+#include "rk30_hdmi_hw.h"
+
+static char edid_result = 0;
+
+static inline void delay100us(void)
+{
+	msleep(1);
+}
+
+int rk30_hdmi_initial(void)
+{
+	int rc = HDMI_ERROR_SUCESS;
+
+	hdmi->pwr_mode = PWR_SAVE_MODE_A;
+	hdmi->remove = rk30_hdmi_removed ;
+	hdmi->control_output = rk30_hdmi_control_output;
+	hdmi->config_video = rk30_hdmi_config_video;
+	hdmi->config_audio = rk30_hdmi_config_audio;
+	hdmi->detect_hotplug = rk30_hdmi_detect_hotplug;
+	hdmi->read_edid = rk30_hdmi_read_edid;
+	// internal hclk = hdmi_hclk/20
+	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV);
+	
+	if(hdmi->hdcp_power_on_cb)
+		rc = hdmi->hdcp_power_on_cb();
+
+	return rc;
+}
+
+static void rk30_hdmi_set_pwr_mode(int mode)
+{
+	if(hdmi->pwr_mode == mode)
+		return;
+	hdmi_dbg(hdmi->dev, "[%s] mode %d\n", __FUNCTION__, mode);	
+	switch(mode)
+	{
+		case PWR_SAVE_MODE_A:
+			HDMIWrReg(SYS_CTRL, 0x10);
+			break;
+		case PWR_SAVE_MODE_B:
+			HDMIWrReg(SYS_CTRL, 0x20);
+			break;
+		case PWR_SAVE_MODE_D:
+			// reset PLL A&B
+			HDMIWrReg(SYS_CTRL, 0x4C);
+			delay100us();
+			// release PLL A reset
+			HDMIWrReg(SYS_CTRL, 0x48);
+			delay100us();
+			// release PLL B reset
+			HDMIWrReg(SYS_CTRL, 0x40);
+			break;
+		case PWR_SAVE_MODE_E:
+			HDMIWrReg(SYS_CTRL, 0x80);
+			break;
+	}
+	hdmi->pwr_mode = mode;
+	if(mode != PWR_SAVE_MODE_A)
+		msleep(10);
+	hdmi_dbg(hdmi->dev, "[%s] curmode %02x\n", __FUNCTION__, HDMIRdReg(SYS_CTRL));
+}
+
+int rk30_hdmi_detect_hotplug(void)
+{
+	int value =	HDMIRdReg(HPD_MENS_STA);
+	
+	hdmi_dbg(hdmi->dev, "[%s] value %02x\n", __FUNCTION__, value);
+	#if 0
+	// When HPD and TMDS_CLK was high, HDMI is actived.
+	value &= m_HOTPLUG_STATUS | m_MSEN_STATUS;
+	if(value  == (m_HOTPLUG_STATUS | m_MSEN_STATUS) )
+		return HDMI_HPD_ACTIVED;
+	else if(value)
+		return HDMI_HPD_INSERT;
+	else
+		return HDMI_HPD_REMOVED;
+	#else
+	// When HPD was high, HDMI is actived.
+	if(value & m_HOTPLUG_STATUS)
+		return HDMI_HPD_ACTIVED;
+	else if(value & m_MSEN_STATUS)
+		return HDMI_HPD_INSERT;
+	else
+		return HDMI_HPD_REMOVED;
+	#endif
+}
+
+#define HDMI_EDID_DDC_CLK	90000
+int rk30_hdmi_read_edid(int block, unsigned char *buff)
+{
+	int value, ret = -1, ddc_bus_freq = 0;
+	char interrupt = 0, trytime = 2;
+	unsigned long flags;
+	
+	hdmi_dbg(hdmi->dev, "[%s] block %d\n", __FUNCTION__, block);
+	spin_lock_irqsave(&hdmi->irq_lock, flags);
+	edid_result = 0;
+	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
+	//Before Phy parameter was set, DDC_CLK is equal to PLLA freq which is 30MHz.
+	//Set DDC I2C CLK which devided from DDC_CLK to 100KHz.
+	ddc_bus_freq = (30000000/HDMI_EDID_DDC_CLK)/4;
+	HDMIWrReg(DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
+	HDMIWrReg(DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
+	
+	// Enable edid interrupt
+	HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS | m_INT_EDID_ERR | m_INT_EDID_READY);
+	
+	while(trytime--) {
+		// Config EDID block and segment addr
+		HDMIWrReg(EDID_WORD_ADDR, (block%2) * 0x80);
+		HDMIWrReg(EDID_SEGMENT_POINTER, block/2);	
+	
+		value = 100;
+		while(value--)
+		{
+			spin_lock_irqsave(&hdmi->irq_lock, flags);
+			interrupt = edid_result;
+			edid_result = 0;
+			spin_unlock_irqrestore(&hdmi->irq_lock, flags);
+			if(interrupt & (m_INT_EDID_ERR | m_INT_EDID_READY))
+				break;
+			msleep(10);
+		}
+		hdmi_dbg(hdmi->dev, "[%s] edid read value %d\n", __FUNCTION__, value);
+		if(interrupt & m_INT_EDID_READY)
+		{
+			for(value = 0; value < HDMI_EDID_BLOCK_SIZE; value++) 
+				buff[value] = HDMIRdReg(DDC_READ_FIFO_ADDR);
+			ret = 0;
+			
+			hdmi_dbg(hdmi->dev, "[%s] edid read sucess\n", __FUNCTION__);
+#ifdef HDMI_DEBUG
+			for(value = 0; value < 128; value++) {
+				printk("%02x ,", buff[value]);
+				if( (value + 1) % 16 == 0)
+					printk("\n");
+			}
+#endif
+			break;
+		}		
+		if(interrupt & m_INT_EDID_ERR)
+			hdmi_err(hdmi->dev, "[%s] edid read error\n", __FUNCTION__);
+		
+		hdmi_dbg(hdmi->dev, "[%s] edid try times %d\n", __FUNCTION__, trytime);
+		msleep(100);
+	}
+	// Disable edid interrupt
+	HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS);
+	return ret;
+}
+
+static inline void rk30_hdmi_config_phy_reg(int reg, int value)
+{
+	HDMIWrReg(reg, value);
+	HDMIWrReg(SYS_CTRL, 0x2C);
+	delay100us();
+	HDMIWrReg(SYS_CTRL, 0x20);
+	msleep(1);
+}
+
+static void rk30_hdmi_config_phy(unsigned char vic)
+{
+	HDMIWrReg(DEEP_COLOR_MODE, 0x22);	// tmds frequency same as input dlck
+	rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
+	switch(vic)
+	{
+		case HDMI_1920x1080p_60Hz:
+		case HDMI_1920x1080p_50Hz:
+			rk30_hdmi_config_phy_reg(0x158, 0x0E);
+			rk30_hdmi_config_phy_reg(0x15c, 0x00);
+			rk30_hdmi_config_phy_reg(0x160, 0x60);
+			rk30_hdmi_config_phy_reg(0x164, 0x00);
+			rk30_hdmi_config_phy_reg(0x168, 0xDA);
+			rk30_hdmi_config_phy_reg(0x16c, 0xA1);
+			rk30_hdmi_config_phy_reg(0x170, 0x0e);
+			rk30_hdmi_config_phy_reg(0x174, 0x22);
+			rk30_hdmi_config_phy_reg(0x178, 0x00);
+			break;
+			
+		case HDMI_1920x1080i_60Hz:
+		case HDMI_1920x1080i_50Hz:
+		case HDMI_1280x720p_60Hz:
+		case HDMI_1280x720p_50Hz:
+			rk30_hdmi_config_phy_reg(0x158, 0x06);
+			rk30_hdmi_config_phy_reg(0x15c, 0x00);
+			rk30_hdmi_config_phy_reg(0x160, 0x60);
+			rk30_hdmi_config_phy_reg(0x164, 0x00);
+			rk30_hdmi_config_phy_reg(0x168, 0xCA);
+			rk30_hdmi_config_phy_reg(0x16c, 0xA3);
+			rk30_hdmi_config_phy_reg(0x170, 0x0e);
+			rk30_hdmi_config_phy_reg(0x174, 0x20);
+			rk30_hdmi_config_phy_reg(0x178, 0x00);
+			break;
+			
+		case HDMI_720x576p_50Hz_4_3:
+		case HDMI_720x576p_50Hz_16_9:
+		case HDMI_720x480p_60Hz_4_3:
+		case HDMI_720x480p_60Hz_16_9:
+			rk30_hdmi_config_phy_reg(0x158, 0x02);
+			rk30_hdmi_config_phy_reg(0x15c, 0x00);
+			rk30_hdmi_config_phy_reg(0x160, 0x60);
+			rk30_hdmi_config_phy_reg(0x164, 0x00);
+			rk30_hdmi_config_phy_reg(0x168, 0xC2);
+			rk30_hdmi_config_phy_reg(0x16c, 0xA2);
+			rk30_hdmi_config_phy_reg(0x170, 0x0e);
+			rk30_hdmi_config_phy_reg(0x174, 0x20);
+			rk30_hdmi_config_phy_reg(0x178, 0x00);
+			break;
+		default:
+			hdmi_err(hdmi->dev, "not support such vic %d\n", vic);
+			break;
+	}
+}
+
+static void rk30_hdmi_config_avi(unsigned char vic, unsigned char output_color)
+{
+	int i, clolorimetry, aspect_ratio;
+	char info[SIZE_AVI_INFOFRAME];
+	
+	memset(info, 0, SIZE_AVI_INFOFRAME);
+	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AVI);
+	info[0] = 0x82;
+	info[1] = 0x02;
+	info[2] = 0x0D;	
+	info[3] = info[0] + info[1] + info[2];
+
+	if(output_color == VIDEO_OUTPUT_YCBCR444)	
+		info[4] = (AVI_COLOR_MODE_YCBCR444 << 5);
+	else if(output_color == VIDEO_OUTPUT_YCBCR422)
+		info[4] = (AVI_COLOR_MODE_YCBCR422 << 5);
+	else
+		info[4] = (AVI_COLOR_MODE_RGB << 5);
+	info[4] |= (1 << 4);	//Enable active format data bits is present in info[2]
+	
+	switch(vic)
+	{
+		case HDMI_720x480i_60Hz_4_3:
+		case HDMI_720x576i_50Hz_4_3:
+		case HDMI_720x480p_60Hz_4_3:
+		case HDMI_720x576p_50Hz_4_3:				
+			aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
+			clolorimetry = AVI_COLORIMETRY_SMPTE_170M;
+			break;
+		case HDMI_720x480i_60Hz_16_9:
+		case HDMI_720x576i_50Hz_16_9:
+		case HDMI_720x480p_60Hz_16_9:
+		case HDMI_720x576p_50Hz_16_9:
+			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+			clolorimetry = AVI_COLORIMETRY_SMPTE_170M;
+			break;
+		default:
+			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
+			clolorimetry = AVI_COLORIMETRY_ITU709;
+	}
+
+	if(output_color == VIDEO_OUTPUT_RGB444)
+		clolorimetry = AVI_COLORIMETRY_NO_DATA;
+	
+	info[5] = (clolorimetry << 6) | (aspect_ratio << 4) | ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME;
+	info[6] = 0;
+	info[7] = vic;
+	info[8] = 0;
+
+	// Calculate AVI InfoFrame ChecKsum
+	for (i = 4; i < SIZE_AVI_INFOFRAME; i++)
+	{
+    	info[3] += info[i];
+	}
+	info[3] = 0x100 - info[3];
+	
+	for(i = 0; i < SIZE_AVI_INFOFRAME; i++)
+		HDMIWrReg(CONTROL_PACKET_HB0 + i*4, info[i]);
+}
+ 
+static char coeff_csc[][24] = {
+		//G			B			R			Bias
+	{	//CSC_RGB_0_255_TO_ITU601_16_235
+		0x11, 0xb6, 0x02, 0x0b, 0x10, 0x55, 0x00, 0x80, 	//Cr
+		0x02, 0x59, 0x01, 0x32, 0x00, 0x75, 0x00, 0x10, 	//Y
+		0x11, 0x5b, 0x10, 0xb0, 0x02, 0x0b, 0x00, 0x80, 	//Cb
+	},
+	{	//CSC_RGB_0_255_TO_ITU709_16_235
+		0x11, 0xdb, 0x02, 0x0b, 0x10, 0x30, 0x00, 0x80,		//Cr
+		0x02, 0xdc, 0x00, 0xda, 0x00, 0x4a, 0x00, 0x10, 	//Y
+		0x11, 0x93, 0x10, 0x78, 0x02, 0x0b, 0x00, 0x80, 	//Cb
+	},
+		//Y			Cr			Cb			Bias
+	{	//CSC_ITU601_16_235_TO_RGB_16_235
+		0x04, 0x00, 0x05, 0x7c, 0x00, 0x00, 0x02, 0xaf, 	//R
+		0x04, 0x00, 0x12, 0xcb, 0x11, 0x58, 0x00, 0x84, 	//G
+		0x04, 0x00, 0x00, 0x00, 0x06, 0xee, 0x02, 0xde,		//B
+	},
+	{	//CSC_ITU709_16_235_TO_RGB_16_235
+		0x04, 0x00, 0x06, 0x29, 0x00, 0x00, 0x02, 0xc5, 	//R
+		0x04, 0x00, 0x11, 0xd6, 0x10, 0xbb, 0x00, 0x52, 	//G
+		0x04, 0x00, 0x00, 0x00, 0x07, 0x44, 0x02, 0xe8, 	//B
+	},
+	{	//CSC_ITU601_16_235_TO_RGB_0_255
+		0x04, 0xa8, 0x05, 0x7c, 0x00, 0x00, 0x02, 0xc2, 	//R
+		0x04, 0xa8, 0x12, 0xcb, 0x11, 0x58, 0x00, 0x72, 	//G
+		0x04, 0xa8, 0x00, 0x00, 0x06, 0xee, 0x02, 0xf0, 	//B
+	},
+	{	//CSC_ITU709_16_235_TO_RGB_0_255
+		0x04, 0xa8, 0x06, 0x29, 0x00, 0x00, 0x02, 0xd8, 	//R
+		0x04, 0xa8, 0x11, 0xd6, 0x10, 0xbb, 0x00, 0x40, 	//G
+		0x04, 0xa8, 0x00, 0x00, 0x07, 0x44, 0x02, 0xfb, 	//B
+	},
+	
+};
+
+static void rk30_hdmi_config_csc(struct hdmi_video_para *vpara)
+{
+	int i, mode;
+	char *coeff = NULL;
+		
+	if( ((vpara->input_color == VIDEO_INPUT_COLOR_RGB) && (vpara->output_color == VIDEO_OUTPUT_RGB444)) ||
+		((vpara->input_color == VIDEO_INPUT_COLOR_YCBCR) && (vpara->output_color != VIDEO_OUTPUT_RGB444) ))
+	{
+		return;
+	}
+	switch(vpara->vic)
+	{
+		case HDMI_720x480i_60Hz_4_3:
+		case HDMI_720x576i_50Hz_4_3:
+		case HDMI_720x480p_60Hz_4_3:
+		case HDMI_720x576p_50Hz_4_3:
+		case HDMI_720x480i_60Hz_16_9:
+		case HDMI_720x576i_50Hz_16_9:
+		case HDMI_720x480p_60Hz_16_9:
+		case HDMI_720x576p_50Hz_16_9:
+			if(vpara->input_color == VIDEO_INPUT_COLOR_RGB)
+				mode = CSC_RGB_0_255_TO_ITU601_16_235;
+			else if(vpara->output_mode == OUTPUT_HDMI)
+				mode = CSC_ITU601_16_235_TO_RGB_16_235;
+			else
+				mode = CSC_ITU601_16_235_TO_RGB_0_255;
+			break;
+		default:
+			if(vpara->input_color == VIDEO_INPUT_COLOR_RGB)
+				mode = CSC_RGB_0_255_TO_ITU709_16_235;
+			else if(vpara->output_mode == OUTPUT_HDMI)
+				mode = CSC_ITU709_16_235_TO_RGB_16_235;
+			else
+				mode = CSC_ITU709_16_235_TO_RGB_0_255;
+			break;
+	}
+	
+	coeff = coeff_csc[mode];
+	
+	HDMIWrReg(CSC_CONFIG1, v_CSC_MODE(CSC_MODE_MANUAL) | v_CSC_BRSWAP_DIABLE(1));
+	
+	for(i = 0; i < 24; i++)
+		HDMIWrReg(CSC_PARA_C0_H + i*4, coeff[i]);
+		
+	HDMIWrReg(AV_CTRL2, v_CSC_ENABLE(1));
+}
+
+int rk30_hdmi_config_video(struct hdmi_video_para *vpara)
+{
+	int value;
+	struct fb_videomode *mode;
+	
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	if(vpara == NULL) {
+		hdmi_err(hdmi->dev, "[%s] input parameter error\n", __FUNCTION__);
+		return -1;
+	}
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_E)
+		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_D || hdmi->pwr_mode == PWR_SAVE_MODE_A)
+		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
+	
+	if(hdmi->hdcp_power_off_cb)
+		hdmi->hdcp_power_off_cb();
+		
+	// Input video mode is RGB24bit, Data enable signal from external
+	HDMIMskReg(value, AV_CTRL1, m_INPUT_VIDEO_MODE | m_DE_SIGNAL_SELECT, \
+		v_INPUT_VIDEO_MODE(vpara->input_mode) | EXTERNAL_DE)	
+	HDMIMskReg(value, VIDEO_CTRL1, m_VIDEO_OUTPUT_MODE | m_VIDEO_INPUT_DEPTH | m_VIDEO_INPUT_COLOR_MODE, \
+		v_VIDEO_OUTPUT_MODE(vpara->output_color) | v_VIDEO_INPUT_DEPTH(VIDEO_INPUT_DEPTH_8BIT) | vpara->input_color)
+	HDMIWrReg(DEEP_COLOR_MODE, 0x20);
+	// color space convert
+	rk30_hdmi_config_csc(vpara);
+	// Set HDMI Mode
+	HDMIWrReg(HDCP_CTRL, v_HDMI_DVI(vpara->output_mode));
+
+	// Set ext video
+	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
+	if(mode == NULL)
+	{
+		hdmi_err(hdmi->dev, "[%s] not found vic %d\n", __FUNCTION__, vpara->vic);
+		return -ENOENT;
+	}
+	hdmi->tmdsclk = mode->pixclock;
+
+	if( (vpara->vic == HDMI_720x480p_60Hz_4_3) || (vpara->vic == HDMI_720x480p_60Hz_16_9) )
+		value = v_VSYNC_OFFSET(6);
+	else
+		value = v_VSYNC_OFFSET(0);
+	value |= v_EXT_VIDEO_ENABLE(1) | v_INTERLACE(mode->vmode);
+	if(mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		value |= v_HSYNC_POLARITY(1);
+	if(mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		value |= v_VSYNC_POLARITY(1);
+	HDMIWrReg(EXT_VIDEO_PARA, value);
+	value = mode->left_margin + mode->xres + mode->right_margin + mode->hsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_HTOTAL_L, value & 0xFF);
+	HDMIWrReg(EXT_VIDEO_PARA_HTOTAL_H, (value >> 8) & 0xFF);
+	
+	value = mode->left_margin + mode->right_margin + mode->hsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_HBLANK_L, value & 0xFF);
+	HDMIWrReg(EXT_VIDEO_PARA_HBLANK_H, (value >> 8) & 0xFF);
+	
+	value = mode->left_margin + mode->hsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_HDELAY_L, value & 0xFF);
+	HDMIWrReg(EXT_VIDEO_PARA_HDELAY_H, (value >> 8) & 0xFF);
+	
+	value = mode->hsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_HSYNCWIDTH_L, value & 0xFF);
+	HDMIWrReg(EXT_VIDEO_PARA_HSYNCWIDTH_H, (value >> 8) & 0xFF);
+	
+	value = mode->upper_margin + mode->yres + mode->lower_margin + mode->vsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_VTOTAL_L, value & 0xFF);
+	HDMIWrReg(EXT_VIDEO_PARA_VTOTAL_H, (value >> 8) & 0xFF);
+	
+	value = mode->upper_margin + mode->vsync_len + mode->lower_margin;
+	HDMIWrReg(EXT_VIDEO_PARA_VBLANK_L, value & 0xFF);
+	
+	if(vpara->vic == HDMI_720x480p_60Hz_4_3 || vpara->vic == HDMI_720x480p_60Hz_16_9)
+		value = 42;
+	else
+		value = mode->upper_margin + mode->vsync_len;
+
+	HDMIWrReg(EXT_VIDEO_PARA_VDELAY, value & 0xFF);
+	
+	value = mode->vsync_len;
+	HDMIWrReg(EXT_VIDEO_PARA_VSYNCWIDTH, value & 0xFF);
+	
+	if(vpara->output_mode == OUTPUT_HDMI) {
+		rk30_hdmi_config_avi(vpara->vic, vpara->output_color);
+		hdmi_dbg(hdmi->dev, "[%s] sucess output HDMI.\n", __FUNCTION__);
+	}
+	else {
+		hdmi_dbg(hdmi->dev, "[%s] sucess output DVI.\n", __FUNCTION__);	
+	}
+	
+	rk30_hdmi_config_phy(vpara->vic);
+	rk30_hdmi_control_output(0);
+	return 0;
+}
+
+static void rk30_hdmi_config_aai(void)
+{
+	int i;
+	char info[SIZE_AUDIO_INFOFRAME];
+	
+	memset(info, 0, SIZE_AUDIO_INFOFRAME);
+	
+	info[0] = 0x84;
+	info[1] = 0x01;
+	info[2] = 0x0A;
+	
+	info[3] = info[0] + info[1] + info[2];	
+	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
+    	info[3] += info[i];
+    	
+	info[3] = 0x100 - info[3];
+	
+	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AAI);
+	for(i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
+		HDMIWrReg(CONTROL_PACKET_HB0 + i*4, info[i]);
+}
+
+int rk30_hdmi_config_audio(struct hdmi_audio *audio)
+{
+	int value, rate, N;
+	char word_length, channel;
+	
+	if(audio->channel < 3)
+		channel = I2S_CHANNEL_1_2;
+	else if(audio->channel < 5)
+		channel = I2S_CHANNEL_3_4;
+	else if(audio->channel < 7)
+		channel = I2S_CHANNEL_5_6;
+	else
+		channel = I2S_CHANNEL_7_8;
+	
+	switch(audio->rate)
+	{
+		case HDMI_AUDIO_FS_32000:
+			rate = AUDIO_32K;
+			N = N_32K;
+			break;
+		case HDMI_AUDIO_FS_44100:
+			rate = AUDIO_441K;
+			N = N_441K;
+			break;
+		case HDMI_AUDIO_FS_48000:
+			rate = AUDIO_48K;
+			N = N_48K;
+			break;
+		case HDMI_AUDIO_FS_88200:
+			rate = AUDIO_882K;
+			N = N_882K;
+			break;
+		case HDMI_AUDIO_FS_96000:
+			rate = AUDIO_96K;
+			N = N_96K;
+			break;
+		case HDMI_AUDIO_FS_176400:
+			rate = AUDIO_1764K;
+			N = N_1764K;
+			break;
+		case HDMI_AUDIO_FS_192000:
+			rate = AUDIO_192K;
+			N = N_192K;
+			break;
+		default:
+			hdmi_err(hdmi->dev, "[%s] not support such sample rate %d\n", __FUNCTION__, audio->rate);
+			return -ENOENT;
+	}
+//	switch(audio->word_length)
+//	{
+//		case HDMI_AUDIO_WORD_LENGTH_16bit:
+//			word_length = 0x02;
+//			break;
+//		case HDMI_AUDIO_WORD_LENGTH_20bit:
+//			word_length = 0x0a;
+//			break;
+//		case HDMI_AUDIO_WORD_LENGTH_24bit:
+//			word_length = 0x0b;
+//			break;
+//		default:
+//			hdmi_err(hdmi->dev, "[%s] not support such word length %d\n", __FUNCTION__, audio->word_length);
+//			return -ENOENT;
+//	}
+	//set_audio_if I2S
+	HDMIWrReg(AUDIO_CTRL1, 0x00); //internal CTS, disable down sample, i2s input, disable MCLK
+	HDMIWrReg(AUDIO_CTRL2, 0x40); 
+	HDMIWrReg(I2S_AUDIO_CTRL, v_I2S_MODE(I2S_MODE_STANDARD) | v_I2S_CHANNEL(channel) );	
+	HDMIWrReg(I2S_INPUT_SWAP, 0x00); //no swap
+	HDMIMskReg(value, AV_CTRL1, m_AUDIO_SAMPLE_RATE, v_AUDIO_SAMPLE_RATE(rate))	
+//	HDMIWrReg(SRC_NUM_AUDIO_LEN, word_length);
+		
+    //Set N value 6144, fs=48kHz
+    HDMIWrReg(N_1, N & 0xFF);
+    HDMIWrReg(N_2, (N >> 8) & 0xFF);
+    HDMIWrReg(LR_SWAP_N3, (N >> 16) & 0x0F); 
+    
+    rk30_hdmi_config_aai();
+    return 0;
+}
+
+static void rk30_hdmi_audio_reset(void)
+{
+	int value;
+	
+	HDMIMskReg(value, VIDEO_SETTING2, m_AUDIO_RESET, AUDIO_CAPTURE_RESET)
+	msleep(1);
+	HDMIMskReg(value, VIDEO_SETTING2, m_AUDIO_RESET, 0)
+}
+
+void rk30_hdmi_control_output(int enable)
+{
+	hdmi_dbg(hdmi->dev, "[%s] %d\n", __FUNCTION__, enable);
+	if(enable == 0) {
+		HDMIWrReg(VIDEO_SETTING2, 0x03);
+	}
+	else {
+		if(hdmi->pwr_mode == PWR_SAVE_MODE_B) {
+			//  Switch to power save mode_d
+			rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
+		}
+		if(hdmi->pwr_mode == PWR_SAVE_MODE_D) {
+			//  Switch to power save mode_e
+			rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_E);
+		}
+		HDMIWrReg(VIDEO_SETTING2, 0x00);
+		rk30_hdmi_audio_reset();
+	}
+}
+
+int rk30_hdmi_removed(void)
+{
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_E)
+	{
+		HDMIWrReg(VIDEO_SETTING2, 0x00);
+		rk30_hdmi_audio_reset();
+		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
+	}
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_D)
+		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_B && hdmi->state == HDMI_SLEEP)
+	{
+		HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS);
+		HDMIWrReg(INTR_MASK2, 0);
+		HDMIWrReg(INTR_MASK3, 0);
+		HDMIWrReg(INTR_MASK4, 0);
+		// Disable color space convertion
+		HDMIWrReg(AV_CTRL2, v_CSC_ENABLE(0));
+		HDMIWrReg(CSC_CONFIG1, v_CSC_MODE(CSC_MODE_AUTO) | v_CSC_BRSWAP_DIABLE(1));
+		if(hdmi->hdcp_power_off_cb)
+			hdmi->hdcp_power_off_cb();
+		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_A);
+	}
+	dev_printk(KERN_INFO , hdmi->dev , "Removed.\n");
+	return HDMI_ERROR_SUCESS;
+}
+
+
+irqreturn_t hdmi_irq(int irq, void *priv)
+{		
+	char interrupt1 = 0, interrupt2 = 0, interrupt3 = 0, interrupt4 = 0;
+	
+	if(hdmi->pwr_mode == PWR_SAVE_MODE_A)
+	{
+		HDMIWrReg(SYS_CTRL, 0x20);
+		hdmi->pwr_mode = PWR_SAVE_MODE_B;
+		
+		hdmi_dbg(hdmi->dev, "hdmi irq wake up\n");
+		// HDMI was inserted when system is sleeping, irq was triggered only once
+		// when wake up. So we need to check hotplug status.
+		if(HDMIRdReg(HPD_MENS_STA) & (m_HOTPLUG_STATUS | m_MSEN_STATUS)) {			
+			queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));
+		}
+	}
+	else
+	{
+		interrupt1 = HDMIRdReg(INTR_STATUS1);
+		interrupt2 = HDMIRdReg(INTR_STATUS2);
+		interrupt3 = HDMIRdReg(INTR_STATUS3);
+		interrupt4 = HDMIRdReg(INTR_STATUS4);
+		HDMIWrReg(INTR_STATUS1, interrupt1);
+		HDMIWrReg(INTR_STATUS2, interrupt2);
+		HDMIWrReg(INTR_STATUS3, interrupt3);
+		HDMIWrReg(INTR_STATUS4, interrupt4);
+#if 0
+		hdmi_dbg(hdmi->dev, "[%s] interrupt1 %02x interrupt2 %02x interrupt3 %02x interrupt4 %02x\n",\
+			 __FUNCTION__, interrupt1, interrupt2, interrupt3, interrupt4);
+#endif
+		if(interrupt1 & (m_INT_HOTPLUG | m_INT_MSENS))
+		{
+			if(hdmi->state == HDMI_SLEEP)
+				hdmi->state = WAIT_HOTPLUG;
+			interrupt1 &= ~(m_INT_HOTPLUG | m_INT_MSENS);
+			queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
+		}
+		else if(interrupt1 & (m_INT_EDID_READY | m_INT_EDID_ERR)) {
+			spin_lock(&hdmi->irq_lock);
+			edid_result = interrupt1;
+			spin_unlock(&hdmi->irq_lock);
+		}
+		else if(hdmi->state == HDMI_SLEEP) {
+			hdmi_dbg(hdmi->dev, "hdmi return to sleep mode\n");
+			HDMIWrReg(SYS_CTRL, 0x10);
+			hdmi->pwr_mode = PWR_SAVE_MODE_A;
+		}
+		if(interrupt2 && hdmi->hdcp_irq_cb)
+			hdmi->hdcp_irq_cb(interrupt2);
+	}
+	return IRQ_HANDLED;
+}
+
diff --git a/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.h b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.h
new file mode 100755
index 0000000..c42f061
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk30/rk30_hdmi_hw.h
@@ -0,0 +1,422 @@
+#ifndef __RK30_HDMI_HW_H__
+#define __RK30_HDMI_HW_H__
+
+/* HDMI_SYS_CONTROL */
+#define SYS_CTRL	0x0
+
+enum {
+	PWR_SAVE_MODE_A = 1,
+	PWR_SAVE_MODE_B = 2,
+	PWR_SAVE_MODE_D = 4,
+	PWR_SAVE_MODE_E = 8
+};
+#define m_PWR_SAVE_MODE		0xF0
+#define v_PWR_SAVE_MODE(n)	(n << 4)
+#define PLL_B_RESET			(1 << 3)
+
+#define N_32K 		0x1000
+#define N_441K 		0x1880
+#define N_882K 		0x3100
+#define N_1764K 	0x6200
+#define N_48K 		0x1800
+#define N_96K		0x3000
+#define N_192K 		0x6000
+
+#define LR_SWAP_N3			0x04
+#define N_2					0x08
+#define N_1					0x0c
+
+#define AUDIO_CTRL1			0x28
+#define AUDIO_CTRL2 		0x2c
+#define I2S_AUDIO_CTRL		0x30
+enum {
+	I2S_MODE_STANDARD = 0,
+	I2S_MODE_RIGHT_JUSTIFIED,
+	I2S_MODE_LEFT_JUSTIFIED
+};
+#define v_I2S_MODE(n)		n
+enum {
+	I2S_CHANNEL_1_2 = 1,
+	I2S_CHANNEL_3_4 = 3,
+	I2S_CHANNEL_5_6 = 7,
+	I2S_CHANNEL_7_8 = 0xf
+};
+#define v_I2S_CHANNEL(n)	( (n) << 2 )
+
+#define I2S_INPUT_SWAP		0x40
+
+#define SRC_NUM_AUDIO_LEN	0x50
+
+/* HDMI_AV_CTRL1*/
+#define AV_CTRL1	0x54
+enum {
+	AUDIO_32K	= 0x3,
+	AUDIO_441K	= 0x0,
+	AUDIO_48K	= 0x2,
+	AUDIO_882K	= 0x8,
+	AUDIO_96K	= 0xa,
+	AUDIO_1764K	= 0xc,
+	AUDIO_192K	= 0xe,
+};
+#define m_AUDIO_SAMPLE_RATE		0xF0
+#define v_AUDIO_SAMPLE_RATE(n)	(n << 4)
+#define m_INPUT_VIDEO_MODE			(7 << 1)
+#define v_INPUT_VIDEO_MODE(n)		(n << 1)
+enum {
+	INTERNAL_DE = 0,
+	EXTERNAL_DE
+};
+#define m_DE_SIGNAL_SELECT			(1 << 0)
+
+/* HDMI_AV_CTRL2 */
+#define AV_CTRL2	0xec
+#define m_CSC_ENABLE				(1 << 0)
+#define v_CSC_ENABLE(n)				(n)
+
+/* HDMI_VIDEO_CTRL1 */
+#define VIDEO_CTRL1	0x58
+
+#define m_VIDEO_OUTPUT_MODE		(0x3 << 6)
+#define v_VIDEO_OUTPUT_MODE(n)	(n << 6)
+enum {
+	VIDEO_INPUT_DEPTH_12BIT = 0,
+	VIDEO_INPUT_DEPTH_10BIT = 0x1,
+	VIDEO_INPUT_DEPTH_8BIT = 0x3
+};
+#define m_VIDEO_INPUT_DEPTH		(3 << 4)
+#define v_VIDEO_INPUT_DEPTH(n)	(n << 4)
+enum {
+	VIDEO_EMBEDDED_SYNC_LOCATION_0 = 0,
+	VIDEO_EMBEDDED_SYNC_LOCATION_1,
+	VIDEO_EMBEDDED_SYNC_LOCATION_2
+};
+#define m_VIDEO_EMBEDDED_SYNC_LOCATION		(3 << 2)
+#define VIDEO_EMBEDDED_SYNC_LOCATION(n)		(n << 2)
+#define m_VIDEO_INPUT_COLOR_MODE			(1 << 0)
+
+/* DEEP_COLOR_MODE */
+#define DEEP_COLOR_MODE	0x5c
+enum{
+	TMDS_CLOCK_MODE_8BIT = 0,
+	TMDS_CLOKK_MODE_10BIT,
+	TMDS_CLOKK_MODE_12BIT
+};
+#define TMDS_CLOCK_MODE_MASK	0x3 << 6
+#define TMDS_CLOCK_MODE(n)		(n) << 6
+
+/* VIDEO_CTRL2 */
+#define VIDEO_SETTING2	0x114
+#define m_UNMUTE					(1 << 7)
+#define m_MUTE						(1 << 6)
+#define m_AUDIO_RESET				(1 << 2)
+#define m_NOT_SEND_AUDIO			(1 << 1)
+#define m_NOT_SEND_VIDEO			(1 << 0)
+#define AV_UNMUTE					(1 << 7)		// Unmute video and audio, send normal video and audio data
+#define AV_MUTE						(1 << 6)		// Mute video and audio, send black video data and silent audio data
+#define AUDIO_CAPTURE_RESET			(1 << 2)		// Reset audio process logic, only available in pwr_e mode.
+#define NOT_SEND_AUDIO				(1 << 1)		// Send silent audio data
+#define NOT_SEND_VIDEO				(1 << 0)		// Send black video data
+
+/* Color Space Convertion Parameter*/
+#define CSC_PARA_C0_H	0x60
+#define CSC_PARA_C0_L	0x64
+#define CSC_PARA_C1_H	0x68
+#define CSC_PARA_C1_L	0x6c
+#define CSC_PARA_C2_H	0x70
+#define CSC_PARA_C2_L	0x74
+#define CSC_PARA_C3_H	0x78
+#define CSC_PARA_C3_L	0x7c
+#define CSC_PARA_C4_H	0x80
+#define CSC_PARA_C4_L	0x84
+#define CSC_PARA_C5_H	0x88
+#define CSC_PARA_C5_L	0x8c
+#define CSC_PARA_C6_H	0x90
+#define CSC_PARA_C6_L	0x94
+#define CSC_PARA_C7_H	0x98
+#define CSC_PARA_C7_L	0x9c
+#define CSC_PARA_C8_H	0xa0
+#define CSC_PARA_C8_L	0xa4
+#define CSC_PARA_C9_H	0xa8
+#define CSC_PARA_C9_L	0xac
+#define CSC_PARA_C10_H	0xac
+#define CSC_PARA_C10_L	0xb4
+#define CSC_PARA_C11_H	0xb8
+#define CSC_PARA_C11_L	0xbc
+
+#define CSC_CONFIG1		0x34c
+#define m_CSC_MODE			(1 << 7)
+#define m_CSC_COEF_MODE 	(0xF << 3)	//Only used in auto csc mode
+#define m_CSC_STATUS		(1 << 2)
+#define m_CSC_VID_SELECT	(1 << 1)
+#define m_CSC_BRSWAP_DIABLE	(1)
+
+enum {
+	CSC_MODE_MANUAL	= 0,
+	CSC_MODE_AUTO
+};
+#define v_CSC_MODE(n)			(n << 7)
+enum {
+	COE_SDTV_LIMITED_RANGE = 0x08,
+	COE_SDTV_FULL_RANGE = 0x04,
+	COE_HDTV_60Hz = 0x2,
+	COE_HDTV_50Hz = 0x1
+};
+#define v_CSC_COE_MODE(n)		(n << 3)
+enum {
+	CSC_INPUT_VID_5_19 = 0,
+	CSC_INPUT_VID_28_29
+};
+#define v_CSC_VID_SELECT(n)		(n << 1)
+#define v_CSC_BRSWAP_DIABLE(n)	(n)
+
+/* CONTROL_PACKET_BUF_INDEX */
+#define CONTROL_PACKET_BUF_INDEX	0x17c
+enum {
+	INFOFRAME_AVI = 0x06,
+	INFOFRAME_AAI = 0x08
+};
+#define CONTROL_PACKET_HB0			0x180
+#define CONTROL_PACKET_HB1			0x184
+#define CONTROL_PACKET_HB2			0x188
+#define CONTROL_PACKET_PB_ADDR		0x18c
+#define SIZE_AVI_INFOFRAME			0x11	// 17 bytes
+#define SIZE_AUDIO_INFOFRAME		0x0F	// 15 bytes
+enum {
+	AVI_COLOR_MODE_RGB = 0,
+	AVI_COLOR_MODE_YCBCR422,
+	AVI_COLOR_MODE_YCBCR444
+};
+enum {
+	AVI_COLORIMETRY_NO_DATA = 0,
+	AVI_COLORIMETRY_SMPTE_170M,
+	AVI_COLORIMETRY_ITU709,
+	AVI_COLORIMETRY_EXTENDED
+};
+enum {
+	AVI_CODED_FRAME_ASPECT_NO_DATA,
+	AVI_CODED_FRAME_ASPECT_4_3,
+	AVI_CODED_FRAME_ASPECT_16_9
+};
+enum {
+	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
+	ACTIVE_ASPECT_RATE_4_3,
+	ACTIVE_ASPECT_RATE_16_9,
+	ACTIVE_ASPECT_RATE_14_9
+};
+
+/* External Video Parameter Setting*/
+#define EXT_VIDEO_PARA			0xC0
+#define m_VSYNC_OFFSET			(0xF << 4)
+#define m_VSYNC_POLARITY		(1 << 3)
+#define m_HSYNC_POLARITY		(1 << 2)
+#define m_INTERLACE				(1 << 1)
+#define m_EXT_VIDEO_ENABLE		(1 << 0)
+
+#define v_VSYNC_OFFSET(n)		(n << 4)
+#define v_VSYNC_POLARITY(n)		(n << 3)
+#define v_HSYNC_POLARITY(n)		(n << 2)
+#define v_INTERLACE(n)			(n << 1)
+#define v_EXT_VIDEO_ENABLE(n)	(n << 0) 
+
+#define EXT_VIDEO_PARA_HTOTAL_L		0xC4
+#define EXT_VIDEO_PARA_HTOTAL_H		0xC8
+#define EXT_VIDEO_PARA_HBLANK_L		0xCC
+#define EXT_VIDEO_PARA_HBLANK_H		0xD0
+#define EXT_VIDEO_PARA_HDELAY_L		0xD4
+#define EXT_VIDEO_PARA_HDELAY_H		0xD8
+#define EXT_VIDEO_PARA_HSYNCWIDTH_L	0xDC
+#define EXT_VIDEO_PARA_HSYNCWIDTH_H	0xE0
+
+#define EXT_VIDEO_PARA_VTOTAL_L		0xE4
+#define EXT_VIDEO_PARA_VTOTAL_H		0xE8
+#define EXT_VIDEO_PARA_VBLANK_L		0xF4
+#define EXT_VIDEO_PARA_VDELAY		0xF8
+#define EXT_VIDEO_PARA_VSYNCWIDTH	0xFC
+
+#define PHY_PLL_SPEED				0x158
+	#define v_TEST_EN(n)			(n << 6)
+	#define v_PLLA_BYPASS(n)		(n << 4)
+	#define v_PLLB_SPEED(n)			(n << 2)
+	#define v_PLLA_SPEED(n)			(n)
+	enum {
+		PLL_SPEED_LOWEST = 0,
+		PLL_SPEED_MIDLOW,
+		PLL_SPEED_MIDHIGH,
+		PLL_SPEED_HIGHEST
+	};
+
+#define PHY_PLL_17					0x15c		// PLL A & B config bit 17
+	#define v_PLLA_BIT17(n)			(n << 2)
+	#define v_PLLB_BIT17(n)			(n << 1)
+	
+#define PHY_BGR						0x160
+	#define v_BGR_DISCONNECT(n)		(n << 7)
+	#define v_BGR_V_OFFSET(n)		(n << 4)
+	#define v_BGR_I_OFFSET(n)		(n)
+
+#define PHY_PLLA_1					0x164
+#define PHY_PLLA_2					0x168
+#define PHY_PLLB_1					0x16c
+#define PHY_PLLB_2					0x170
+
+#define PHY_DRIVER_PREEMPHASIS		0x174
+	#define v_TMDS_SWING(n)			(n << 4)
+	#define v_PRE_EMPHASIS(n)		(n)
+	
+#define PHY_PLL_16_AML				0x178		// PLL A & B config bit 16 and AML control
+	#define v_PLLA_BIT16(n)			(n << 5)
+	#define v_PLLB_BIT16(n)			(n << 4)
+	#define v_AML(n)				(n)
+
+/* Interrupt Setting */
+#define INTR_MASK1					0x248
+#define INTR_STATUS1				0x250
+	#define m_INT_HOTPLUG				(1 << 7)
+	#define m_INT_MSENS					(1 << 6)
+	#define m_INT_VSYNC					(1 << 5)
+	#define m_INT_AUDIO_FIFO_FULL		(1 << 4)
+	#define m_INT_EDID_READY			(1 << 2)
+	#define m_INT_EDID_ERR				(1 << 1)
+#define INTR_MASK2					0x24c
+#define INTR_STATUS2				0x254
+	#define m_INT_HDCP_ERR				(1 << 7)	// HDCP error detected
+	#define m_INT_BKSV_RPRDY			(1 << 6)	// BKSV list ready from repeater
+	#define m_INT_BKSV_RCRDY			(1 << 5)	// BKSV list ready from receiver
+	#define m_INT_AUTH_DONE				(1 << 4)	// HDCP authentication done
+	#define m_INT_AUTH_READY			(1 << 3)	// HDCP authentication ready
+#define INTR_MASK3					0x258
+#define INTR_STATUS3				0x260
+
+#define INTR_MASK4					0x25c
+#define INTR_STATUS4				0x264
+
+#define DDC_READ_FIFO_ADDR			0x200
+#define DDC_BUS_FREQ_L				0x204
+#define DDC_BUS_FREQ_H				0x208
+#define DDC_BUS_CTRL				0x2dc
+#define DDC_I2C_LEN					0x278
+#define DDC_I2C_OFFSET				0x280
+#define DDC_I2C_CTRL				0x284
+#define DDC_I2C_READ_BUF0			0x288
+#define DDC_I2C_READ_BUF1			0x28c
+#define DDC_I2C_READ_BUF2			0x290
+#define DDC_I2C_READ_BUF3			0x294
+#define DDC_I2C_WRITE_BUF0			0x298
+#define DDC_I2C_WRITE_BUF1			0x29c
+#define DDC_I2C_WRITE_BUF2			0x2a0
+#define DDC_I2C_WRITE_BUF3			0x2a4
+#define DDC_I2C_WRITE_BUF4			0x2ac
+#define DDC_I2C_WRITE_BUF5			0x2b0
+#define DDC_I2C_WRITE_BUF6			0x2b4
+
+#define EDID_SEGMENT_POINTER		0x310
+#define EDID_WORD_ADDR				0x314
+#define EDID_FIFO_ADDR				0x318
+
+#define HPD_MENS_STA				0x37c
+#define m_HOTPLUG_STATUS			(1 << 7)
+#define m_MSEN_STATUS				(1 << 6)
+
+/* HDCP_CTRL */
+#define HDCP_CTRL		0x2bc
+	enum {
+		OUTPUT_DVI = 0,
+		OUTPUT_HDMI
+	};
+	#define m_HDCP_AUTH_START			(1 << 7)	// start hdcp
+	#define m_HDCP_BKSV_PASS			(1 << 6)	// bksv valid
+	#define m_HDCP_BKSV_FAILED			(1 << 5)	// bksv invalid
+	#define m_HDCP_FRAMED_ENCRYPED		(1 << 4)
+	#define m_HDCP_AUTH_STOP			(1 << 3)	// stop hdcp
+	#define m_HDCP_ADV_CIPHER			(1 << 2)	// advanced cipher mode
+	#define m_HDMI_DVI					(1 << 1)
+	#define m_HDCP_RESET				(1 << 0)	// reset hdcp
+	#define v_HDCP_AUTH_START(n)		(n << 7)
+	#define v_HDCP_BKSV_PASS(n)			(n << 6)
+	#define v_HDCP_BKSV_FAILED(n)		(n << 5)
+	#define v_HDCP_FRAMED_ENCRYPED(n)	(n << 4)
+	#define v_HDCP_AUTH_STOP(n)			(n << 3)
+	#define v_HDCP_ADV_CIPHER(n)		(n << 2)
+	#define v_HDMI_DVI(n)				(n << 1)
+	#define v_HDCP_RESET(n)				(n << 0)
+#define HDCP_CTRL2		0x340
+
+/* HDCP Key Memory Access Control */
+#define HDCP_KEY_ACCESS_CTRL1	0x338
+#define HDCP_KEY_ACCESS_CTRL2	0x33c
+	#define m_LOAD_FACSIMILE_HDCP_KEY	(1 << 1)
+	#define m_LOAD_HDCP_KEY				(1 << 0)
+/* HDCP Key Memory Control */
+#define HDCP_KEY_MEM_CTRL	0x348
+	#define m_USE_KEY1		(1 << 6)
+	#define m_USE_KEY2		(1 << 5)
+	#define m_LOAD_AKSV		(1 << 4)
+	#define m_KSV_SELECTED	(1 << 3)
+	#define m_KSV_VALID		(1 << 2)
+	#define m_KEY_VALID		(1 << 1)
+	#define m_KEY_READY		(1 << 0)
+	#define v_USE_KEY1(n)	(n << 6)
+	#define v_USE_KEY2(n)	(n << 5)
+	#define v_LOAD_AKSV(n)	(n << 4)
+
+/* HDCP B device capacity */
+#define HDCP_BCAPS				0x2f8
+	#define m_HDMI_RECEIVED			(1 << 7) //If HDCP receiver support HDMI, this bit must be 1.
+	#define m_REPEATER				(1 << 6)
+	#define m_KSV_FIFO_READY		(1 << 5)
+	#define m_DDC_FAST				(1 << 4)
+	#define m_1_1_FEATURE			(1 << 1)
+	#define m_FAST_REAUTHENTICATION	(1 << 0) //For HDMI, this function is supported whether this bit is enabled or not.
+
+/* HDCP KSV Value */
+#define HDCP_KSV_BYTE0			0x2fc
+#define HDCP_KSV_BYTE1			0x300
+#define HDCP_KSV_BYTE2			0x304
+#define HDCP_KSV_BYTE3			0x308
+#define HDCP_KSV_BYTE4			0x30c
+
+/* HDCP error status */
+#define HDCP_ERROR				0x320
+
+/* HDCP 100 ms timer */
+#define HDCP_TIMER_100MS		0x324
+/* HDCP 5s timer */
+#define HDCP_TIMER_5S			0x328
+
+/* HDCP Key ram address */
+#define HDCP_RAM_KEY_KSV1		0x400
+#define HDCP_RAM_KEY_KSV2		0x407
+#define HDCP_RAM_KEY_PRIVATE	0x40e
+#define HDCP_KEY_LENGTH			0x13C
+
+
+#define HDCP_ENABLE_HW_AUTH		// Enable hardware authentication mode	
+#define HDMI_INTERANL_CLK_DIV	0x19
+
+#define HDMIRdReg(addr)						__raw_readl(hdmi->regbase + addr)
+#define HDMIWrReg(addr, val)        		__raw_writel((val), hdmi->regbase + addr);
+#define HDMIMskReg(temp, addr, msk, val)	\
+	temp = __raw_readl(hdmi->regbase + addr) & (0xFF - (msk)) ; \
+	__raw_writel(temp | ( (val) & (msk) ),  hdmi->regbase + addr); 
+
+
+
+/* Color Space Convertion Mode */
+enum {
+	CSC_RGB_0_255_TO_ITU601_16_235 = 0,	//RGB 0-255 input to YCbCr 16-235 output according BT601
+	CSC_RGB_0_255_TO_ITU709_16_235,		//RGB 0-255 input to YCbCr 16-235 output accroding BT709
+	CSC_ITU601_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT601
+	CSC_ITU709_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT709
+	CSC_ITU601_16_235_TO_RGB_0_255,		//YCbCr 16-235 input to RGB 0-255 output according BT601
+	CSC_ITU709_16_235_TO_RGB_0_255		//YCbCr 16-235 input to RGB 0-255 output according BT709
+};
+
+extern int rk30_hdmi_initial(void);
+extern int rk30_hdmi_detect_hotplug(void);
+extern int rk30_hdmi_read_edid(int block, unsigned char *buff);
+extern int rk30_hdmi_removed(void);
+extern int rk30_hdmi_config_video(struct hdmi_video_para *vpara);
+extern int rk30_hdmi_config_audio(struct hdmi_audio *audio);
+extern void rk30_hdmi_control_output(int enable);
+
+#endif
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/Kconfig b/drivers/video/rockchip/hdmi/chips/rk610/Kconfig
new file mode 100755
index 0000000..389f127
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/Kconfig
@@ -0,0 +1,14 @@
+config HDCP_RK610
+	bool "RK610 HDCP support"
+        depends on HDMI_RK610
+        default n
+	help
+	  HDCP Interface. This adds the High Definition Content Protection Interface.
+	  See http://www.digital-cp.com/ for HDCP specification.
+
+config HDCP_RK610_DEBUG
+	bool "RK610 HDCP Debugging"
+        depends on HDCP_RK610
+        default n
+	help
+	  Enableds verbose debugging the the HDCP drivers
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/Makefile b/drivers/video/rockchip/hdmi/chips/rk610/Makefile
new file mode 100755
index 0000000..683fb21
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/Makefile
@@ -0,0 +1,6 @@
+ccflags-$(CONFIG_RK_HDMI_DEBUG) = -DDEBUG -DHDMI_DEBUG
+ccflags-$(CONFIG_HDCP_RK610_DEBUG) = -DHDCP_DEBUG
+
+obj-$(CONFIG_HDMI_RK610)		+= rk610_hdmi_hw.o rk610_hdmi.o
+obj-$(CONFIG_HDCP_RK610)  		+= rk610_hdmi_hdcp.o rk610_hdcp.o
+
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.c b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.c
new file mode 100755
index 0000000..61207db
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.c
@@ -0,0 +1,563 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/workqueue.h>
+#include <linux/firmware.h>
+#include "rk610_hdmi.h"
+#include "rk610_hdcp.h"
+
+struct hdcp *hdcp = NULL;
+
+static void hdcp_work_queue(struct work_struct *work);
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_submit_work
+ *-----------------------------------------------------------------------------
+ */
+static struct delayed_work *hdcp_submit_work(int event, int delay)
+{
+	struct hdcp_delayed_work *work;
+
+	DBG("%s event %04x delay %d", __FUNCTION__, event, delay);
+	
+	work = kmalloc(sizeof(struct hdcp_delayed_work), GFP_ATOMIC);
+
+	if (work) {
+		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
+		work->event = event;
+		queue_delayed_work(hdcp->workqueue,
+				   &work->work,
+				   msecs_to_jiffies(delay));
+	} else {
+		printk(KERN_WARNING "HDCP: Cannot allocate memory to "
+				    "create work\n");
+		return 0;
+	}
+
+	return &work->work;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_cancel_work
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_cancel_work(struct delayed_work **work)
+{
+	int ret = 0;
+
+	if (*work) {
+		ret = cancel_delayed_work(*work);
+		if (ret != 1) {
+			ret = cancel_work_sync(&((*work)->work));
+			printk(KERN_INFO "Canceling work failed - "
+					 "cancel_work_sync done %d\n", ret);
+		}
+		kfree(*work);
+		*work = 0;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_failure
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_failure(void)
+{
+	if (hdcp->hdmi_state == HDMI_STOPPED) {
+		return;
+	}
+
+	rk610_hdcp_disable();
+	rk610_hdmi_sys_enalbe_output(false);
+	
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	
+	if (hdcp->retry_cnt && (hdcp->hdmi_state != HDMI_STOPPED)) {
+		if (hdcp->retry_cnt < HDCP_INFINITE_REAUTH) {
+			hdcp->retry_cnt--;
+			printk(KERN_INFO "HDCP: authentication failed - "
+					 "retrying, attempts=%d\n",
+							hdcp->retry_cnt);
+		} else
+			printk(KERN_INFO "HDCP: authentication failed - "
+					 "retrying\n");
+
+		hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+
+		hdcp->pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
+							 HDCP_REAUTH_DELAY);
+	} else {
+		printk(KERN_INFO "HDCP: authentication failed - "
+				 "HDCP disabled\n");
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+	}
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_start_authentication
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_start_authentication(void)
+{
+	int status = HDCP_OK;
+
+	hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
+
+	DBG("HDCP: authentication start");
+
+	status = rk610_hdcp_start_authentication();
+
+	if (status != HDCP_OK) {
+		DBG("HDCP: authentication failed");
+		hdcp_wq_authentication_failure();
+	} else {
+		hdcp->hdcp_state = HDCP_WAIT_KSV_LIST;
+//		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_check_bksv
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_check_bksv(void)
+{
+	int status = HDCP_OK;
+
+	DBG("Check BKSV start");
+	
+	status = rk610_hdcp_check_bksv();
+
+	if (status != HDCP_OK) {
+		printk(KERN_INFO "HDCP: Check BKSV failed");
+		hdcp->retry_cnt = 0;
+		hdcp_wq_authentication_failure();
+	}
+	else {
+		DBG("HDCP: Check BKSV successful");
+
+		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
+
+		/* Restore retry counter */
+		if(hdcp->retry_times == 0)
+			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+		else
+			hdcp->retry_cnt = hdcp->retry_times;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_authentication_sucess
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_authentication_sucess(void)
+{
+	rk610_hdmi_sys_enalbe_output(true);
+	printk(KERN_INFO "HDCP: authentication pass");
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_wq_disable
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_wq_disable(int event)
+{
+	printk(KERN_INFO "HDCP: disabled");
+
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	rk610_hdcp_disable();
+	if(event == HDCP_DISABLE_CTL) {
+		hdcp->hdcp_state = HDCP_DISABLED;
+		if(hdcp->hdmi_state == HDMI_STARTED)
+			rk610_hdmi_sys_enalbe_output(true);
+	}
+	else if(event == HDCP_STOP_FRAME_EVENT)
+		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_work_queue
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_work_queue(struct work_struct *work)
+{
+	struct hdcp_delayed_work *hdcp_w =
+		container_of(work, struct hdcp_delayed_work, work.work);
+	int event = hdcp_w->event;
+
+	mutex_lock(&hdcp->lock);
+	
+	DBG("hdcp_work_queue() - START - %u hdmi=%d hdcp=%d evt= %x %d",
+		jiffies_to_msecs(jiffies),
+		hdcp->hdmi_state,
+		hdcp->hdcp_state,
+		(event & 0xFF00) >> 8,
+		event & 0xFF);
+	
+	if(event == HDCP_STOP_FRAME_EVENT) {
+		hdcp->hdmi_state = HDMI_STOPPED;
+	}
+	
+	if (event == HDCP_DISABLE_CTL || event == HDCP_STOP_FRAME_EVENT) {
+		hdcp_wq_disable(event);
+	}
+	
+	if (event & HDCP_WORKQUEUE_SRC)
+		hdcp->pending_wq_event = 0;
+	
+	/* First handle HDMI state */
+	if (event == HDCP_START_FRAME_EVENT) {
+		hdcp->pending_start = 0;
+		hdcp->hdmi_state = HDMI_STARTED;
+	}
+	
+	/**********************/
+	/* HDCP state machine */
+	/**********************/
+	switch (hdcp->hdcp_state) {
+		case HDCP_DISABLED:
+			/* HDCP enable control or re-authentication event */
+			if (event == HDCP_ENABLE_CTL) {
+				if(hdcp->retry_times == 0)
+					hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
+				else
+					hdcp->retry_cnt = hdcp->retry_times;
+				if (hdcp->hdmi_state == HDMI_STARTED)
+					hdcp_wq_start_authentication();
+				else
+					hdcp->hdcp_state = HDCP_ENABLE_PENDING;
+			}
+			break;
+		
+		case HDCP_ENABLE_PENDING:
+			/* HDMI start frame event */
+			if (event == HDCP_START_FRAME_EVENT)
+				hdcp_wq_start_authentication();
+
+			break;
+		
+		case HDCP_AUTHENTICATION_START:
+			/* Re-authentication */
+			if (event == HDCP_AUTH_REATT_EVENT)
+				hdcp_wq_start_authentication();
+	
+			break;
+		
+		case HDCP_WAIT_KSV_LIST:
+			/* KSV failure */
+			if (event == HDCP_FAIL_EVENT) {
+				printk(KERN_INFO "HDCP: KSV switch failure\n");
+	
+				hdcp_wq_authentication_failure();
+			}
+			/* KSV list ready event */
+			else if (event == HDCP_KSV_LIST_RDY_EVENT)
+				hdcp_wq_check_bksv();
+			break;
+		
+		case HDCP_LINK_INTEGRITY_CHECK:
+			/* Ri failure */
+			if (event == HDCP_FAIL_EVENT) {
+				printk(KERN_INFO "HDCP: Ri check failure\n");
+				hdcp_wq_authentication_failure();
+			}
+			else if(event == HDCP_AUTH_PASS_EVENT)
+				hdcp_wq_authentication_sucess();
+			break;
+	
+		default:
+			printk(KERN_WARNING "HDCP: error - unknow HDCP state\n");
+			break;
+	}
+	
+	kfree(hdcp_w);
+	if(event == HDCP_STOP_FRAME_EVENT)
+		complete(&hdcp->complete);
+		
+	mutex_unlock(&hdcp->lock);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_start_frame_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_start_frame_cb(void)
+{
+	DBG("hdcp_start_frame_cb()");
+
+	/* Cancel any pending work */
+	if (hdcp->pending_start)
+		hdcp_cancel_work(&hdcp->pending_start);
+	if (hdcp->pending_wq_event)
+		hdcp_cancel_work(&hdcp->pending_wq_event);
+
+	hdcp->pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
+							HDCP_ENABLE_DELAY);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_irq_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_irq_cb(int status)
+{
+	char interrupt1;
+	char interrupt2;
+	
+	rk610_hdcp_interrupt(&interrupt1, &interrupt2);
+	DBG("%s 0x%02x 0x%02x", __FUNCTION__, interrupt1, interrupt2);
+	if(interrupt1 & m_INT_HDCP_ERR)
+	{
+		if( (hdcp->hdcp_state != HDCP_DISABLED) &&
+			(hdcp->hdcp_state != HDCP_ENABLE_PENDING) )
+		{	
+			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
+		}
+	}
+	else if(interrupt1 & (m_INT_BKSV_READY | m_INT_BKSV_UPDATE))
+		hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
+	else if(interrupt1 & m_INT_AUTH_SUCCESS)
+		hdcp_submit_work(HDCP_AUTH_PASS_EVENT, 0);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_on_cb
+ *-----------------------------------------------------------------------------
+ */
+static int hdcp_power_on_cb(void)
+{
+	DBG("%s", __FUNCTION__);
+//	return rk610_hdcp_load_key2mem(hdcp->keys);
+	return HDCP_OK;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function: hdcp_power_off_cb
+ *-----------------------------------------------------------------------------
+ */
+static void hdcp_power_off_cb(void)
+{
+	DBG("%s", __FUNCTION__);
+	if(!hdcp->enable)
+		return;
+	
+	hdcp_cancel_work(&hdcp->pending_start);
+	hdcp_cancel_work(&hdcp->pending_wq_event);
+	init_completion(&hdcp->complete);
+	/* Post event to workqueue */
+	if (hdcp_submit_work(HDCP_STOP_FRAME_EVENT, 0))	
+		wait_for_completion_interruptible_timeout(&hdcp->complete,
+							msecs_to_jiffies(5000));
+}
+
+// Load HDCP key to external HDCP memory
+static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
+{
+	if (!fw) {
+		pr_err("HDCP: failed to load keys\n");
+		return;
+	}
+	
+	if(fw->size < HDCP_KEY_SIZE) {
+		pr_err("HDCP: firmware wrong size %d\n", fw->size);
+		return;
+	}
+	
+	hdcp->keys =  kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
+	if(hdcp->keys == NULL) {
+		pr_err("HDCP: can't allocated space for keys\n");
+		return;
+	}
+	
+	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
+	
+	printk(KERN_INFO "HDCP: load hdcp key success\n");
+
+	if(fw->size > HDCP_KEY_SIZE) {
+		DBG("%s invalid key size %d", __FUNCTION__, fw->size - HDCP_KEY_SIZE);
+		if((fw->size - HDCP_KEY_SIZE) % 5) {
+			pr_err("HDCP: failed to load invalid keys\n");
+			return;
+		}
+		hdcp->invalidkeys = kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
+		if(hdcp->invalidkeys == NULL) {
+			pr_err("HDCP: can't allocated space for invalid keys\n");
+			return;
+		}
+		memcpy(hdcp->invalidkeys, fw->data + HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
+		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE)/5;
+		printk(KERN_INFO "HDCP: loaded hdcp invalid key success\n");
+	}
+}
+
+static ssize_t hdcp_enable_read(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	int enable = 0;
+	
+	if(hdcp)
+		enable = hdcp->enable;
+		
+	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
+}
+
+static ssize_t hdcp_enable_write(struct device *device,
+			   struct device_attribute *attr, const char *buf, size_t count)
+{
+	int enable;
+
+	if(hdcp == NULL)
+		return -EINVAL;
+	
+	sscanf(buf, "%d", &enable);
+	if(hdcp->enable != enable)
+	{
+		/* Post event to workqueue */
+		if(enable) {
+			if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
+				return -EFAULT;
+		}
+		else {
+			hdcp_cancel_work(&hdcp->pending_start);
+			hdcp_cancel_work(&hdcp->pending_wq_event);
+		
+			/* Post event to workqueue */
+			if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
+				return -EFAULT;
+		}
+		hdcp->enable = 	enable;
+	}
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR, hdcp_enable_read, hdcp_enable_write);
+
+static ssize_t hdcp_trytimes_read(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	int trytimes = 0;
+	
+	if(hdcp)
+		trytimes = hdcp->retry_times;
+		
+	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
+}
+
+static ssize_t hdcp_trytimes_wrtie(struct device *device,
+			   struct device_attribute *attr, const char *buf, size_t count)
+{
+	int trytimes;
+
+	if(hdcp == NULL)
+		return -EINVAL;
+	
+	sscanf(buf, "%d", &trytimes);
+	if(hdcp->retry_times != trytimes)
+		hdcp->retry_times = trytimes;
+	
+	return count;
+}
+
+
+static DEVICE_ATTR(trytimes, S_IRUGO|S_IWUSR, hdcp_trytimes_read, hdcp_trytimes_wrtie);
+
+
+static struct miscdevice mdev;
+
+static int __init rk610_hdcp_init(void)
+{
+	int ret;
+	
+	DBG("[%s] %u", __FUNCTION__, jiffies_to_msecs(jiffies));
+	
+	hdcp = kmalloc(sizeof(struct hdcp), GFP_KERNEL);
+	if(!hdcp)
+	{
+    	printk(KERN_ERR ">>HDCP: kmalloc fail!");
+    	ret = -ENOMEM;
+    	goto error0; 
+	}
+	memset(hdcp, 0, sizeof(struct hdcp));
+	mutex_init(&hdcp->lock);
+	
+	mdev.minor = MISC_DYNAMIC_MINOR;
+	mdev.name = "hdcp";
+	mdev.mode = 0666;
+	if (misc_register(&mdev)) {
+		printk(KERN_ERR "HDCP: Could not add character driver\n");
+		ret = HDMI_ERROR_FALSE;
+		goto error1;
+	}
+	ret = device_create_file(mdev.this_device, &dev_attr_enable);
+    if(ret)
+    {
+        printk(KERN_ERR "HDCP: Could not add sys file enable\n");
+        ret = -EINVAL;
+        goto error2;
+    }
+    
+    ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
+    if(ret)
+    {
+        printk(KERN_ERR "HDCP: Could not add sys file trytimes\n");
+        ret = -EINVAL;
+        goto error3;
+    }
+    
+    hdcp->workqueue = create_singlethread_workqueue("hdcp");
+	if (hdcp->workqueue == NULL) {
+		printk(KERN_ERR "HDCP,: create workqueue failed.\n");
+		goto error4;
+	}
+    
+    
+    ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
+			      "hdcp.keys", mdev.this_device, GFP_KERNEL,
+			      hdcp, hdcp_load_keys_cb);
+	if (ret < 0) {
+		printk(KERN_ERR "HDCP: request_firmware_nowait failed: %d\n", ret);
+		goto error5;
+	}
+	
+	rk610_hdmi_register_hdcp_callbacks(	hdcp_start_frame_cb,
+										hdcp_irq_cb,
+										hdcp_power_on_cb,
+										hdcp_power_off_cb);
+										
+	DBG("%s success %u", __FUNCTION__, jiffies_to_msecs(jiffies));
+	return 0;
+	
+error5:
+	destroy_workqueue(hdcp->workqueue);
+error4:
+	device_remove_file(mdev.this_device, &dev_attr_trytimes);
+error3:
+	device_remove_file(mdev.this_device, &dev_attr_enable);
+error2:
+	misc_deregister(&mdev);
+error1:
+	if(hdcp->keys)
+		kfree(hdcp->keys);
+	if(hdcp->invalidkeys)
+		kfree(hdcp->invalidkeys);
+	kfree(hdcp);
+error0:
+	return ret;
+}
+
+static void __exit rk610_hdcp_exit(void)
+{
+	device_remove_file(mdev.this_device, &dev_attr_enable);
+	misc_deregister(&mdev);
+	if(hdcp->keys)
+		kfree(hdcp->keys);
+	if(hdcp->invalidkeys)
+		kfree(hdcp->invalidkeys);
+	kfree(hdcp);
+}
+
+module_init(rk610_hdcp_init);
+module_exit(rk610_hdcp_exit);
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.h b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.h
new file mode 100755
index 0000000..d7459a2
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdcp.h
@@ -0,0 +1,194 @@
+#ifndef __RK610_HDCP_H__
+#define __RK610_HDCP_H__
+
+/***************************/
+/* Definitions             */
+/***************************/
+
+/* Status / error codes */
+#define HDCP_OK			0
+#define HDCP_KEY_ERR	1
+#define HDCP_KSV_ERR	2
+
+/* Delays */
+#define HDCP_ENABLE_DELAY	300
+#define HDCP_REAUTH_DELAY	100
+
+/* Event source */
+#define HDCP_SRC_SHIFT		8
+#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
+#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
+#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
+#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
+
+/* Event */
+#define HDCP_ENABLE_CTL			(HDCP_IOCTL_SRC		| 0)
+#define HDCP_DISABLE_CTL		(HDCP_IOCTL_SRC		| 1)
+#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC		| 2)
+#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC		| 3)
+#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC		| 4)
+#define HDCP_FAIL_EVENT			(HDCP_IRQ_SRC		| 5)
+#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC		| 6)
+#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC	| 7)
+
+/* Key size */
+#define HDCP_KEY_SIZE			308	
+
+/* HDCP DDC Clock */
+#define HDCP_DDC_CLK			100000
+
+/* Authentication retry times */
+#define HDCP_INFINITE_REAUTH	0x100
+
+/* HDCP Regs */
+#define HDCP_CTRL1				0x52
+	#define m_AUTH_START		(1 << 7)
+	#define m_BKSV_VALID		(1 << 6)
+	#define m_BKSV_INVALID		(1 << 5)
+	#define m_ENCRYPT_ENABLE	(1 << 4)
+	#define m_AUTH_STOP			(1 << 3)
+	#define m_ADVANED_ENABLE	(1 << 2)
+	#define m_HDMI_DVI			(1 << 1)
+	#define m_HDCP_RESET		(1 << 0)
+	
+	#define v_AUTH_START(n)		(n << 7)
+	#define v_BKSV_VALID(n)		(n << 6)
+	#define v_BKSV_INVALID(n)	(n << 5)
+	#define v_ENCRYPT_ENABLE(n)	(n << 4)
+	#define v_AUTH_STOP(n)		(n << 3)
+	#define v_ADVANED_ENABLE(n)	(n << 2)
+	#define v_HDMI_DVI(n)		(n << 1)
+	#define v_HDCP_RESET(n)		(n << 0)
+
+#define HDCP_CTRL2				0x53
+	#define m_DISABLE_127_CHECK				(1 << 7)
+	#define m_SKIP_BKSV_CHECK				(1 << 6)
+	#define m_ENABLE_PJ_CHECK				(1 << 5)
+	#define m_DISABLE_DEVICE_NUMBER_CHECK	(1 << 4)
+	#define m_DELAY_RI_1_CLK				(1 << 3)
+	#define m_USE_PRESET_AN					(1 << 2)
+	#define m_KEY_COMBINATION				(3 << 0)
+	
+	#define v_DISABLE_127_CHECK(n)			(n << 7)
+	#define v_SKIP_BKSV_CHECK(n)			(n << 6)
+	#define v_ENABLE_PJ_CHECK(n)			(n << 5)
+	#define v_DISABLE_DEVICE_NUMBER_CHECK(n)(n << 4)
+	#define v_DELAY_RI_1_CLK(n)				(n << 3)
+	#define v_USE_PRESET_AN(n)				(n << 2)
+	#define v_KEY_COMBINATION(n)			(n << 0)
+
+#define HDCP_KEY_STATUS			0x54
+	#define m_KEY_READY			(1 << 0)
+
+#define HDCP_CTRL_SOFT			0x57
+	#define m_DISABLE_127_CHECK				(1 << 7)
+	#define m_SKIP_BKSV_CHECK				(1 << 6)
+	#define m_NOT_AUTHENTICATED				(1 << 5)
+	#define m_ENCRYPTED						(1 << 4)
+	#define m_ADVANCED_CIPHER				(1 << 3)
+	
+#define HDCP_BCAPS_RX			0x58
+#define HDCP_TIMER_100MS		0x63
+#define HDCP_TIMER_5S			0x64
+#define HDCP_ERROR				0x65
+	#define m_DDC_NO_ACK		(1 << 3)
+	#define m_PJ_MISMACH		(1 << 2)
+	#define m_RI_MISMACH		(1 << 1)
+	#define m_BKSV_WRONG		(1 << 0)
+
+#define HDCP_KSV_BYTE0			0x66
+#define HDCP_KSV_BYTE1			0x67
+#define HDCP_KSV_BYTE2			0x68
+#define HDCP_KSV_BYTE3			0x69
+#define HDCP_KSV_BYTE4			0x6a
+
+#define HDCP_AN_SEED			0x6c
+
+#define HDCP_BCAPS_TX			0x80
+#define HDCP_BSTATE_0			0x81
+#define HDCP_BSTATE_1			0x82
+
+#define HDCP_KEY_FIFO			0x98
+
+#define HDCP_INT_MASK1			0xc2
+#define HDCP_INT_STATUS1		0xc3
+	#define m_INT_HDCP_ERR		(1 << 7)
+	#define m_INT_BKSV_READY	(1 << 6)
+	#define m_INT_BKSV_UPDATE	(1 << 5)
+	#define m_INT_AUTH_SUCCESS	(1 << 4)
+	#define m_INT_AUTH_READY	(1 << 3)
+	
+#define HDCP_INT_MASK2			0xc4
+#define HDCP_INT_STATUS2		0xc5
+	#define m_INT_SOFT_MODE_READY			(1 << 7)
+	#define m_INT_AUTH_M0_REDAY				(1 << 6)
+	#define m_INT_1st_FRAME_ARRIVE			(1 << 5)
+	#define m_INT_AN_READY					(1 << 4)
+	#define m_INT_ENCRYPTED					(1 << 2)
+	#define m_INT_NOT_ENCRYPTED_AVMUTE		(1 << 1)
+	#define m_INT_NOT_ENCRYPTED_AVUNMUTE	(1 << 0)
+
+enum hdcp_states {
+	HDCP_DISABLED,
+	HDCP_ENABLE_PENDING,
+	HDCP_AUTHENTICATION_START,
+	HDCP_WAIT_KSV_LIST,
+	HDCP_LINK_INTEGRITY_CHECK,
+};
+
+enum hdmi_states {
+	HDMI_STOPPED,
+	HDMI_STARTED
+};
+
+#define HDCP_PRIVATE_KEY_SIZE	280
+#define HDCP_KEY_SHA_SIZE		20
+
+struct hdcp_keys{
+	u8 KSV[8];
+	u8 DeviceKey[HDCP_PRIVATE_KEY_SIZE];
+	u8 sha1[HDCP_KEY_SHA_SIZE];
+};
+
+struct hdcp_delayed_work {
+	struct delayed_work work;
+	int event;
+};
+
+struct hdcp {
+	int	enable;
+	int retry_times;
+	struct hdcp_keys *keys;
+	int invalidkey;
+	char *invalidkeys;	
+	struct mutex lock;
+	struct completion	complete;
+	struct workqueue_struct *workqueue;
+	
+	enum hdmi_states hdmi_state;
+	enum hdcp_states hdcp_state;
+	
+	struct delayed_work *pending_start;
+	struct delayed_work *pending_wq_event;
+	int retry_cnt;
+};
+
+extern struct hdcp *hdcp;
+
+#ifdef DBG
+#undef DBG
+#endif
+
+#ifdef HDCP_DEBUG
+#define DBG(format, ...) \
+		printk(KERN_INFO "HDCP: " format "\n", ## __VA_ARGS__)
+#else
+#define DBG(format, ...)
+#endif
+
+extern void rk610_hdcp_disable(void);
+extern int	rk610_hdcp_start_authentication(void);
+extern int	rk610_hdcp_check_bksv(void);
+extern int	rk610_hdcp_load_key2mem(struct hdcp_keys *key);
+extern void rk610_hdcp_interrupt(char *status1, char *status2);
+#endif /* __RK610_HDCP_H__ */
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.c b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.c
new file mode 100755
index 0000000..65fc04f
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.c
@@ -0,0 +1,336 @@
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mfd/rk610_core.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <mach/gpio.h>
+#include <mach/iomux.h>
+#include <linux/i2c.h>
+#include "rk610_hdmi.h"
+
+struct rk610_hdmi_pdata *rk610_hdmi = NULL;
+struct hdmi *hdmi=NULL;
+struct i2c_client *rk610_g_hdmi_client=NULL;
+extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
+extern void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent);
+extern void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
+
+int rk610_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void))
+{
+	hdmi->hdcp_cb = hdcp_cb;
+	hdmi->hdcp_irq_cb = hdcp_irq_cb;
+	hdmi->hdcp_power_on_cb = hdcp_power_on_cb;
+	hdmi->hdcp_power_off_cb = hdcp_power_off_cb;
+	
+	return HDMI_ERROR_SUCESS;
+}
+
+#ifdef RK610_DEBUG
+static int rk610_read_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_recv(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+
+static int rk610_write_p0_reg(struct i2c_client *client, char reg, char *val)
+{
+	return i2c_master_reg8_send(client, reg, val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+static ssize_t rk610_show_reg_attrs(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+
+	int i,size=0;
+	char val;
+	struct i2c_client *client=rk610_g_hdmi_client;
+
+	for(i=0;i<256;i++)
+	{
+		rk610_read_p0_reg(client, i,  &val);
+		if(i%16==0)
+			size += sprintf(buf+size,"\n>>>rk610_hdmi %x:",i);
+		size += sprintf(buf+size," %2x",val);
+	}
+
+	return size;
+}
+static ssize_t rk610_store_reg_attrs(struct device *dev,
+						struct device_attribute *attr,
+			 			const char *buf, size_t size)
+{
+	struct i2c_client *client=NULL;
+	static char val=0,reg=0;
+	client = rk610_g_hdmi_client;
+	RK610_DBG(&client->dev,"/**********rk610 reg config******/");
+
+	sscanf(buf, "%x%x", &val,&reg);
+	RK610_DBG(&client->dev,"reg=%x val=%x\n",reg,val);
+	rk610_write_p0_reg(client, reg,  &val);
+	RK610_DBG(&client->dev,"val=%x\n",val);
+	return size;
+}
+
+static struct device_attribute rk610_attrs[] = {
+	__ATTR(reg_ctl, 0777,rk610_show_reg_attrs,rk610_store_reg_attrs),
+};
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hdmi_early_suspend(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi->pwr_mode, hdmi->state);
+	flush_delayed_work(&hdmi->delay_work);	
+	mutex_lock(&hdmi->enable_mutex);
+	hdmi->suspend = 1;
+	if(!hdmi->enable) {
+		mutex_unlock(&hdmi->enable_mutex);
+		return;
+	}
+	
+	#ifdef HDMI_USE_IRQ
+	if(hdmi->irq)
+		disable_irq(hdmi->irq);
+	#endif
+	
+	mutex_unlock(&hdmi->enable_mutex);
+	hdmi->command = HDMI_CONFIG_ENABLE;
+	init_completion(&hdmi->complete);
+	hdmi->wait = 1;
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+	wait_for_completion_interruptible_timeout(&hdmi->complete,
+							msecs_to_jiffies(5000));
+	flush_delayed_work(&hdmi->delay_work);
+	return;
+}
+
+static void hdmi_early_resume(struct early_suspend *h)
+{
+	hdmi_dbg(hdmi->dev, "hdmi exit early resume\n");
+	mutex_lock(&hdmi->enable_mutex);
+	
+	hdmi->suspend = 0;
+	#ifdef HDMI_USE_IRQ
+	if(hdmi->enable && hdmi->irq) {
+		enable_irq(hdmi->irq);
+	}
+	#else
+	queue_delayed_work(rk610_hdmi->workqueue, &rk610_hdmi->delay_work, 100);
+	#endif
+	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
+	mutex_unlock(&hdmi->enable_mutex);
+	return;
+}
+#endif
+
+static void rk610_irq_work_func(struct work_struct *work)
+{
+	if(hdmi->suspend == 0) {
+		if(hdmi->enable == 1) {
+			rk610_hdmi_interrupt();
+			if(hdmi->hdcp_irq_cb)
+				hdmi->hdcp_irq_cb(0);
+		}
+		#ifndef HDMI_USE_IRQ
+		queue_delayed_work(rk610_hdmi->workqueue, &rk610_hdmi->delay_work, 50);
+		#endif
+	}
+}
+
+#ifdef HDMI_USE_IRQ
+static irqreturn_t rk610_irq(int irq, void *dev_id)
+{
+	printk(KERN_INFO "rk610 irq triggered.\n");
+	schedule_work(&rk610_hdmi->irq_work);
+    return IRQ_HANDLED;
+}
+#endif
+
+static int rk610_hdmi_i2c_probe(struct i2c_client *client,const struct i2c_device_id *id)
+{
+    int rc = 0;
+	
+	rk610_hdmi = kzalloc(sizeof(struct rk610_hdmi_pdata), GFP_KERNEL);
+	if(!rk610_hdmi)
+	{
+        dev_err(&client->dev, "no memory for state\n");
+    	return -ENOMEM;
+    }
+	rk610_hdmi->client = client;
+	rk610_g_hdmi_client = client;
+	i2c_set_clientdata(client, rk610_hdmi);
+	
+	hdmi = kmalloc(sizeof(struct hdmi), GFP_KERNEL);
+	if(!hdmi)
+	{
+    	dev_err(&client->dev, "rk610 hdmi kmalloc fail!");
+    	goto err_kzalloc_hdmi;
+	}
+	memset(hdmi, 0, sizeof(struct hdmi));
+	hdmi->dev = &client->dev;
+	
+	if(HDMI_SOURCE_DEFAULT == HDMI_SOURCE_LCDC0)
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
+	else
+		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
+	if(hdmi->lcdc == NULL)
+	{
+		dev_err(hdmi->dev, "can not connect to video source lcdc\n");
+		rc = -ENXIO;
+		goto err_request_lcdc;
+	}
+	hdmi->xscale = 100;
+	hdmi->yscale = 100;
+	hdmi->insert = rk610_hdmi_sys_insert;
+	hdmi->remove = rk610_hdmi_sys_remove;
+	hdmi->control_output = rk610_hdmi_sys_enalbe_output;
+	hdmi->config_video = rk610_hdmi_sys_config_video;
+	hdmi->config_audio = rk610_hdmi_sys_config_audio;
+	hdmi->detect_hotplug = rk610_hdmi_sys_detect_hpd;
+	hdmi->read_edid = rk610_hdmi_sys_read_edid;
+	hdmi_sys_init();
+	
+	hdmi->workqueue = create_singlethread_workqueue("hdmi");
+	INIT_DELAYED_WORK(&(hdmi->delay_work), hdmi_work);
+	
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	hdmi->early_suspend.suspend = hdmi_early_suspend;
+	hdmi->early_suspend.resume = hdmi_early_resume;
+	hdmi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 10;
+	register_early_suspend(&hdmi->early_suspend);
+	#endif
+	
+	hdmi_register_display_sysfs(hdmi, NULL);
+	#ifdef CONFIG_SWITCH
+	hdmi->switch_hdmi.name="hdmi";
+	switch_dev_register(&(hdmi->switch_hdmi));
+	#endif
+		
+	spin_lock_init(&hdmi->irq_lock);
+	mutex_init(&hdmi->enable_mutex);
+	
+	rk610_hdmi_sys_init();
+	
+#ifdef HDMI_USE_IRQ
+	if(client->irq != INVALID_GPIO) {
+		INIT_WORK(&rk610_hdmi->irq_work, rk610_irq_work_func);
+		schedule_work(&rk610_hdmi->irq_work);
+		if((rc = gpio_request(client->irq, "hdmi gpio")) < 0)
+	    {
+	        dev_err(&client->dev, "fail to request gpio %d\n", client->irq);
+	        goto err_request_lcdc;
+	    }
+	    hdmi->irq = gpio_to_irq(client->irq);
+		rk610_hdmi->gpio = client->irq;
+	    gpio_pull_updown(client->irq, GPIOPullUp);
+	    gpio_direction_input(client->irq);
+	    if((rc = request_irq(hdmi->irq, rk610_irq, IRQF_TRIGGER_RISING, NULL, hdmi)) < 0)
+	    {
+	        dev_err(&client->dev, "fail to request hdmi irq\n");
+	        goto err_request_irq;
+	    }
+	}
+	else
+#else
+	{
+		rk610_hdmi->workqueue = create_singlethread_workqueue("rk610 irq");
+		INIT_DELAYED_WORK(&(rk610_hdmi->delay_work), rk610_irq_work_func);
+		rk610_irq_work_func(NULL);
+	}
+#endif
+
+#ifdef RK610_DEBUG
+	device_create_file(&(client->dev), &rk610_attrs[0]);
+#endif
+
+	dev_info(&client->dev, "rk610 hdmi i2c probe ok\n");
+	
+    return 0;
+	
+err_request_irq:
+	gpio_free(client->irq);
+err_request_lcdc:
+	kfree(hdmi);
+	hdmi = NULL;
+err_kzalloc_hdmi:
+	kfree(rk610_hdmi);
+	rk610_hdmi = NULL;
+	dev_err(&client->dev, "rk610 hdmi probe error\n");
+	return rc;
+
+}
+
+static int __devexit rk610_hdmi_i2c_remove(struct i2c_client *client)
+{	
+	hdmi_dbg(hdmi->dev, "%s\n", __func__);
+	if(hdmi) {
+		mutex_lock(&hdmi->enable_mutex);
+		if(!hdmi->suspend && hdmi->enable && hdmi->irq)
+			disable_irq(hdmi->irq);
+		mutex_unlock(&hdmi->enable_mutex);
+		if(hdmi->irq)
+			free_irq(hdmi->irq, NULL);
+		flush_workqueue(hdmi->workqueue);
+		destroy_workqueue(hdmi->workqueue);
+		#ifdef CONFIG_SWITCH
+		switch_dev_unregister(&(hdmi->switch_hdmi));
+		#endif
+		hdmi_unregister_display_sysfs(hdmi);
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+		fb_destroy_modelist(&hdmi->edid.modelist);
+		if(hdmi->edid.audio)
+			kfree(hdmi->edid.audio);
+		if(hdmi->edid.specs)
+		{
+			if(hdmi->edid.specs->modedb)
+				kfree(hdmi->edid.specs->modedb);
+			kfree(hdmi->edid.specs);
+		}
+		kfree(hdmi);
+		hdmi = NULL;
+	}
+    return 0;
+}
+
+static void rk610_hdmi_i2c_shutdown(struct i2c_client *client)
+{
+	if(hdmi) {
+		#ifdef CONFIG_HAS_EARLYSUSPEND
+		unregister_early_suspend(&hdmi->early_suspend);
+		#endif
+	}
+	printk(KERN_INFO "rk610 hdmi shut down.\n");
+}
+
+static const struct i2c_device_id rk610_hdmi_id[] = {
+	{ "rk610_hdmi", 0 },
+	{ }
+};
+
+static struct i2c_driver rk610_hdmi_i2c_driver = {
+    .driver = {
+        .name  = "rk610_hdmi",
+        .owner = THIS_MODULE,
+    },
+    .probe      = rk610_hdmi_i2c_probe,
+    .remove     = rk610_hdmi_i2c_remove,
+    .shutdown	= rk610_hdmi_i2c_shutdown,
+    .id_table	= rk610_hdmi_id,
+};
+
+static int __init rk610_hdmi_init(void)
+{
+    return i2c_add_driver(&rk610_hdmi_i2c_driver);
+}
+
+static void __exit rk610_hdmi_exit(void)
+{
+    i2c_del_driver(&rk610_hdmi_i2c_driver);
+}
+
+module_init(rk610_hdmi_init);
+//fs_initcall(rk610_init);
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.h b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.h
new file mode 100755
index 0000000..746283e
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi.h
@@ -0,0 +1,34 @@
+#ifndef __RK610_HDMI_H__
+#define __RK610_HDMI_H__
+#include "../../rk_hdmi.h"
+
+#define HDMI_SOURCE_DEFAULT HDMI_SOURCE_LCDC0
+//#define HDMI_USE_IRQ
+
+struct rk610_hdmi_pdata {
+	int gpio;
+	struct i2c_client *client;
+	struct delayed_work delay_work;
+	#ifdef HDMI_USE_IRQ
+	struct work_struct	irq_work;
+	#else
+	struct workqueue_struct *workqueue;
+	#endif
+};
+
+extern struct rk610_hdmi_pdata *rk610_hdmi;
+
+extern int rk610_hdmi_sys_init(void);
+extern void rk610_hdmi_interrupt(void);
+extern int rk610_hdmi_sys_detect_hpd(void);
+extern int rk610_hdmi_sys_insert(void);
+extern int rk610_hdmi_sys_remove(void);
+extern int rk610_hdmi_sys_read_edid(int block, unsigned char *buff);
+extern int rk610_hdmi_sys_config_video(struct hdmi_video_para *vpara);
+extern int rk610_hdmi_sys_config_audio(struct hdmi_audio *audio);
+extern void rk610_hdmi_sys_enalbe_output(int enable);
+extern int rk610_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
+					 void (*hdcp_irq_cb)(int status),
+					 int (*hdcp_power_on_cb)(void),
+					 void (*hdcp_power_off_cb)(void));
+#endif
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hdcp.c b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hdcp.c
new file mode 100755
index 0000000..e690f71
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hdcp.c
@@ -0,0 +1,156 @@
+#include <linux/delay.h>
+#include "rk610_hdmi.h"
+#include "rk610_hdmi_hw.h"
+#include "rk610_hdcp.h"
+
+static char rk610_hdmi_i2c_read_reg(char reg)
+{
+	char val = 0;
+	
+	if(i2c_master_reg8_recv(rk610_hdmi->client, reg, &val, 1, 100*1000) > 0)
+		return  val;
+	else {
+		printk(KERN_ERR "[%s] read reg %02x error\n", __FUNCTION__, reg);
+		return 0;
+	}
+}
+static char rk610_hdmi_i2c_write_reg(char reg, char val)
+{
+	if(i2c_master_reg8_send(rk610_hdmi->client, reg, &val, 1, 100*1000) > 0)
+		return 0;
+	else {
+		printk(KERN_ERR "[%s] write reg %02x error\n", __FUNCTION__, reg);
+		return -EINVAL;
+	}
+}
+
+#define HDCPWrReg	rk610_hdmi_i2c_write_reg
+#define HDCPRdReg	rk610_hdmi_i2c_read_reg
+#define HDCPMskReg(temp, addr, msk, val)	\
+	temp = HDCPRdReg(addr) & (0xFF - (msk)) ; \
+	HDCPWrReg(addr, temp | ( (val) & (msk) )); 
+	
+void rk610_hdcp_disable(void)
+{
+	char temp;
+	
+	// Diable HDCP Interrupt
+	HDCPWrReg(HDCP_INT_MASK1, 0x00);
+	// Stop and Reset HDCP
+	HDCPMskReg(temp, HDCP_CTRL1, m_ENCRYPT_ENABLE | m_AUTH_STOP | m_HDCP_RESET, 
+		v_ENCRYPT_ENABLE(0) | v_AUTH_STOP(1) | v_HDCP_RESET(1) )
+}
+
+int	rk610_hdcp_load_key2mem(struct hdcp_keys *key)
+{
+	int i;
+	DBG("HDCP: rk610_hdcp_load_key2mem start");
+	// Write 40 private key
+	for(i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++)
+		HDCPWrReg(HDCP_KEY_FIFO, key->DeviceKey[i]);
+	
+	// Write 1st aksv
+	for(i = 0; i < 5; i++)
+		HDCPWrReg(HDCP_KEY_FIFO, key->KSV[i]);
+		
+	// Write 2nd aksv
+	for(i = 0; i < 5; i++)
+		HDCPWrReg(HDCP_KEY_FIFO, key->KSV[i]);
+	DBG("HDCP: rk610_hdcp_load_key2mem end");
+	return HDCP_OK;
+}
+
+int	rk610_hdcp_start_authentication(void)
+{
+	char temp;
+	int retry = 0;
+
+	if(hdcp->keys == NULL) {
+		printk(KERN_ERR "HDCP: key is not loaded\n");
+		return HDCP_KEY_ERR;
+	}
+	
+	// Select TMDS CLK to configure regs
+	HDCPMskReg(temp, SYS_CTRL, m_REG_CLK_SOURCE, v_REG_CLK_SOURCE_TMDS);
+	
+	temp = HDCPRdReg(HDCP_KEY_STATUS);
+	while( ( temp & m_KEY_READY) == 0 ) {
+		if(retry > 10) {
+			printk(KERN_ERR "HDCP: loaded key error\n");
+			return HDCP_KEY_ERR;
+		}
+		rk610_hdcp_load_key2mem(hdcp->keys);
+		msleep(1);
+		temp = HDCPRdReg(HDCP_KEY_STATUS);
+	}
+	
+	// Config DDC bus clock: ddc_clk = reg_clk/4*(reg 0x4c 0x4b)
+	DBG("TMDS frequency %d", hdmi->tmdsclk);
+	retry = hdmi->tmdsclk/(HDCP_DDC_CLK*4);
+	HDCPWrReg(DDC_CLK_L, retry & 0xFF);
+	HDCPWrReg(DDC_CLK_H, (retry >> 8) & 0xFF);
+	
+	HDCPWrReg(HDCP_CTRL2, 0x00);
+	
+	//Enable interrupt
+	HDCPWrReg(HDCP_INT_MASK1, m_INT_HDCP_ERR | m_INT_BKSV_READY | m_INT_BKSV_UPDATE | m_INT_AUTH_SUCCESS | m_INT_AUTH_READY);
+//	HDCPWrReg(HDCP_INT_MASK2, 0xFF);
+	//Start authentication
+	HDCPMskReg(temp, HDCP_CTRL1, m_AUTH_START | m_ENCRYPT_ENABLE | m_ADVANED_ENABLE, v_AUTH_START(1) | v_ENCRYPT_ENABLE(1) | v_ADVANED_ENABLE(0));
+	
+	return HDCP_OK;
+}
+
+int	rk610_hdcp_check_bksv(void)
+{
+	int i, j;
+	char temp = 0, bksv[5];
+	char *invalidkey;
+	
+	for(i = 0; i < 5; i++) {
+		bksv[i] = HDCPRdReg(HDCP_KSV_BYTE0 + (4 - i)) & 0xFF;
+	}
+	DBG("bksv is 0x%02x%02x%02x%02x%02x", bksv[0], bksv[1], bksv[2], bksv[3], bksv[4]);
+	
+	for (i = 0; i < 5; i++)
+	{
+    	for (j = 0; j < 8; j++)
+    	{
+    		if (bksv[i] & 0x01)
+    		{
+        		temp++;
+    		}
+    		bksv[i] >>= 1;
+    	}
+ 	}
+ 	if (temp != 20)
+    	return HDCP_KSV_ERR;
+	
+	for(i = 0; i < hdcp->invalidkey; i++)
+	{
+		invalidkey = hdcp->invalidkeys + i *5;
+		if(memcmp(bksv, invalidkey, 5) == 0) {
+			printk(KERN_ERR "HDCP: BKSV was revocated!!!\n");
+			HDCPMskReg(temp, HDCP_CTRL1, m_BKSV_INVALID | m_ENCRYPT_ENABLE, v_BKSV_INVALID(1) | v_ENCRYPT_ENABLE(1));
+			return HDCP_KSV_ERR;
+		}
+	}
+	HDCPMskReg(temp, HDCP_CTRL1, m_BKSV_VALID | m_ENCRYPT_ENABLE, v_BKSV_VALID(1) | v_ENCRYPT_ENABLE(1));
+	return HDCP_OK;
+}
+
+void rk610_hdcp_interrupt(char *status1, char *status2)
+{
+	char interrupt1 = HDCPRdReg(HDCP_INT_STATUS1);
+	char interrupt2 = HDCPRdReg(HDCP_INT_STATUS2);
+	if(interrupt1) {
+		HDCPWrReg(HDCP_INT_STATUS1, interrupt1);
+		if(interrupt1 & m_INT_HDCP_ERR)
+			printk(KERN_INFO "HDCP: Error 0x%02x\n", HDCPRdReg(HDCP_ERROR));
+	}
+	if(interrupt2)
+		HDCPWrReg(HDCP_INT_STATUS2, interrupt2);
+	
+	*status1 = interrupt1;
+	*status2 = interrupt2;
+}
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.c b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.c
new file mode 100755
index 0000000..9c3396f
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.c
@@ -0,0 +1,409 @@
+#include <linux/delay.h>
+#include "rk610_hdmi.h"
+#include "rk610_hdmi_hw.h"
+#include <asm/atomic.h>
+
+static atomic_t edid_ready;
+
+static int rk610_hdmi_i2c_read_reg(char reg, char *val)
+{
+	if(i2c_master_reg8_recv(rk610_hdmi->client, reg, val, 1, 100*1000) > 0)
+		return  0;
+	else {
+		printk("[%s] reg %02x error\n", __FUNCTION__, reg);
+		return -EINVAL;
+	}
+}
+static int rk610_hdmi_i2c_write_reg(char reg, char val)
+{
+	return i2c_master_reg8_send(rk610_hdmi->client, reg, &val, 1, 100*1000) > 0? 0: -EINVAL;
+}
+
+#define HDMIWrReg	rk610_hdmi_i2c_write_reg
+
+int rk610_hdmi_sys_init(void)
+{
+	// System power power off
+	HDMIWrReg(SYS_CTRL, v_REG_CLK_SOURCE_IIS | v_PWR_OFF | v_INT_POL_HIGH);
+	
+	//Synchronize analog module.
+//	HDMIWrReg(PHY_SYNC, 0x00);
+//	HDMIWrReg(PHY_SYNC, 0x01);
+	
+	// set hdmi phy parameters
+	// driver mode
+	HDMIWrReg(PHY_DRIVER, v_MAIN_DRIVER(8)| v_PRE_DRIVER(0) | v_TX_ENABLE(0));
+//	HDMIWrReg(PHY_PRE_EMPHASIS, 0x04);
+	HDMIWrReg(PHY_PRE_EMPHASIS, v_PRE_EMPHASIS(0) | v_TMDS_PWRDOWN(1));	//Driver power down	
+	// pll mode
+	HDMIWrReg(0xe8, 0x10);
+	HDMIWrReg(0xe6, 0x2c);
+
+	HDMIWrReg(PHY_PLL_CTRL, v_PLL_DISABLE(1) | v_PLL_RESET(1) | v_TMDS_RESET(1));
+	HDMIWrReg(PHY_PLL_LDO_PWR, v_LDO_PWR_DOWN(1));
+	HDMIWrReg(PHY_BANDGAP_PWR, v_BANDGAP_PWR_DOWN);
+
+	// Enable Hotplug interrupt
+	HDMIWrReg(INTERRUPT_MASK1, m_INT_HOTPLUG);
+	return HDMI_ERROR_SUCESS;
+}
+
+void rk610_hdmi_interrupt()
+{
+	char interrupt = 0;
+	
+	if(rk610_hdmi_i2c_read_reg(INTERRUPT_STATUS1, &interrupt))
+		return;
+		
+	HDMIWrReg(INTERRUPT_STATUS1, interrupt);
+	
+	if(interrupt)
+		HDMIWrReg(INTERRUPT_STATUS1, interrupt);
+	
+	if(interrupt & m_INT_HOTPLUG) {
+		hdmi_dbg(hdmi->dev, "%s interrupt %02x\n", __FUNCTION__, interrupt);
+		if(hdmi->state == HDMI_SLEEP)
+			hdmi->state = WAIT_HOTPLUG;
+		queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
+	}
+	else if(interrupt & m_INT_EDID_READY) {
+		atomic_set(&edid_ready, 1);
+	}
+}
+
+int rk610_hdmi_sys_detect_hpd(void)
+{
+	char hdmi_status = 0;
+
+	#ifdef HDMI_USE_IRQ
+	rk610_hdmi_i2c_read_reg(INTERRUPT_STATUS1, &hdmi_status);
+	HDMIWrReg(INTERRUPT_STATUS1, hdmi_status);
+	#endif
+	hdmi_status = 0;
+	rk610_hdmi_i2c_read_reg(HDMI_STATUS, &hdmi_status);
+//	printk("%s value is %02x\n", __FUNCTION__, hdmi_status);	
+	if(hdmi_status)
+		return HDMI_HPD_ACTIVED;
+	else
+		return HDMI_HPD_REMOVED;
+}
+
+#define SYSCLK	11289600
+#define DDC_CLK 100000
+int rk610_hdmi_sys_read_edid(int block, unsigned char *buff)
+{
+	char value;
+	int count, rc = HDMI_ERROR_EDID;
+	int trytime = 2;
+	
+	// Config DDC bus clock: ddc_clk = reg_clk/4*(reg 0x4c 0x4b)
+	// when reg00 select reg_clk equal to sys_clk which is equal
+	// to i2s clk, it gernerally is 11.2896MHz.
+	
+	count = SYSCLK/(DDC_CLK*4);
+	HDMIWrReg(DDC_CLK_L, count & 0xFF);
+	HDMIWrReg(DDC_CLK_H, (count >> 8) & 0xFF);
+	
+	// Enable EDID Interrupt
+//	edid_ready = 0;
+	atomic_set(&edid_ready, 0);
+	value = 0;
+	rk610_hdmi_i2c_read_reg(INTERRUPT_MASK1, &value);
+	value |= m_INT_EDID_READY;
+	HDMIWrReg(INTERRUPT_MASK1, value);
+	
+	
+	while(trytime--) {
+		// Reset FIFO offset
+		HDMIWrReg(EDID_FIFO_OFFSET, 0);
+		// Set EDID read addr.
+		HDMIWrReg(EDID_WORD_ADDR, (block%2) * 0x80);
+		HDMIWrReg(EDID_SEGMENT_POINTER, block/2);
+		
+		count = 0;
+		while(count++ < 10)
+		{	
+			value = atomic_read(&edid_ready);
+			if(value)
+			{
+				for(count = 0; count < 128; count++)
+					rk610_hdmi_i2c_read_reg(EDID_FIFO_ADDR, buff + count);
+				rc = HDMI_ERROR_SUCESS;
+				break;
+			}
+			msleep(100);
+		}
+	}
+	// Disable EDID interrupt.
+	value = 0;
+	rk610_hdmi_i2c_read_reg(INTERRUPT_MASK1, &value);
+	value &= ~m_INT_EDID_READY;
+	HDMIWrReg(INTERRUPT_MASK1, value);
+	return rc;
+}
+
+static void rk610_hdmi_config_avi(unsigned char vic, unsigned char output_color)
+{
+	int i;
+	char info[SIZE_AVI_INFOFRAME];
+	
+	memset(info, 0, SIZE_AVI_INFOFRAME);
+	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AVI);
+	info[0] = 0x82;
+	info[1] = 0x02;
+	info[2] = 0x0D;	
+	info[3] = info[0] + info[1] + info[2];
+	info[4] = (AVI_COLOR_MODE_RGB << 5);
+	info[5] = (AVI_COLORIMETRY_NO_DATA << 6) | (AVI_CODED_FRAME_ASPECT_NO_DATA << 4) | ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME;
+	info[6] = 0;
+	info[7] = vic;
+	info[8] = 0;
+
+	// Calculate AVI InfoFrame ChecKsum
+	for (i = 4; i < SIZE_AVI_INFOFRAME; i++)
+	{
+    	info[3] += info[i];
+	}
+	info[3] = 0x100 - info[3];
+	
+	for(i = 0; i < SIZE_AVI_INFOFRAME; i++)
+		HDMIWrReg(CONTROL_PACKET_ADDR + i, info[i]);
+}
+
+int rk610_hdmi_sys_config_video(struct hdmi_video_para *vpara)
+{
+	char value;
+	struct fb_videomode *mode;
+	
+	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
+	if(vpara == NULL) {
+		hdmi_err(hdmi->dev, "[%s] input parameter error\n", __FUNCTION__);
+		return -1;
+	}
+	if(hdmi->hdcp_power_off_cb)
+		hdmi->hdcp_power_off_cb();
+	// Diable video and audio output
+	HDMIWrReg(AV_MUTE, v_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));
+	
+	// Input video mode is SDR RGB24bit, Data enable signal from external
+	HDMIWrReg(VIDEO_CONTRL1, v_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444) | v_DE_EXTERNAL);
+	HDMIWrReg(VIDEO_CONTRL2, v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS) | (vpara->output_color & 0xFF));
+
+	// Set HDMI Mode
+	HDMIWrReg(HDCP_CTRL, v_HDMI_DVI(vpara->output_mode));
+
+	// Enable or disalbe color space convert
+	if(vpara->input_color != vpara->output_color) {
+		value = v_SOF_DISABLE | v_CSC_ENABLE;
+	}
+	else
+		value = v_SOF_DISABLE;
+	HDMIWrReg(VIDEO_CONTRL3, value);
+	
+	#if 1
+	HDMIWrReg(VIDEO_TIMING_CTL, 0);
+	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
+	if(mode == NULL)
+	{
+		hdmi_err(hdmi->dev, "[%s] not found vic %d\n", __FUNCTION__, vpara->vic);
+		return -ENOENT;
+	}
+	hdmi->tmdsclk = mode->pixclock;
+#else
+	value = v_EXTERANL_VIDEO(1) | v_INETLACE(mode->vmode);
+	if(mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		value |= v_HSYNC_POLARITY(1);
+	if(mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		value |= v_VSYNC_POLARITY(1);
+	HDMIWrReg(VIDEO_TIMING_CTL, value);
+	
+	value = mode->left_margin + mode->xres + mode->right_margin + mode->hsync_len;
+	HDMIWrReg(VIDEO_EXT_HTOTAL_L, value & 0xFF);
+	HDMIWrReg(VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);
+	
+	value = mode->left_margin + mode->right_margin + mode->hsync_len;
+	HDMIWrReg(VIDEO_EXT_HBLANK_L, value & 0xFF);
+	HDMIWrReg(VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);
+	
+	value = mode->left_margin + mode->hsync_len;
+	HDMIWrReg(VIDEO_EXT_HDELAY_L, value & 0xFF);
+	HDMIWrReg(VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);
+	
+	value = mode->hsync_len;
+	HDMIWrReg(VIDEO_EXT_HDURATION_L, value & 0xFF);
+	HDMIWrReg(VIDEO_EXT_HDURATION_H, (value >> 8) & 0xFF);
+	
+	value = mode->upper_margin + mode->yres + mode->lower_margin + mode->vsync_len;
+	HDMIWrReg(VIDEO_EXT_VTOTAL_L, value & 0xFF);
+	HDMIWrReg(VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);
+	
+	value = mode->upper_margin + mode->vsync_len + mode->lower_margin;
+	HDMIWrReg(VIDEO_EXT_VBLANK, value & 0xFF);
+
+	if(vpara->vic == HDMI_720x480p_60Hz_4_3 || vpara->vic == HDMI_720x480p_60Hz_16_9)
+		value = 42;
+	else
+		value = mode->upper_margin + mode->vsync_len;
+
+	HDMIWrReg(VIDEO_EXT_VDELAY, value & 0xFF);
+	
+	value = mode->vsync_len;
+	HDMIWrReg(VIDEO_EXT_VDURATION, value & 0xFF);
+	#endif
+	
+	if(vpara->output_mode == OUTPUT_HDMI) {
+		rk610_hdmi_config_avi(vpara->vic, vpara->output_color);
+		hdmi_dbg(hdmi->dev, "[%s] sucess output HDMI.\n", __FUNCTION__);
+	}
+	else {
+		hdmi_dbg(hdmi->dev, "[%s] sucess output DVI.\n", __FUNCTION__);	
+	}
+
+	// Power on TMDS
+	HDMIWrReg(PHY_PRE_EMPHASIS, v_PRE_EMPHASIS(0) | v_TMDS_PWRDOWN(0)); // TMDS power on
+	
+	// Enable TMDS
+	value = 0;
+	rk610_hdmi_i2c_read_reg(PHY_DRIVER, &value);
+	value |= v_TX_ENABLE(1);
+	HDMIWrReg(PHY_DRIVER, value);
+	
+	return 0;
+}
+
+static void rk610_hdmi_config_aai(void)
+{
+	int i;
+	char info[SIZE_AUDIO_INFOFRAME];
+	
+	memset(info, 0, SIZE_AUDIO_INFOFRAME);
+	
+	info[0] = 0x84;
+	info[1] = 0x01;
+	info[2] = 0x0A;
+	
+	info[3] = info[0] + info[1] + info[2];	
+	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
+    	info[3] += info[i];
+    	
+	info[3] = 0x100 - info[3];
+	
+	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AAI);
+	for(i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
+		HDMIWrReg(CONTROL_PACKET_ADDR + i, info[i]);
+}
+
+int rk610_hdmi_sys_config_audio(struct hdmi_audio *audio)
+{
+	int rate, N, channel, mclk_fs;
+	
+	if(audio->channel < 3)
+		channel = I2S_CHANNEL_1_2;
+	else if(audio->channel < 5)
+		channel = I2S_CHANNEL_3_4;
+	else if(audio->channel < 7)
+		channel = I2S_CHANNEL_5_6;
+	else
+		channel = I2S_CHANNEL_7_8;
+		
+	switch(audio->rate)
+	{
+		case HDMI_AUDIO_FS_32000:
+			rate = AUDIO_32K;
+			N = N_32K;
+			mclk_fs = MCLK_384FS;
+			break;
+		case HDMI_AUDIO_FS_44100:
+			rate = AUDIO_441K;
+			N = N_441K;
+			mclk_fs = MCLK_256FS;
+			break;
+		case HDMI_AUDIO_FS_48000:
+			rate = AUDIO_48K;
+			N = N_48K;
+			mclk_fs = MCLK_256FS;
+			break;
+		case HDMI_AUDIO_FS_88200:
+			rate = AUDIO_882K;
+			N = N_882K;
+			mclk_fs = MCLK_128FS;
+			break;
+		case HDMI_AUDIO_FS_96000:
+			rate = AUDIO_96K;
+			N = N_96K;
+			mclk_fs = MCLK_128FS;
+			break;
+		case HDMI_AUDIO_FS_176400:
+			rate = AUDIO_1764K;
+			N = N_1764K;
+			mclk_fs = MCLK_128FS;
+			break;
+		case HDMI_AUDIO_FS_192000:
+			rate = AUDIO_192K;
+			N = N_192K;
+			mclk_fs = MCLK_128FS;
+			break;
+		default:
+			dev_err(hdmi->dev, "[%s] not support such sample rate %d\n", __FUNCTION__, audio->rate);
+			return -ENOENT;
+	}
+
+	//set_audio source I2S
+	HDMIWrReg(AUDIO_CTRL1, 0x00); //internal CTS, disable down sample, i2s input, disable MCLK
+	HDMIWrReg(AUDIO_SAMPLE_RATE, rate);
+	HDMIWrReg(AUDIO_I2S_MODE, v_I2S_MODE(I2S_STANDARD) | v_I2S_CHANNEL(channel) );	
+	HDMIWrReg(AUDIO_I2S_MAP, 0x00); 
+	HDMIWrReg(AUDIO_I2S_SWAPS_SPDIF, 0); // no swap	
+		
+    //Set N value
+    HDMIWrReg(AUDIO_N_H, (N >> 16) & 0x0F);
+    HDMIWrReg(AUDIO_N_M, (N >> 8) & 0xFF); 
+	HDMIWrReg(AUDIO_N_L, N & 0xFF);    
+    rk610_hdmi_config_aai();
+    
+    return 0;
+}
+
+void rk610_hdmi_sys_enalbe_output(int enable)
+{
+	char mutestatus = 0;
+	
+	if(enable) {
+		rk610_hdmi_i2c_read_reg(AV_MUTE, &mutestatus);
+		if(mutestatus && (m_AUDIO_MUTE | m_VIDEO_BLACK)) {
+			HDMIWrReg(AV_MUTE, v_AUDIO_MUTE(0) | v_VIDEO_MUTE(0));
+			HDMIWrReg(SYS_CTRL, v_REG_CLK_SOURCE_IIS | v_PWR_ON | v_INT_POL_HIGH);
+			HDMIWrReg(SYS_CTRL, v_REG_CLK_SOURCE_IIS | v_PWR_OFF | v_INT_POL_HIGH);
+			HDMIWrReg(SYS_CTRL, v_REG_CLK_SOURCE_IIS | v_PWR_ON | v_INT_POL_HIGH);
+			if(hdmi->hdcp_cb)
+				hdmi->hdcp_cb();
+		}
+	}
+	else {
+		HDMIWrReg(AV_MUTE, v_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));		
+	}
+}
+
+int rk610_hdmi_sys_insert(void)
+{
+	hdmi_dbg(hdmi->dev, "%s \n", __FUNCTION__);
+	//Bring up analog module.
+	HDMIWrReg(PHY_BANDGAP_PWR, v_BANDGAP_PWR_UP);	//BG power on 
+	HDMIWrReg(PHY_PLL_LDO_PWR, 0x00);		//PLL power on
+	msleep(1);
+	HDMIWrReg(PHY_PLL_CTRL, v_PLL_DISABLE(0));	//Analog reset
+	return 0;
+}
+
+int rk610_hdmi_sys_remove(void)
+{
+	hdmi_dbg(hdmi->dev, "%s \n", __FUNCTION__);
+	if(hdmi->hdcp_power_off_cb)
+		hdmi->hdcp_power_off_cb();
+	HDMIWrReg(PHY_DRIVER, v_MAIN_DRIVER(8)| v_PRE_DRIVER(0) | v_TX_ENABLE(0));
+	HDMIWrReg(PHY_PRE_EMPHASIS, v_PRE_EMPHASIS(0) | v_TMDS_PWRDOWN(1));	//Driver power down	
+	HDMIWrReg(PHY_PLL_CTRL, v_PLL_DISABLE(1) | v_PLL_RESET(1) | v_TMDS_RESET(1));
+	HDMIWrReg(PHY_PLL_LDO_PWR, v_LDO_PWR_DOWN(1));
+	HDMIWrReg(PHY_BANDGAP_PWR, v_BANDGAP_PWR_DOWN);
+	return 0;
+}
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.h b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.h
new file mode 100755
index 0000000..0e4cce9
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/chips/rk610/rk610_hdmi_hw.h
@@ -0,0 +1,237 @@
+#ifndef _RK610_HDMI_HW_H
+#define _RK610_HDMI_HW_H
+
+enum {
+		OUTPUT_DVI = 0,
+		OUTPUT_HDMI
+	};
+	
+#define SYS_CTRL					0x00
+	#define m_INT_POL				(1 << 0)
+	#define m_POWER					(1 << 1)
+	#define m_REG_CLK_SOURCE		(1 << 2)
+	#define v_INT_POL_HIGH			1
+	#define v_INT_POL_LOW			0
+	#define v_PWR_ON				(0 << 1)
+	#define v_PWR_OFF				(1 << 1)
+	#define v_REG_CLK_SOURCE_TMDS	(0 << 2)
+	#define v_REG_CLK_SOURCE_IIS	(1 << 2)
+#define VIDEO_CONTRL1				0x01
+	#define m_VIDEO_INPUT_FORMAT	(7 << 1)
+	#define m_DE_SOURCE				(1 << 0)
+	enum {
+		VIDEO_INPUT_SDR_RGB444 = 0,
+		VIDEO_INPUT_DDR_RGB444 = 5,
+		VIDEO_INPUT_DDR_YCBCR422 = 6			
+	};
+	#define v_VIDEO_INPUT_FORMAT(n)	(n << 1)
+	#define v_DE_EXTERNAL			1
+	#define v_DE_INTERANL			0
+	
+#define VIDEO_CONTRL2				0x02
+	#define m_VIDEO_OUTPUT_FORMAT	(3 << 6)
+	#define m_VIDEO_INPUT_BITS		(3 << 4)
+	#define v_VIDEO_OUTPUT_FORMAT(n)(n << 6)
+	#define v_VIDEO_INPUT_BITS(n)	(n << 4)
+	enum{
+		VIDEO_INPUT_12BITS = 0,
+		VIDEO_INPUT_10BITS,
+		VIDEO_INPUT_8BITS
+	};
+#define VIDEO_CONTRL3				0x04
+	#define m_SOF					(1 << 3)
+	#define m_CSC					(1 << 0)
+	#define v_SOF_ENABLE			(0 << 3)
+	#define v_SOF_DISABLE			(1 << 3)
+	#define v_CSC_ENABLE			1
+	#define v_CSC_DISABLE			0
+	
+#define AV_MUTE						0x05
+	#define m_AVMUTE_CLEAR			(1 << 7)
+	#define m_AVMUTE_ENABLE			(1 << 6)
+	#define m_AUDIO_MUTE			(1 << 1)
+	#define m_VIDEO_BLACK			(1 << 0)
+	#define v_AUDIO_MUTE(n)			(n << 1)
+	#define v_VIDEO_MUTE(n)			(n << 0)
+	
+#define VIDEO_TIMING_CTL			0x08
+	#define v_HSYNC_POLARITY(n)		(n << 3)
+	#define v_VSYNC_POLARITY(n)		(n << 2)
+	#define v_INETLACE(n)			(n << 1)
+	#define v_EXTERANL_VIDEO(n)		(n << 0)
+	
+#define VIDEO_EXT_HTOTAL_L			0x09
+#define VIDEO_EXT_HTOTAL_H			0x0a
+#define VIDEO_EXT_HBLANK_L			0x0b
+#define VIDEO_EXT_HBLANK_H			0x0c
+#define VIDEO_EXT_HDELAY_L			0x0d
+#define VIDEO_EXT_HDELAY_H			0x0e
+#define VIDEO_EXT_HDURATION_L		0x0f
+#define VIDEO_EXT_HDURATION_H		0x10
+#define VIDEO_EXT_VTOTAL_L			0x11
+#define VIDEO_EXT_VTOTAL_H			0x12
+#define VIDEO_EXT_VBLANK			0x13
+#define VIDEO_EXT_VDELAY			0x14
+#define VIDEO_EXT_VDURATION			0x15
+
+#define AUDIO_CTRL1					0x35
+	enum {
+		CTS_SOURCE_INTERNAL = 0,
+		CTS_SOURCE_EXTERNAL
+	};
+	#define v_CTS_SOURCE(n)			(n << 7)
+	enum {
+		DOWNSAMPLE_DISABLE = 0,
+		DOWNSAMPLE_1_2,
+		DOWNSAMPLE_1_4
+	};
+	#define v_DOWN_SAMPLE(n)		(n << 5)
+	enum {
+		AUDIO_SOURCE_IIS = 0,
+		AUDIO_SOURCE_SPDIF
+	};
+	#define v_AUDIO_SOURCE(n)		(n << 3)
+	#define v_MCLK_ENABLE(n)		(n << 2)
+	enum {
+		MCLK_128FS = 0,
+		MCLK_256FS,
+		MCLK_384FS,
+		MCLK_512FS
+	};
+	#define v_MCLK_RATIO(n)			(n)
+	
+#define AUDIO_SAMPLE_RATE			0x37
+	enum {
+		AUDIO_32K	= 0x3,
+		AUDIO_441K	= 0x0,
+		AUDIO_48K	= 0x2,
+		AUDIO_882K	= 0x8,
+		AUDIO_96K	= 0xa,
+		AUDIO_1764K	= 0xc,
+		AUDIO_192K	= 0xe,
+	};
+
+#define AUDIO_I2S_MODE				0x38
+	enum {
+		I2S_CHANNEL_1_2 = 1,
+		I2S_CHANNEL_3_4 = 3,
+		I2S_CHANNEL_5_6 = 7,
+		I2S_CHANNEL_7_8 = 0xf
+	};
+	#define v_I2S_CHANNEL(n)		((n) << 2)
+	enum {
+		I2S_STANDARD = 0,
+		I2S_LEFT_JUSTIFIED,
+		I2S_RIGHT_JUSTIFIED
+	};
+	#define v_I2S_MODE(n)				(n)
+
+#define AUDIO_I2S_MAP				0x39
+#define AUDIO_I2S_SWAPS_SPDIF		0x3a
+	#define v_SPIDF_FREQ(n)			(n)	
+
+#define N_32K 		0x1000
+#define N_441K 		0x1880
+#define N_882K 		0x3100
+#define N_1764K 	0x6200
+#define N_48K 		0x1800
+#define N_96K		0x3000
+#define N_192K 		0x6000
+
+#define AUDIO_N_H					0x3f
+#define AUDIO_N_M					0x40
+#define AUDIO_N_L					0x41
+
+#define AUDIO_CTS_H					0x45
+#define AUDIO_CTS_M					0x46
+#define AUDIO_CTS_L					0x47
+
+
+#define DDC_CLK_L					0x4b
+#define DDC_CLK_H					0x4c
+
+#define EDID_SEGMENT_POINTER	0x4d
+#define EDID_WORD_ADDR			0x4e
+#define EDID_FIFO_OFFSET		0x4f
+#define EDID_FIFO_ADDR			0x50
+
+/* CONTROL_PACKET_BUF_INDEX */
+#define CONTROL_PACKET_BUF_INDEX	0x9f
+enum {
+	INFOFRAME_AVI = 0x06,
+	INFOFRAME_AAI = 0x08
+};
+#define CONTROL_PACKET_ADDR			0xa0
+
+
+#define SIZE_AVI_INFOFRAME			0x11	// 14 bytes
+#define SIZE_AUDIO_INFOFRAME		0x0F	// 15 bytes
+enum {
+	AVI_COLOR_MODE_RGB = 0,
+	AVI_COLOR_MODE_YCBCR422,
+	AVI_COLOR_MODE_YCBCR444
+};
+enum {
+	AVI_COLORIMETRY_NO_DATA = 0,
+	AVI_COLORIMETRY_SMPTE_170M,
+	AVI_COLORIMETRY_ITU709,
+	AVI_COLORIMETRY_EXTENDED
+};
+enum {
+	AVI_CODED_FRAME_ASPECT_NO_DATA,
+	AVI_CODED_FRAME_ASPECT_4_3,
+	AVI_CODED_FRAME_ASPECT_16_9
+};
+enum {
+	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
+	ACTIVE_ASPECT_RATE_4_3,
+	ACTIVE_ASPECT_RATE_16_9,
+	ACTIVE_ASPECT_RATE_14_9
+};
+
+#define HDCP_CTRL				0x52
+	#define m_HDMI_DVI			(1 << 1)
+	#define v_HDMI_DVI(n)		(n << 1)
+
+#define INTERRUPT_MASK1			0xc0
+#define INTERRUPT_STATUS1		0xc1
+	#define m_INT_HOTPLUG		(1 << 7)
+	#define	m_INT_ACTIVE_VSYNC	(1 << 6)
+	#define m_INT_EDID_READY	(1 << 2)
+	
+#define INTERRUPT_MASK2			0xc2
+#define INTERRUPT_STATUS2		0xc3
+	#define m_INT_HDCP_ERR		(1 << 7)
+	#define m_INT_BKSV_FLAG		(1 << 6)
+	#define m_INT_HDCP_OK		(1 << 4)
+
+#define HDMI_STATUS				0xc8
+	#define m_HOTPLUG	(1 << 7)
+	#define m_DDC_SDA	(1 << 5)
+	#define m_DDC_SDC	(1 << 4)
+
+#define PHY_SYNC				0xce		//sync phy parameter				
+
+#define PHY_DRIVER				0xe1
+	#define v_MAIN_DRIVER(n)	(n << 4)
+	#define v_PRE_DRIVER(n)		(n << 2)
+	#define v_TX_ENABLE(n)		(n << 1)
+	
+#define PHY_PRE_EMPHASIS		0xe2
+	#define v_PRE_EMPHASIS(n)	(n << 4)
+	#define v_TMDS_PWRDOWN(n)	(n)
+	
+#define PHY_PLL_TEST			0xe3
+#define PHY_BANDGAP_PWR			0xe4
+	#define v_BANDGAP_PWR_DOWN	0x03
+	#define v_BANDGAP_PWR_UP	0
+	
+#define PHY_PLL_CTRL			0xe5
+	#define v_PLL_DISABLE(n)	(n << 4)
+	#define v_PLL_RESET(n)		(n << 3)
+	#define v_TMDS_RESET(n)		(n << 2)
+			
+#define PHY_PLL_LDO_PWR			0xe7
+	#define v_LDO_PWR_DOWN(n)	(n << 2)
+		
+#endif
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/hdcp/Kconfig b/drivers/video/rockchip/hdmi/hdcp/Kconfig
deleted file mode 100755
index 1bb3c3a..0000000
--- a/drivers/video/rockchip/hdmi/hdcp/Kconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-config HDCP_RK30
-	bool "RK30 HDCP support"
-        depends on LCDC_RK30 && HDMI_RK30
-        default n
-	help
-	  HDCP Interface. This adds the High Definition Content Protection Interface.
-	  See http://www.digital-cp.com/ for HDCP specification.
-
-config HDCP_RK30_DEBUG
-	bool "RK30 HDCP Debugging"
-        depends on HDCP_RK30
-        default n
-	help
-	  Enableds verbose debugging the the HDCP drivers
diff --git a/drivers/video/rockchip/hdmi/hdcp/Makefile b/drivers/video/rockchip/hdmi/hdcp/Makefile
deleted file mode 100755
index 108b67c..0000000
--- a/drivers/video/rockchip/hdmi/hdcp/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-# Makefile for HDCP linux kernel module.
-#
-
-ccflags-$(CONFIG_HDCP_RK30_DEBUG) = -DDEBUG -DHDCP_DEBUG
-
-obj-$(CONFIG_HDCP_RK30) += hdcp.o
-hdcp-y := rk30_hdcp.o rk30_hdmi_hdcp.o
diff --git a/drivers/video/rockchip/hdmi/hdcp/rk30_hdcp.c b/drivers/video/rockchip/hdmi/hdcp/rk30_hdcp.c
deleted file mode 100755
index 68d0ac8..0000000
--- a/drivers/video/rockchip/hdmi/hdcp/rk30_hdcp.c
+++ /dev/null
@@ -1,570 +0,0 @@
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/miscdevice.h>
-#include <linux/workqueue.h>
-#include <linux/firmware.h>
-#include "../rk30_hdmi.h"
-#include "../rk30_hdmi_hw.h"
-#include "rk30_hdmi_hdcp.h"
-
-struct hdcp *hdcp = NULL;
-
-static void hdcp_work_queue(struct work_struct *work);
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_submit_work
- *-----------------------------------------------------------------------------
- */
-static struct delayed_work *hdcp_submit_work(int event, int delay)
-{
-	struct hdcp_delayed_work *work;
-
-	DBG("%s event %04x delay %d", __FUNCTION__, event, delay);
-	
-	work = kmalloc(sizeof(struct hdcp_delayed_work), GFP_ATOMIC);
-
-	if (work) {
-		INIT_DELAYED_WORK(&work->work, hdcp_work_queue);
-		work->event = event;
-		queue_delayed_work(hdcp->workqueue,
-				   &work->work,
-				   msecs_to_jiffies(delay));
-	} else {
-		printk(KERN_WARNING "HDCP: Cannot allocate memory to "
-				    "create work\n");
-		return 0;
-	}
-
-	return &work->work;
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_cancel_work
- *-----------------------------------------------------------------------------
- */
-static void hdcp_cancel_work(struct delayed_work **work)
-{
-	int ret = 0;
-
-	if (*work) {
-		ret = cancel_delayed_work(*work);
-		if (ret != 1) {
-			ret = cancel_work_sync(&((*work)->work));
-			printk(KERN_INFO "Canceling work failed - "
-					 "cancel_work_sync done %d\n", ret);
-		}
-		kfree(*work);
-		*work = 0;
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_authentication_failure
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_authentication_failure(void)
-{
-	if (hdcp->hdmi_state == HDMI_STOPPED) {
-		return;
-	}
-
-	rk30_hdcp_disable();
-	rk30_hdmi_control_output(false);
-	
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-
-	if (hdcp->retry_cnt && (hdcp->hdmi_state != HDMI_STOPPED)) {
-		if (hdcp->retry_cnt < HDCP_INFINITE_REAUTH) {
-			hdcp->retry_cnt--;
-			printk(KERN_INFO "HDCP: authentication failed - "
-					 "retrying, attempts=%d\n",
-							hdcp->retry_cnt);
-		} else
-			printk(KERN_INFO "HDCP: authentication failed - "
-					 "retrying\n");
-
-		hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
-
-		hdcp->pending_wq_event = hdcp_submit_work(HDCP_AUTH_REATT_EVENT,
-							 HDCP_REAUTH_DELAY);
-	} else {
-		printk(KERN_INFO "HDCP: authentication failed - "
-				 "HDCP disabled\n");
-		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-	}
-
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_start_authentication
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_start_authentication(void)
-{
-	int status = HDCP_OK;
-
-	hdcp->hdcp_state = HDCP_AUTHENTICATION_START;
-
-	DBG("HDCP: authentication start");
-
-	status = rk30_hdcp_start_authentication();
-
-	if (status != HDCP_OK) {
-		DBG("HDCP: authentication failed");
-		hdcp_wq_authentication_failure();
-	} else {
-		hdcp->hdcp_state = HDCP_WAIT_KSV_LIST;
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_check_bksv
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_check_bksv(void)
-{
-	int status = HDCP_OK;
-
-	DBG("Check BKSV start");
-	
-	status = rk30_hdcp_check_bksv();
-
-	if (status != HDCP_OK) {
-		printk(KERN_INFO "HDCP: Check BKSV failed");
-		hdcp->retry_cnt = 0;
-		hdcp_wq_authentication_failure();
-	}
-	else {
-		DBG("HDCP: Check BKSV successful");
-
-		hdcp->hdcp_state = HDCP_LINK_INTEGRITY_CHECK;
-
-		/* Restore retry counter */
-		if(hdcp->retry_times == 0)
-			hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-		else
-			hdcp->retry_cnt = hdcp->retry_times;
-	}
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_authentication_sucess
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_authentication_sucess(void)
-{
-	printk(KERN_INFO "HDCP: authentication pass");
-	rk30_hdmi_control_output(true);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_wq_disable
- *-----------------------------------------------------------------------------
- */
-static void hdcp_wq_disable(int event)
-{
-	printk(KERN_INFO "HDCP: disabled");
-
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-	rk30_hdcp_disable();
-	if(event == HDCP_DISABLE_CTL) {
-		hdcp->hdcp_state = HDCP_DISABLED;
-		if(hdcp->hdmi_state == HDMI_STARTED)
-			rk30_hdmi_control_output(true);			
-	}
-	else if(event == HDCP_STOP_FRAME_EVENT)
-		hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_work_queue
- *-----------------------------------------------------------------------------
- */
-static void hdcp_work_queue(struct work_struct *work)
-{
-	struct hdcp_delayed_work *hdcp_w =
-		container_of(work, struct hdcp_delayed_work, work.work);
-	int event = hdcp_w->event;
-
-	mutex_lock(&hdcp->lock);
-	
-	DBG("hdcp_work_queue() - START - %u hdmi=%d hdcp=%d evt= %x %d",
-		jiffies_to_msecs(jiffies),
-		hdcp->hdmi_state,
-		hdcp->hdcp_state,
-		(event & 0xFF00) >> 8,
-		event & 0xFF);
-	
-	if(event == HDCP_STOP_FRAME_EVENT) {
-		hdcp->hdmi_state = HDMI_STOPPED;
-	}
-	
-	if (event == HDCP_DISABLE_CTL || event == HDCP_STOP_FRAME_EVENT) {
-		hdcp_wq_disable(event);
-	}
-	
-	if (event & HDCP_WORKQUEUE_SRC)
-		hdcp->pending_wq_event = 0;
-	
-	/* First handle HDMI state */
-	if (event == HDCP_START_FRAME_EVENT) {
-		hdcp->pending_start = 0;
-		hdcp->hdmi_state = HDMI_STARTED;
-	}
-	
-	/**********************/
-	/* HDCP state machine */
-	/**********************/
-	switch (hdcp->hdcp_state) {
-		case HDCP_DISABLED:
-			/* HDCP enable control or re-authentication event */
-			if (event == HDCP_ENABLE_CTL) {
-				if(hdcp->retry_times == 0)
-					hdcp->retry_cnt = HDCP_INFINITE_REAUTH;
-				else
-					hdcp->retry_cnt = hdcp->retry_times;
-				if (hdcp->hdmi_state == HDMI_STARTED)
-					hdcp_wq_start_authentication();
-				else
-					hdcp->hdcp_state = HDCP_ENABLE_PENDING;
-			}
-			break;
-		
-		case HDCP_ENABLE_PENDING:
-			/* HDMI start frame event */
-			if (event == HDCP_START_FRAME_EVENT)
-				hdcp_wq_start_authentication();
-
-			break;
-		
-		case HDCP_AUTHENTICATION_START:
-			/* Re-authentication */
-			if (event == HDCP_AUTH_REATT_EVENT)
-				hdcp_wq_start_authentication();
-	
-			break;
-		
-		case HDCP_WAIT_KSV_LIST:
-			/* KSV failure */
-			if (event == HDCP_FAIL_EVENT) {
-				printk(KERN_INFO "HDCP: KSV switch failure\n");
-	
-				hdcp_wq_authentication_failure();
-			}
-			/* KSV list ready event */
-			else if (event == HDCP_KSV_LIST_RDY_EVENT)
-				hdcp_wq_check_bksv();
-			break;
-		
-		case HDCP_LINK_INTEGRITY_CHECK:
-			/* Ri failure */
-			if (event == HDCP_FAIL_EVENT) {
-				printk(KERN_INFO "HDCP: Ri check failure\n");
-				hdcp_wq_authentication_failure();
-			}
-			else if(event == HDCP_AUTH_PASS_EVENT)
-				hdcp_wq_authentication_sucess();
-			break;
-	
-		default:
-			printk(KERN_WARNING "HDCP: error - unknow HDCP state\n");
-			break;
-	}
-	
-	kfree(hdcp_w);
-	if(event == HDCP_STOP_FRAME_EVENT)
-		complete(&hdcp->complete);
-		
-	mutex_unlock(&hdcp->lock);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_start_frame_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_start_frame_cb(void)
-{
-	DBG("hdcp_start_frame_cb()");
-
-	/* Cancel any pending work */
-	if (hdcp->pending_start)
-		hdcp_cancel_work(&hdcp->pending_start);
-	if (hdcp->pending_wq_event)
-		hdcp_cancel_work(&hdcp->pending_wq_event);
-
-	hdcp->pending_start = hdcp_submit_work(HDCP_START_FRAME_EVENT,
-							HDCP_ENABLE_DELAY);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_irq_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_irq_cb(int interrupt)
-{
-	int value;
-	DBG("%s 0x%x", __FUNCTION__, interrupt);
-	if(interrupt & m_INT_HDCP_ERR)
-	{
-		value = HDMIRdReg(HDCP_ERROR);
-		HDMIWrReg(HDCP_ERROR, value);
-		printk(KERN_INFO "HDCP: Error 0x%02x\n", value);
-		
-		if( (hdcp->hdcp_state != HDCP_DISABLED) &&
-			(hdcp->hdcp_state != HDCP_ENABLE_PENDING) )
-		{	
-			hdcp_submit_work(HDCP_FAIL_EVENT, 0);
-		}
-	}
-	else if(interrupt & (m_INT_BKSV_RPRDY | m_INT_BKSV_RCRDY))
-		hdcp_submit_work(HDCP_KSV_LIST_RDY_EVENT, 0);
-	else if(interrupt & m_INT_AUTH_DONE)
-		hdcp_submit_work(HDCP_AUTH_PASS_EVENT, 0);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_power_on_cb
- *-----------------------------------------------------------------------------
- */
-static int hdcp_power_on_cb(void)
-{
-	DBG("%s", __FUNCTION__);
-	return rk30_hdcp_load_key2mem(hdcp->keys);
-}
-
-/*-----------------------------------------------------------------------------
- * Function: hdcp_power_off_cb
- *-----------------------------------------------------------------------------
- */
-static void hdcp_power_off_cb(void)
-{
-	DBG("%s", __FUNCTION__);
-	if(!hdcp->enable)
-		return;
-	
-	hdcp_cancel_work(&hdcp->pending_start);
-	hdcp_cancel_work(&hdcp->pending_wq_event);
-	init_completion(&hdcp->complete);
-	/* Post event to workqueue */
-	if (hdcp_submit_work(HDCP_STOP_FRAME_EVENT, 0))	
-		wait_for_completion_interruptible_timeout(&hdcp->complete,
-							msecs_to_jiffies(2000));
-}
-
-// Load HDCP key to external HDCP memory
-static void hdcp_load_keys_cb(const struct firmware *fw, void *context)
-{
-	if (!fw) {
-		pr_err("HDCP: failed to load keys\n");
-		return;
-	}
-	
-	if(fw->size < HDCP_KEY_SIZE) {
-		pr_err("HDCP: firmware wrong size %d\n", fw->size);
-		return;
-	}
-	
-	hdcp->keys =  kmalloc(HDCP_KEY_SIZE, GFP_KERNEL);
-	if(hdcp->keys == NULL) {
-		pr_err("HDCP: can't allocated space for keys\n");
-		return;
-	}
-	
-	memcpy(hdcp->keys, fw->data, HDCP_KEY_SIZE);
-	
-	rk30_hdcp_load_key2mem(hdcp->keys);
-	printk(KERN_INFO "HDCP: loaded hdcp key success\n");
-
-	if(fw->size > HDCP_KEY_SIZE) {
-		DBG("%s invalid key size %d", __FUNCTION__, fw->size - HDCP_KEY_SIZE);
-		if((fw->size - HDCP_KEY_SIZE) % 5) {
-			pr_err("HDCP: failed to load invalid keys\n");
-			return;
-		}
-		hdcp->invalidkeys = kmalloc(fw->size - HDCP_KEY_SIZE, GFP_KERNEL);
-		if(hdcp->invalidkeys == NULL) {
-			pr_err("HDCP: can't allocated space for invalid keys\n");
-			return;
-		}
-		memcpy(hdcp->invalidkeys, fw->data + HDCP_KEY_SIZE, fw->size - HDCP_KEY_SIZE);
-		hdcp->invalidkey = (fw->size - HDCP_KEY_SIZE)/5;
-		printk(KERN_INFO "HDCP: loaded hdcp invalid key success\n");
-	}
-}
-
-static ssize_t hdcp_enable_read(struct device *device,
-			    struct device_attribute *attr, char *buf)
-{
-	int enable = 0;
-	
-	if(hdcp)
-		enable = hdcp->enable;
-		
-	return snprintf(buf, PAGE_SIZE, "%d\n", enable);
-}
-
-static ssize_t hdcp_enable_write(struct device *device,
-			   struct device_attribute *attr, const char *buf, size_t count)
-{
-	int enable;
-
-	if(hdcp == NULL)
-		return -EINVAL;
-	
-	sscanf(buf, "%d", &enable);
-	if(hdcp->enable != enable)
-	{
-		/* Post event to workqueue */
-		if(enable) {
-			if (hdcp_submit_work(HDCP_ENABLE_CTL, 0) == 0)
-				return -EFAULT;
-		}
-		else {
-			hdcp_cancel_work(&hdcp->pending_start);
-			hdcp_cancel_work(&hdcp->pending_wq_event);
-		
-			/* Post event to workqueue */
-			if (hdcp_submit_work(HDCP_DISABLE_CTL, 0) == 0)
-				return -EFAULT;
-		}
-		hdcp->enable = 	enable;
-	}
-	return count;
-}
-
-static DEVICE_ATTR(enable, S_IRUGO|S_IWUSR, hdcp_enable_read, hdcp_enable_write);
-
-static ssize_t hdcp_trytimes_read(struct device *device,
-			    struct device_attribute *attr, char *buf)
-{
-	int trytimes = 0;
-	
-	if(hdcp)
-		trytimes = hdcp->retry_times;
-		
-	return snprintf(buf, PAGE_SIZE, "%d\n", trytimes);
-}
-
-static ssize_t hdcp_trytimes_wrtie(struct device *device,
-			   struct device_attribute *attr, const char *buf, size_t count)
-{
-	int trytimes;
-
-	if(hdcp == NULL)
-		return -EINVAL;
-	
-	sscanf(buf, "%d", &trytimes);
-	if(hdcp->retry_times != trytimes)
-		hdcp->retry_times = trytimes;
-	
-	return count;
-}
-
-
-static DEVICE_ATTR(trytimes, S_IRUGO|S_IWUSR, hdcp_trytimes_read, hdcp_trytimes_wrtie);
-
-
-static struct miscdevice mdev;
-
-static int __init rk30_hdcp_init(void)
-{
-	int ret;
-	
-	DBG("[%s] %u", __FUNCTION__, jiffies_to_msecs(jiffies));
-	
-	hdcp = kmalloc(sizeof(struct hdcp), GFP_KERNEL);
-	if(!hdcp)
-	{
-    	printk(KERN_ERR ">>HDCP: kmalloc fail!");
-    	ret = -ENOMEM;
-    	goto error0; 
-	}
-	memset(hdcp, 0, sizeof(struct hdcp));
-	mutex_init(&hdcp->lock);
-	
-	mdev.minor = MISC_DYNAMIC_MINOR;
-	mdev.name = "hdcp";
-	mdev.mode = 0666;
-	if (misc_register(&mdev)) {
-		printk(KERN_ERR "HDCP: Could not add character driver\n");
-		ret = HDMI_ERROR_FALSE;
-		goto error1;
-	}
-	ret = device_create_file(mdev.this_device, &dev_attr_enable);
-    if(ret)
-    {
-        printk(KERN_ERR "HDCP: Could not add sys file enable\n");
-        ret = -EINVAL;
-        goto error2;
-    }
-    
-    ret = device_create_file(mdev.this_device, &dev_attr_trytimes);
-    if(ret)
-    {
-        printk(KERN_ERR "HDCP: Could not add sys file trytimes\n");
-        ret = -EINVAL;
-        goto error3;
-    }
-    
-    hdcp->workqueue = create_singlethread_workqueue("hdcp");
-	if (hdcp->workqueue == NULL) {
-		printk(KERN_ERR "HDCP,: create workqueue failed.\n");
-		goto error4;
-	}
-    
-    
-    ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG,
-			      "hdcp.keys", mdev.this_device, GFP_KERNEL,
-			      hdcp, hdcp_load_keys_cb);
-	if (ret < 0) {
-		printk(KERN_ERR "HDCP: request_firmware_nowait failed: %d\n", ret);
-		goto error5;
-	}
-	
-	rk30_hdmi_register_hdcp_callbacks(	hdcp_start_frame_cb,
-										hdcp_irq_cb,
-										hdcp_power_on_cb,
-										hdcp_power_off_cb);
-										
-	DBG("%s success %u", __FUNCTION__, jiffies_to_msecs(jiffies));
-	return 0;
-	
-error5:
-	destroy_workqueue(hdcp->workqueue);
-error4:
-	device_remove_file(mdev.this_device, &dev_attr_trytimes);
-error3:
-	device_remove_file(mdev.this_device, &dev_attr_enable);
-error2:
-	misc_deregister(&mdev);
-error1:
-	if(hdcp->keys)
-		kfree(hdcp->keys);
-	if(hdcp->invalidkeys)
-		kfree(hdcp->invalidkeys);
-	kfree(hdcp);
-error0:
-	return ret;
-}
-
-static void __exit rk30_hdcp_exit(void)
-{
-	if(hdcp) {
-		mutex_lock(&hdcp->lock);
-		rk30_hdmi_register_hdcp_callbacks(0, 0, 0, 0);
-		device_remove_file(mdev.this_device, &dev_attr_enable);
-		misc_deregister(&mdev);
-		destroy_workqueue(hdcp->workqueue);
-		if(hdcp->keys)
-			kfree(hdcp->keys);
-		if(hdcp->invalidkeys)
-			kfree(hdcp->invalidkeys);
-		mutex_unlock(&hdcp->lock);
-		kfree(hdcp);
-	}
-}
-
-module_init(rk30_hdcp_init);
-module_exit(rk30_hdcp_exit);
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.c b/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.c
deleted file mode 100755
index 1184989..0000000
--- a/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.c
+++ /dev/null
@@ -1,157 +0,0 @@
-#include <linux/delay.h>
-#include <asm/io.h>
-#include <mach/io.h>
-#include "../rk30_hdmi.h"
-#include "../rk30_hdmi_hw.h"
-#include "rk30_hdmi_hdcp.h"
-
-static void rk30_hdcp_write_mem(int addr_8, char value)
-{
-	int temp;
-	int addr_32 = addr_8 - addr_8%4;
-	int shift = (addr_8%4) * 8;
-	
-	temp = HDMIRdReg(addr_32);
-	temp &= ~(0xff << shift);
-	temp |= value << shift;
-//	printk("temp is %08x\n", temp);
-	HDMIWrReg(addr_32, temp);
-}
-
-int rk30_hdcp_load_key2mem(struct hdcp_keys *key)
-{
-	int i;
-	
-	if(key == NULL)	return	HDMI_ERROR_FALSE;
-	
-	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV);
-	
-	for(i = 0; i < 7; i++)
-		rk30_hdcp_write_mem(HDCP_RAM_KEY_KSV1 + i, key->KSV[i]);
-	for(i = 0; i < 7; i++)
-		rk30_hdcp_write_mem(HDCP_RAM_KEY_KSV2 + i, key->KSV[i]);
-	for(i = 0; i < HDCP_PRIVATE_KEY_SIZE; i++)
-		rk30_hdcp_write_mem(HDCP_RAM_KEY_PRIVATE + i, key->DeviceKey[i]);
-	for(i = 0; i < HDCP_KEY_SHA_SIZE; i++)
-		rk30_hdcp_write_mem(HDCP_RAM_KEY_PRIVATE + HDCP_PRIVATE_KEY_SIZE + i, key->sha1[i]);
-	
-	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV | 0x20);
-	return HDCP_OK;
-}
-
-void rk30_hdcp_disable(void)
-{
-	int temp;
-	// Diable HDCP Interrupt
-	HDMIWrReg(INTR_MASK2, 0x00);
-	// Stop and Reset HDCP
-	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_FRAMED_ENCRYPED | m_HDCP_AUTH_STOP | m_HDCP_RESET, 
-		v_HDCP_FRAMED_ENCRYPED(0) | v_HDCP_AUTH_STOP(1) | v_HDCP_RESET(1) );
-}
-
-static int rk30_hdcp_load_key(void)
-{
-	int value, temp = 0;
-	
-	if(hdcp->keys == NULL) {
-		pr_err("[%s] HDCP key not loaded.\n", __FUNCTION__);
-		return HDCP_KEY_ERR;
-	}
-	
-	value = HDMIRdReg(HDCP_KEY_MEM_CTRL);
-	//Check HDCP key loaded from external HDCP memory
-	while((value & (m_KSV_VALID | m_KEY_VALID | m_KEY_READY)) != (m_KSV_VALID | m_KEY_VALID | m_KEY_READY)) {
-		if(temp > 10) {
-			pr_err("[%s] loaded hdcp key is incorrectable %02x\n", __FUNCTION__, value & 0xFF);
-			return HDCP_KEY_ERR;
-		}
-		//Load HDCP Key from external HDCP memory
-		HDMIWrReg(HDCP_KEY_ACCESS_CTRL2, m_LOAD_HDCP_KEY);
-		msleep(1);
-		value = HDMIRdReg(HDCP_KEY_MEM_CTRL);
-		temp++;
-	}
-	
-	return HDCP_OK;
-}
-
-
-int rk30_hdcp_start_authentication(void)
-{
-	int rc, temp;
-	
-	rc = rk30_hdcp_load_key();
-	if(rc != HDCP_OK)
-		return rc;
-	
-	// Set 100ms & 5 sec timer
-	switch(hdmi->vic)
-	{
-		case HDMI_720x576p_50Hz_4_3:
-		case HDMI_720x576p_50Hz_16_9:
-		case HDMI_1280x720p_50Hz:
-		case HDMI_1920x1080i_50Hz:
-		case HDMI_720x576i_50Hz_4_3:
-		case HDMI_720x576i_50Hz_16_9:
-		case HDMI_1920x1080p_50Hz:
-			HDMIWrReg(HDCP_TIMER_100MS, 5);
-			HDMIWrReg(HDCP_TIMER_5S, 250);
-			break;
-		
-		default:
-			HDMIWrReg(HDCP_TIMER_100MS, 0x26);
-			HDMIWrReg(HDCP_TIMER_5S, 0x2c);
-			break;
-	}
-	// Config DDC Clock
-	temp = (hdmi->tmdsclk/HDCP_DDC_CLK)/4;
-	HDMIWrReg(DDC_BUS_FREQ_L, temp & 0xFF);
-	HDMIWrReg(DDC_BUS_FREQ_H, (temp >> 8) & 0xFF);
-	// Enable HDCP Interrupt
-	HDMIWrReg(INTR_MASK2, m_INT_HDCP_ERR | m_INT_BKSV_RPRDY | m_INT_BKSV_RCRDY | m_INT_AUTH_DONE | m_INT_AUTH_READY);
-	// Start HDCP
-	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_AUTH_START | m_HDCP_FRAMED_ENCRYPED, v_HDCP_AUTH_START(1) | v_HDCP_FRAMED_ENCRYPED(0));
-	
-	return HDCP_OK;
-}
-
-int rk30_hdcp_check_bksv(void)
-{
-	int i, temp;
-	char bksv[5];
-	char *invalidkey;
-	
-	temp = HDMIRdReg(HDCP_BCAPS);
-	DBG("Receiver capacity is 0x%02x", temp);
-	
-#ifdef DEBUG	
-	if(temp & m_HDMI_RECEIVED)
-		DBG("Receiver support HDMI");
-	if(temp & m_REPEATER)
-		DBG("Receiver is a repeater");
-	if(temp & m_DDC_FAST)
-		DBG("Receiver support 400K DDC");
-	if(temp & m_1_1_FEATURE)
-		DBG("Receiver support 1.1 features, such as advanced cipher, EESS.");
-	if(temp & m_FAST_REAUTHENTICATION)
-		DBG("Receiver support fast reauthentication.");
-#endif
-		
-	for(i = 0; i < 5; i++) {
-		bksv[i] = HDMIRdReg(HDCP_KSV_BYTE0 + (4 - i)*4) & 0xFF;
-	}
-	
-	DBG("bksv is 0x%02x%02x%02x%02x%02x", bksv[0], bksv[1], bksv[2], bksv[3], bksv[4]);
-	
-	for(i = 0; i < hdcp->invalidkey; i++)
-	{
-		invalidkey = hdcp->invalidkeys + i *5;
-		if(memcmp(bksv, invalidkey, 5) == 0) {
-			printk(KERN_ERR "HDCP: BKSV was revocated!!!\n");
-			HDMIMskReg(temp, HDCP_CTRL, m_HDCP_BKSV_FAILED | m_HDCP_FRAMED_ENCRYPED, v_HDCP_BKSV_FAILED(1) | v_HDCP_FRAMED_ENCRYPED(0));
-			return HDCP_KSV_ERR;
-		}
-	}
-	HDMIMskReg(temp, HDCP_CTRL, m_HDCP_BKSV_PASS | m_HDCP_FRAMED_ENCRYPED, v_HDCP_BKSV_PASS(1) | v_HDCP_FRAMED_ENCRYPED(1));
-	return HDCP_OK;
-}
diff --git a/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.h b/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.h
deleted file mode 100755
index 0224d88..0000000
--- a/drivers/video/rockchip/hdmi/hdcp/rk30_hdmi_hdcp.h
+++ /dev/null
@@ -1,99 +0,0 @@
-#ifndef __RK30_HDMI_HDCP_H__
-#define __RK30_HDMI_HDCP_H__
-
-/***************************/
-/* Definitions             */
-/***************************/
-
-/* Status / error codes */
-#define HDCP_OK			0
-#define HDCP_KEY_ERR	1
-#define HDCP_KSV_ERR	2
-
-/* Delays */
-#define HDCP_ENABLE_DELAY	300
-#define HDCP_REAUTH_DELAY	100
-
-/* Event source */
-#define HDCP_SRC_SHIFT		8
-#define HDCP_IOCTL_SRC		(0x1 << HDCP_SRC_SHIFT)
-#define HDCP_HDMI_SRC		(0x2 << HDCP_SRC_SHIFT)
-#define HDCP_IRQ_SRC		(0x4 << HDCP_SRC_SHIFT)
-#define HDCP_WORKQUEUE_SRC	(0x8 << HDCP_SRC_SHIFT)
-
-/* Event */
-#define HDCP_ENABLE_CTL			(HDCP_IOCTL_SRC		| 0)
-#define HDCP_DISABLE_CTL		(HDCP_IOCTL_SRC		| 1)
-#define HDCP_START_FRAME_EVENT	(HDCP_HDMI_SRC		| 2)
-#define HDCP_STOP_FRAME_EVENT	(HDCP_HDMI_SRC		| 3)
-#define HDCP_KSV_LIST_RDY_EVENT	(HDCP_IRQ_SRC		| 4)
-#define HDCP_FAIL_EVENT			(HDCP_IRQ_SRC		| 5)
-#define HDCP_AUTH_PASS_EVENT	(HDCP_IRQ_SRC		| 6)
-#define HDCP_AUTH_REATT_EVENT	(HDCP_WORKQUEUE_SRC	| 7)
-
-/* Key size */
-#define HDCP_KEY_SIZE			308	
-
-/* Authentication retry times */
-#define HDCP_INFINITE_REAUTH	0x100
-
-enum hdcp_states {
-	HDCP_DISABLED,
-	HDCP_ENABLE_PENDING,
-	HDCP_AUTHENTICATION_START,
-	HDCP_WAIT_KSV_LIST,
-	HDCP_LINK_INTEGRITY_CHECK,
-};
-
-enum hdmi_states {
-	HDMI_STOPPED,
-	HDMI_STARTED
-};
-
-#define HDCP_PRIVATE_KEY_SIZE	280
-#define HDCP_KEY_SHA_SIZE		20
-#define HDCP_DDC_CLK			100000
-
-struct hdcp_keys{
-	u8 KSV[8];
-	u8 DeviceKey[HDCP_PRIVATE_KEY_SIZE];
-	u8 sha1[HDCP_KEY_SHA_SIZE];
-};
-
-struct hdcp_delayed_work {
-	struct delayed_work work;
-	int event;
-};
-
-struct hdcp {
-	int	enable;
-	int retry_times;
-	struct hdcp_keys *keys;
-	int invalidkey;
-	char *invalidkeys;	
-	struct mutex lock;
-	struct completion	complete;
-	struct workqueue_struct *workqueue;
-	
-	enum hdmi_states hdmi_state;
-	enum hdcp_states hdcp_state;
-	
-	struct delayed_work *pending_start;
-	struct delayed_work *pending_wq_event;
-	int retry_cnt;
-};
-
-extern struct hdcp *hdcp;
-
-#ifdef HDCP_DEBUG
-#define DBG(format, ...) \
-		printk(KERN_INFO "HDCP: " format "\n", ## __VA_ARGS__)
-#else
-#define DBG(format, ...)
-#endif
-
-extern void rk30_hdcp_disable(void);
-extern int	rk30_hdcp_start_authentication(void);
-extern int	rk30_hdcp_check_bksv(void);
-extern int	rk30_hdcp_load_key2mem(struct hdcp_keys *key);
-#endif /* __RK30_HDMI_HDCP_H__ */
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi.c b/drivers/video/rockchip/hdmi/rk30_hdmi.c
deleted file mode 100755
index 0aae519..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi.c
+++ /dev/null
@@ -1,299 +0,0 @@
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/clk.h>
-
-#include <mach/board.h>
-#include <mach/io.h>
-#include <mach/gpio.h>
-#include <mach/iomux.h>
-#include "rk30_hdmi.h"
-#include "rk30_hdmi_hw.h"
-
-struct hdmi *hdmi = NULL;
-
-extern irqreturn_t hdmi_irq(int irq, void *priv);
-extern void hdmi_work(struct work_struct *work);
-extern struct rk_lcdc_device_driver * rk_get_lcdc_drv(char *name);
-extern void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent);
-extern void hdmi_unregister_display_sysfs(struct hdmi *hdmi);
-
-int rk30_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
-					 void (*hdcp_irq_cb)(int status),
-					 int (*hdcp_power_on_cb)(void),
-					 void (*hdcp_power_off_cb)(void))
-{
-	if(hdmi == NULL)
-		return HDMI_ERROR_FALSE;
-
-	hdmi->hdcp_cb = hdcp_cb;
-	hdmi->hdcp_irq_cb = hdcp_irq_cb;
-	hdmi->hdcp_power_on_cb = hdcp_power_on_cb;
-	hdmi->hdcp_power_off_cb = hdcp_power_off_cb;
-	
-	return HDMI_ERROR_SUCESS;
-}
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-static void hdmi_early_suspend(struct early_suspend *h)
-{
-	hdmi_dbg(hdmi->dev, "hdmi enter early suspend pwr %d state %d\n", hdmi->pwr_mode, hdmi->state);
-	flush_delayed_work(&hdmi->delay_work);	
-	mutex_lock(&hdmi->enable_mutex);
-	hdmi->suspend = 1;
-	if(!hdmi->enable) {
-		mutex_unlock(&hdmi->enable_mutex);
-		return;
-	}
-	disable_irq(hdmi->irq);
-	mutex_unlock(&hdmi->enable_mutex);
-	hdmi->command = HDMI_CONFIG_ENABLE;
-	init_completion(&hdmi->complete);
-	hdmi->wait = 1;
-	queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
-	wait_for_completion_interruptible_timeout(&hdmi->complete,
-							msecs_to_jiffies(5000));
-	flush_delayed_work(&hdmi->delay_work);
-	// When HDMI 1.1V and 2.5V power off, DDC channel will be pull down, current is produced
-	// from VCC_IO which is pull up outside soc. We need to switch DDC IO to GPIO.
-	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_GPIO0A2);
-	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_GPIO0A1);
-	return;
-}
-
-static void hdmi_early_resume(struct early_suspend *h)
-{
-	hdmi_dbg(hdmi->dev, "hdmi exit early resume\n");
-	mutex_lock(&hdmi->enable_mutex);
-	
-	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_HDMI_I2C_SDA);
-	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_HDMI_I2C_SCL);
-	
-	hdmi->suspend = 0;
-	rk30_hdmi_initial();
-	if(hdmi->enable) {
-		enable_irq(hdmi->irq);
-	}
-	mutex_unlock(&hdmi->enable_mutex);
-	return;
-}
-#endif
-
-static inline void hdmi_io_remap(void)
-{
-	unsigned int value;
-	
-	// Remap HDMI IO Pin
-	rk30_mux_api_set(GPIO0A2_HDMII2CSDA_NAME, GPIO0A_HDMI_I2C_SDA);
-	rk30_mux_api_set(GPIO0A1_HDMII2CSCL_NAME, GPIO0A_HDMI_I2C_SCL);
-	rk30_mux_api_set(GPIO0A0_HDMIHOTPLUGIN_NAME, GPIO0A_HDMI_HOT_PLUG_IN);
-		
-	// Select LCDC0 as video source and enabled.
-	value = (HDMI_SOURCE_DEFAULT << 14) | (1 << 30);
-	writel(value, GRF_SOC_CON0 + RK30_GRF_BASE);
-}
-
-static int __devinit rk30_hdmi_probe (struct platform_device *pdev)
-{
-	int ret;
-	struct resource *res;
-	struct resource *mem;
-	
-	hdmi = kmalloc(sizeof(struct hdmi), GFP_KERNEL);
-	if(!hdmi)
-	{
-    	dev_err(&pdev->dev, ">>rk30 hdmi kmalloc fail!");
-    	return -ENOMEM;
-	}
-	memset(hdmi, 0, sizeof(struct hdmi));
-	hdmi->dev = &pdev->dev;
-	platform_set_drvdata(pdev, hdmi);
-
-	if(HDMI_SOURCE_DEFAULT == HDMI_SOURCE_LCDC0)
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc0");
-	else
-		hdmi->lcdc = rk_get_lcdc_drv("lcdc1");
-	if(hdmi->lcdc == NULL)
-	{
-		dev_err(hdmi->dev, "can not connect to video source lcdc\n");
-		ret = -ENXIO;
-		goto err0;
-	}
-	hdmi->xscale = 95;
-	hdmi->yscale = 95;
-	
-	hdmi->hclk = clk_get(NULL,"hclk_hdmi");
-	if(IS_ERR(hdmi->hclk))
-	{
-		dev_err(hdmi->dev, "Unable to get hdmi hclk\n");
-		ret = -ENXIO;
-		goto err0;
-	}
-	clk_enable(hdmi->hclk);
-	
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(hdmi->dev, "Unable to get register resource\n");
-		ret = -ENXIO;
-		goto err0;
-	}
-	hdmi->regbase_phy = res->start;
-	hdmi->regsize_phy = (res->end - res->start) + 1;
-	mem = request_mem_region(res->start, (res->end - res->start) + 1, pdev->name);
-	if (!mem)
-	{
-    	dev_err(hdmi->dev, "failed to request mem region for hdmi\n");
-    	ret = -ENOENT;
-    	goto err0;
-	}
-
-	
-	hdmi->regbase = (int)ioremap(res->start, (res->end - res->start) + 1);
-	if (!hdmi->regbase) {
-		dev_err(hdmi->dev, "cannot ioremap registers\n");
-		ret = -ENXIO;
-		goto err1;
-	}
-	
-	ret = rk30_hdmi_initial();
-	if(ret != HDMI_ERROR_SUCESS)
-		goto err1;
-		
-	hdmi_io_remap();
-	hdmi_sys_init();
-	
-	hdmi->workqueue = create_singlethread_workqueue("hdmi");
-	INIT_DELAYED_WORK(&(hdmi->delay_work), hdmi_work);
-
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-	hdmi->early_suspend.suspend = hdmi_early_suspend;
-	hdmi->early_suspend.resume = hdmi_early_resume;
-	hdmi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - 10;
-	register_early_suspend(&hdmi->early_suspend);
-	#endif
-		
-	hdmi_register_display_sysfs(hdmi, NULL);
-	#ifdef CONFIG_SWITCH
-	hdmi->switch_hdmi.name="hdmi";
-	switch_dev_register(&(hdmi->switch_hdmi));
-	#endif
-		
-	spin_lock_init(&hdmi->irq_lock);
-	mutex_init(&hdmi->enable_mutex);
-	
-	/* get the IRQ */
-	hdmi->irq = platform_get_irq(pdev, 0);
-	if(hdmi->irq <= 0) {
-		dev_err(hdmi->dev, "failed to get hdmi irq resource (%d).\n", hdmi->irq);
-		ret = -ENXIO;
-		goto err2;
-	}
-
-	/* request the IRQ */
-	ret = request_irq(hdmi->irq, hdmi_irq, 0, dev_name(&pdev->dev), hdmi);
-	if (ret)
-	{
-		dev_err(hdmi->dev, "hdmi request_irq failed (%d).\n", ret);
-		goto err2;
-	}
-
-	hdmi_dbg(hdmi->dev, "rk30 hdmi probe sucess.\n");
-	return 0;
-err2:
-	#ifdef CONFIG_SWITCH
-	switch_dev_unregister(&(hdmi->switch_hdmi));
-	#endif
-	hdmi_unregister_display_sysfs(hdmi);
-	#ifdef CONFIG_HAS_EARLYSUSPEND
-	unregister_early_suspend(&hdmi->early_suspend);
-	#endif
-	iounmap((void*)hdmi->regbase);
-err1:
-	release_mem_region(res->start,(res->end - res->start) + 1);
-	clk_disable(hdmi->hclk);
-err0:
-	hdmi_dbg(hdmi->dev, "rk30 hdmi probe error.\n");
-	kfree(hdmi);
-	hdmi = NULL;
-	return ret;
-}
-
-static int __devexit rk30_hdmi_remove(struct platform_device *pdev)
-{
-	if(hdmi) {
-		mutex_lock(&hdmi->enable_mutex);
-		if(!hdmi->suspend && hdmi->enable)
-			disable_irq(hdmi->irq);
-		mutex_unlock(&hdmi->enable_mutex);
-		free_irq(hdmi->irq, NULL);
-		flush_workqueue(hdmi->workqueue);
-		destroy_workqueue(hdmi->workqueue);
-		#ifdef CONFIG_SWITCH
-		switch_dev_unregister(&(hdmi->switch_hdmi));
-		#endif
-		hdmi_unregister_display_sysfs(hdmi);
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi->early_suspend);
-		#endif
-		iounmap((void*)hdmi->regbase);
-		release_mem_region(hdmi->regbase_phy, hdmi->regsize_phy);
-		clk_disable(hdmi->hclk);
-		fb_destroy_modelist(&hdmi->edid.modelist);
-		if(hdmi->edid.audio)
-			kfree(hdmi->edid.audio);
-		if(hdmi->edid.specs)
-		{
-			if(hdmi->edid.specs->modedb)
-				kfree(hdmi->edid.specs->modedb);
-			kfree(hdmi->edid.specs);
-		}
-		kfree(hdmi);
-		hdmi = NULL;
-	}
-	printk(KERN_INFO "rk30 hdmi removed.\n");
-	return 0;
-}
-
-static void rk30_hdmi_shutdown(struct platform_device *pdev)
-{
-	if(hdmi) {
-		#ifdef CONFIG_HAS_EARLYSUSPEND
-		unregister_early_suspend(&hdmi->early_suspend);
-		#endif
-	}
-	printk(KERN_INFO "rk30 hdmi shut down.\n");
-}
-
-static struct platform_driver rk30_hdmi_driver = {
-	.probe		= rk30_hdmi_probe,
-	.remove		= __devexit_p(rk30_hdmi_remove),
-	.driver		= {
-		.name	= "rk30-hdmi",
-		.owner	= THIS_MODULE,
-	},
-	.shutdown   = rk30_hdmi_shutdown,
-};
-
-static int __init rk30_hdmi_init(void)
-{
-    return platform_driver_register(&rk30_hdmi_driver);
-}
-
-static void __exit rk30_hdmi_exit(void)
-{
-    platform_driver_unregister(&rk30_hdmi_driver);
-}
-
-
-//fs_initcall(rk30_hdmi_init);
-module_init(rk30_hdmi_init);
-module_exit(rk30_hdmi_exit);
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi.h b/drivers/video/rockchip/hdmi/rk30_hdmi.h
deleted file mode 100755
index 54f5a5c..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi.h
+++ /dev/null
@@ -1,108 +0,0 @@
-#ifndef __RK30_HDMI_H__
-#define __RK30_HDMI_H__
-
-#include <linux/kernel.h>
-#include <linux/fb.h>
-#include <linux/spinlock.h>
-#include <linux/mutex.h>
-#include <linux/device.h>
-#include <linux/workqueue.h>
-#include <linux/display-sys.h>
-#ifdef CONFIG_SWITCH
-#include <linux/switch.h>
-#endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-#endif
-#include <asm/atomic.h>
-#include<linux/rk_screen.h>
-#include <linux/rk_fb.h>
-#include "rk_hdmi.h"
-
-// HDMI video source
-enum {
-	HDMI_SOURCE_LCDC0 = 0,
-	HDMI_SOURCE_LCDC1 = 1
-};
-
-/* default HDMI video source */
-#define HDMI_SOURCE_DEFAULT		HDMI_SOURCE_LCDC1
-
-/* If HDMI_ENABLE, system will auto configure output mode according to EDID 
- * If HDMI_DISABLE, system will output mode according to macro HDMI_VIDEO_DEFAULT_MODE
- */
-#define HDMI_AUTO_CONFIGURE			HDMI_ENABLE
-
-/* default HDMI output video mode */
-#define HDMI_VIDEO_DEFAULT_MODE			HDMI_1280x720p_60Hz//HDMI_1920x1080p_60Hz
-/* default HDMI output audio mode */
-#define HDMI_AUDIO_DEFAULT_CHANNEL		2
-#define HDMI_AUDIO_DEFAULT_RATE			HDMI_AUDIO_FS_44100
-#define HDMI_AUDIO_DEFAULT_WORD_LENGTH	HDMI_AUDIO_WORD_LENGTH_16bit
-
-struct hdmi {
-	struct device	*dev;
-	struct clk		*hclk;				//HDMI AHP clk
-	int 			regbase;
-	int				irq;
-	int				regbase_phy;
-	int				regsize_phy;
-	struct rk_lcdc_device_driver *lcdc;
-	
-	#ifdef CONFIG_SWITCH
-	struct switch_dev	switch_hdmi;
-	#endif
-	
-	struct workqueue_struct *workqueue;
-	struct delayed_work delay_work;
-	
-	spinlock_t	irq_lock;
-	struct mutex enable_mutex;
-	
-	int wait;
-	struct completion	complete;
-	
-	int suspend;
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	struct early_suspend	early_suspend;
-#endif
-	
-	struct hdmi_edid edid;
-	int enable;					// Enable HDMI output or not
-	int vic;					// HDMI output video mode code
-	struct hdmi_audio audio;	// HDMI output audio type.
-	
-	int pwr_mode;				// power mode
-	int hotplug;				// hot plug status
-	int state;					// hdmi state machine status
-	int autoconfig;				// if true, auto config hdmi output mode according to EDID.
-	int command;				// HDMI configuration command
-	int display;				// HDMI display status
-	int xscale;					// x direction scale value
-	int yscale;					// y directoon scale value
-	int tmdsclk;				// TDMS Clock frequency
-	// call back for hdcp operatoion
-	void (*hdcp_cb)(void);
-	void (*hdcp_irq_cb)(int);
-	int (*hdcp_power_on_cb)(void);
-	void (*hdcp_power_off_cb)(void);
-};
-
-extern struct hdmi *hdmi;
-
-extern int hdmi_sys_init(void);
-extern int hdmi_sys_parse_edid(struct hdmi* hdmi);
-extern const char *hdmi_get_video_mode_name(unsigned char vic);
-extern int hdmi_videomode_to_vic(struct fb_videomode *vmode);
-extern const struct fb_videomode* hdmi_vic_to_videomode(int vic);
-extern int hdmi_add_videomode(const struct fb_videomode *mode, struct list_head *head);
-extern struct hdmi_video_timing * hdmi_find_mode(int vic);
-extern int hdmi_find_best_mode(struct hdmi* hdmi, int vic);
-extern int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok);
-extern int hdmi_switch_fb(struct hdmi *hdmi, int vic);
-extern void hdmi_sys_remove(void);
-extern int rk30_hdmi_register_hdcp_callbacks(void (*hdcp_cb)(void),
-					 void (*hdcp_irq_cb)(int status),
-					 int  (*hdcp_power_on_cb)(void),
-					 void (*hdcp_power_off_cb)(void));
-#endif /* __RK30_HDMI_H__ */
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_edid.c b/drivers/video/rockchip/hdmi/rk30_hdmi_edid.c
deleted file mode 100755
index 9fec195..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_edid.c
+++ /dev/null
@@ -1,410 +0,0 @@
-#include "rk30_hdmi.h"
-#include "rk30_hdmi_hw.h"
-#include "../../edid.h"
-
-#define hdmi_edid_error(fmt, ...) \
-        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
-
-#if 0
-#define hdmi_edid_debug(fmt, ...) \
-        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
-#else
-#define hdmi_edid_debug(fmt, ...)	
-#endif
-
-typedef enum HDMI_EDID_ERRORCODE
-{
-	E_HDMI_EDID_SUCCESS = 0,
-	E_HDMI_EDID_PARAM,
-	E_HDMI_EDID_HEAD,
-	E_HDMI_EDID_CHECKSUM,
-	E_HDMI_EDID_VERSION,
-	E_HDMI_EDID_UNKOWNDATA,
-	E_HDMI_EDID_NOMEMORY
-}HDMI_EDID_ErrorCode;
-
-static const unsigned int double_aspect_vic[] = {3, 7, 9, 11, 13, 15, 18, 22, 24, 26, 28, 30, 36, 38, 43, 45, 49, 51, 53, 55, 57, 59};
-static int hdmi_edid_checksum(unsigned char *buf)
-{
-	int i;
-	int checksum = 0;
-	
-	for(i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
-		checksum += buf[i];	
-	
-	checksum &= 0xff;
-	
-	if(checksum == 0)
-		return E_HDMI_EDID_SUCCESS;
-	else
-		return E_HDMI_EDID_CHECKSUM;
-}
-
-/*
-	@Des	Parse Detail Timing Descriptor.
-	@Param	buf	:	pointer to DTD data.
-	@Param	pvic:	VIC of DTD descripted.
- */
-static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
-{
-	mode->xres = H_ACTIVE;
-	mode->yres = V_ACTIVE;
-	mode->pixclock = PIXEL_CLOCK;
-//	mode->pixclock /= 1000;
-//	mode->pixclock = KHZ2PICOS(mode->pixclock);
-	mode->right_margin = H_SYNC_OFFSET;
-	mode->left_margin = (H_ACTIVE + H_BLANKING) -
-		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
-	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
-		V_SYNC_WIDTH;
-	mode->lower_margin = V_SYNC_OFFSET;
-	mode->hsync_len = H_SYNC_WIDTH;
-	mode->vsync_len = V_SYNC_WIDTH;
-	if (HSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
-	if (VSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
-	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
-				     (V_ACTIVE + V_BLANKING));
-	if (INTERLACED) {
-		mode->yres *= 2;
-		mode->upper_margin *= 2;
-		mode->lower_margin *= 2;
-		mode->vsync_len *= 2;
-		mode->vmode |= FB_VMODE_INTERLACED;
-	}
-	mode->flag = FB_MODE_IS_DETAILED;
-
-	hdmi_edid_debug("<<<<<<<<Detailed Time>>>>>>>>>\n");
-	hdmi_edid_debug("%d KHz Refresh %d Hz",  PIXEL_CLOCK/1000, mode->refresh);
-	hdmi_edid_debug("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
-	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
-	hdmi_edid_debug("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
-	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
-	hdmi_edid_debug("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
-	       (VSYNC_POSITIVE) ? "+" : "-");
-	return E_HDMI_EDID_SUCCESS;
-}
-
-static int hdmi_edid_parse_base(unsigned char *buf, int *extend_num, struct hdmi_edid *pedid)
-{
-	int rc, i;
-	
-	if(buf == NULL || extend_num == NULL)
-		return E_HDMI_EDID_PARAM;
-		
-	#ifdef DEBUG	
-	for(i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
-	{
-		hdmi_edid_debug("%02x ", buf[i]&0xff);
-		if((i+1) % 16 == 0)
-			hdmi_edid_debug("\n");
-	}
-	#endif
-	
-	// Check first 8 byte to ensure it is an edid base block.
-	if( buf[0] != 0x00 ||
-	    buf[1] != 0xFF ||
-	    buf[2] != 0xFF ||
-	    buf[3] != 0xFF ||
-	    buf[4] != 0xFF ||
-	    buf[5] != 0xFF ||
-	    buf[6] != 0xFF ||
-	    buf[7] != 0x00)
-    {
-        hdmi_edid_error("[EDID] check header error\n");
-        return E_HDMI_EDID_HEAD;
-    }
-    
-    *extend_num = buf[0x7e];
-    #ifdef DEBUG
-    hdmi_edid_debug("[EDID] extend block num is %d\n", buf[0x7e]);
-    #endif
-    
-    // Checksum
-    rc = hdmi_edid_checksum(buf);
-    if( rc != E_HDMI_EDID_SUCCESS)
-    {
-    	hdmi_edid_error("[EDID] base block checksum error\n");
-    	return E_HDMI_EDID_CHECKSUM;
-    }
-
-	pedid->specs = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);
-	if(pedid->specs == NULL)
-		return E_HDMI_EDID_NOMEMORY;
-		
-	fb_edid_to_monspecs(buf, pedid->specs);
-	
-    return E_HDMI_EDID_SUCCESS;
-}
-
-// Parse CEA Short Video Descriptor
-static int hdmi_edid_get_cea_svd(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	const struct fb_videomode *mode;
-	int count, i, j, vic;
-
-	count = buf[0] & 0x1F;
-	for(i = 0; i < count; i++)
-	{
-		hdmi_edid_debug("[EDID-CEA] %02x VID %d native %d\n", buf[1 + i], buf[1 + i] & 0x7f, buf[1 + i] >> 7);
-		vic = buf[1 + i] & 0x7f;
-		for(j = 0; j < ARRAY_SIZE(double_aspect_vic); j++)
-		{
-			if(vic == double_aspect_vic[j])
-			{	
-				vic--;
-				break;
-			}
-		}
-		if(vic)
-		{
-			mode = hdmi_vic_to_videomode(vic);
-			if(mode)
-			{	
-				hdmi_add_videomode(mode, &pedid->modelist);
-			}
-		}
-	}
-	return 0;
-}
-
-// Parse CEA Short Audio Descriptor
-static int hdmi_edid_parse_cea_sad(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	int i, count;
-	
-	count = buf[0] & 0x1F;
-	pedid->audio = kmalloc((count/3)*sizeof(struct hdmi_audio), GFP_KERNEL);
-	if(pedid->audio == NULL)
-		return E_HDMI_EDID_NOMEMORY;
-	pedid->audio_num = count/3;
-	for(i = 0; i < pedid->audio_num; i++)
-	{
-		pedid->audio[i].type = (buf[1 + i*3] >> 3) & 0x0F;
-		pedid->audio[i].channel = (buf[1 + i*3] & 0x07) + 1;
-		pedid->audio[i].rate = buf[1 + i*3 + 1];
-		if(pedid->audio[i].type == HDMI_AUDIO_LPCM)//LPCM 
-		{
-			pedid->audio[i].word_length = buf[1 + i*3 + 2];
-		}
-//		printk("[EDID-CEA] type %d channel %d rate %d word length %d\n", 
-//			pedid->audio[i].type, pedid->audio[i].channel, pedid->audio[i].rate, pedid->audio[i].word_length);
-	}
-	return E_HDMI_EDID_SUCCESS;
-}
-// Parse CEA 861 Serial Extension.
-static int hdmi_edid_parse_extensions_cea(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
-	unsigned int underscan_support, baseaudio_support;
-	unsigned int tag, IEEEOUI = 0;
-//	unsigned int supports_ai,  dc_48bit, dc_36bit, dc_30bit, dc_y444;
-//	unsigned char vic;
-	
-	if(buf == NULL)
-		return E_HDMI_EDID_PARAM;
-		
-	// Check ces extension version
-	if(buf[1] != 3)
-	{
-		hdmi_edid_error("[EDID-CEA] error version.\n");
-		return E_HDMI_EDID_VERSION;
-	}
-	
-	ddc_offset = buf[2];
-	underscan_support = (buf[3] >> 7) & 0x01;
-	baseaudio_support = (buf[3] >> 6) & 0x01;
-	pedid->ycbcr444 = (buf[3] >> 5) & 0x01;
-	pedid->ycbcr422 = (buf[3] >> 4) & 0x01;
-	native_dtd_num = buf[3] & 0x0F;
-//	hdmi_edid_debug("[EDID-CEA] ddc_offset %d underscan_support %d baseaudio_support %d yuv_support %d native_dtd_num %d\n", ddc_offset, underscan_support, baseaudio_support, yuv_support, native_dtd_num);
-	// Parse data block
-	while(cur_offset < ddc_offset)
-	{
-		tag = buf[cur_offset] >> 5;
-		switch(tag)
-		{
-			case 0x02:	// Video Data Block
-				hdmi_edid_debug("[EDID-CEA] It is a Video Data Block.\n");
-				hdmi_edid_get_cea_svd(buf + cur_offset, pedid);
-				break;
-			case 0x01:	// Audio Data Block
-				hdmi_edid_debug("[EDID-CEA] It is a Audio Data Block.\n");
-				hdmi_edid_parse_cea_sad(buf + cur_offset, pedid);
-				break;
-			case 0x04:	// Speaker Allocation Data Block
-				hdmi_edid_debug("[EDID-CEA] It is a Speaker Allocatio Data Block.\n");
-				break;
-			case 0x03:	// Vendor Specific Data Block
-				hdmi_edid_debug("[EDID-CEA] It is a Vendor Specific Data Block.\n");
-
-				IEEEOUI = buf[cur_offset + 2 + 1];
-				IEEEOUI <<= 8;
-				IEEEOUI += buf[cur_offset + 1 + 1];
-				IEEEOUI <<= 8;
-				IEEEOUI += buf[cur_offset + 1];
-				hdmi_edid_debug("[EDID-CEA] IEEEOUI is 0x%08x.\n", IEEEOUI);
-				if(IEEEOUI == 0x0c03)
-					pedid->sink_hdmi = 1;
-//				if(count > 5)
-//				{
-//					pedid->deepcolor = (buf[cur_offset + 5] >> 3) & 0x0F;
-//					supports_ai = buf[cur_offset + 5] >> 7;
-//					dc_48bit = (buf[cur_offset + 5] >> 6) & 0x1;
-//					dc_36bit = (buf[cur_offset + 5] >> 5) & 0x1;
-//					dc_30bit = (buf[cur_offset + 5] >> 4) & 0x1;
-//					dc_y444 = (buf[cur_offset + 5] >> 3) & 0x1;
-//					hdmi_edid_debug("[EDID-CEA] supports_ai %d dc_48bit %d dc_36bit %d dc_30bit %d dc_y444 %d \n", supports_ai, dc_48bit, dc_36bit, dc_30bit, dc_y444);
-//				}
-//				if(count > 6)
-//					pedid->maxtmdsclock = buf[cur_offset + 6] * 5000000;
-//				if(count > 7)
-//				{
-//					pedid->latency_fields_present = (buf[cur_offset + 7] & 0x80) ? 1:0;
-//					pedid->i_latency_fields_present = (buf[cur_offset + 7] & 0x40) ? 1:0;
-//				}
-//				if(count > 9 && pedid->latency_fields_present)
-//				{
-//					pedid->video_latency = buf[cur_offset + 8];
-//					pedid->audio_latency = buf[cur_offset + 9];
-//				}
-//				if(count > 11 && pedid->i_latency_fields_present)
-//				{
-//					pedid->interlaced_video_latency = buf[cur_offset + 10];
-//					pedid->interlaced_audio_latency = buf[cur_offset + 11];
-//				}
-				break;		
-			case 0x05:	// VESA DTC Data Block
-				hdmi_edid_debug("[EDID-CEA] It is a VESA DTC Data Block.\n");
-				break;
-			case 0x07:	// Use Extended Tag
-				hdmi_edid_debug("[EDID-CEA] It is a Use Extended Tag Data Block.\n");
-				break;
-			default:
-				hdmi_edid_error("[EDID-CEA] unkowned data block tag.\n");
-				break;
-		}
-		cur_offset += (buf[cur_offset] & 0x1F) + 1;
-	}
-#if 1	
-{
-	// Parse DTD
-	struct fb_videomode *vmode = kmalloc(sizeof(struct fb_videomode), GFP_KERNEL);
-	if(vmode == NULL)
-		return E_HDMI_EDID_SUCCESS; 
-	while(ddc_offset < HDMI_EDID_BLOCK_SIZE - 2)	//buf[126] = 0 and buf[127] = checksum
-	{
-		if(!buf[ddc_offset] && !buf[ddc_offset + 1])
-			break;
-		memset(vmode, 0, sizeof(struct fb_videomode));
-		hdmi_edid_parse_dtd(buf + ddc_offset, vmode);
-		hdmi_add_videomode(vmode, &pedid->modelist);
-		ddc_offset += 18;
-	}
-	kfree(vmode);
-}
-#endif
-	return E_HDMI_EDID_SUCCESS;
-}
-
-static int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_edid *pedid)
-{
-	int rc;
-	
-	if(buf == NULL || pedid == NULL)
-		return E_HDMI_EDID_PARAM;
-		
-	// Checksum
-    rc = hdmi_edid_checksum(buf);
-    if( rc != E_HDMI_EDID_SUCCESS)
-    {
-    	hdmi_edid_error("[EDID] extensions block checksum error\n");
-    	return E_HDMI_EDID_CHECKSUM;
-    }
-    
-    switch(buf[0])
-    {
-    	case 0xF0:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a extensions block map.\n");
-    		break;
-    	case 0x02:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a  CEA 861 Series Extension.\n");
-    		hdmi_edid_parse_extensions_cea(buf, pedid);
-    		break;
-    	case 0x10:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a Video Timing Block Extension.\n");
-    		break;
-    	case 0x40:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a Display Information Extension.\n");
-    		break;
-    	case 0x50:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a Localized String Extension.\n");
-    		break;
-    	case 0x60:
-    		hdmi_edid_debug("[EDID-EXTEND] It is a Digital Packet Video Link Extension.\n");
-    		break;
-    	default:
-    		hdmi_edid_debug("[EDID-EXTEND] Unkowned extension.\n");
-    		break;
-    }
-    
-    return E_HDMI_EDID_SUCCESS;
-}
-
-
-int hdmi_sys_parse_edid(struct hdmi* hdmi)
-{
-	struct hdmi_edid *pedid;
-	unsigned char *buff = NULL;
-	int rc = HDMI_ERROR_SUCESS, extendblock = 0, i;
-	
-	if(hdmi == NULL)
-		return HDMI_ERROR_FALSE;
-
-	pedid = &(hdmi->edid);
-	memset(pedid, 0, sizeof(struct hdmi_edid));
-	INIT_LIST_HEAD(&pedid->modelist);
-	
-	buff = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
-	if(buff == NULL)
-	{		
-		hdmi_dbg(hdmi->dev, "[%s] can not allocate memory for edid buff.\n", __FUNCTION__);
-		return -1;
-	}
-	// Read base block edid.
-	memset(buff, 0 , HDMI_EDID_BLOCK_SIZE);
-	rc = rk30_hdmi_read_edid(0, buff);
-	if(rc)
-	{
-		dev_err(hdmi->dev, "[HDMI] read edid base block error\n");
-		goto out;
-	}
-	rc = hdmi_edid_parse_base(buff, &extendblock, pedid);
-	if(rc)
-	{
-		dev_err(hdmi->dev, "[HDMI] parse edid base block error\n");
-		goto out;
-	}
-	for(i = 1; i < extendblock + 1; i++)
-	{
-		memset(buff, 0 , HDMI_EDID_BLOCK_SIZE);
-		rc = rk30_hdmi_read_edid(i, buff);
-		if(rc)
-		{
-			printk("[HDMI] read edid block %d error\n", i);	
-			goto out;
-		}
-		rc = hdmi_edid_parse_extensions(buff, pedid);
-		if(rc)
-		{
-			dev_err(hdmi->dev, "[HDMI] parse edid block %d error\n", i);
-			continue;
-		}
-	}
-out:
-	if(buff)
-		kfree(buff);
-	rc = hdmi_ouputmode_select(hdmi, rc);
-	return rc;
-}
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_hw.c b/drivers/video/rockchip/hdmi/rk30_hdmi_hw.c
deleted file mode 100755
index 8cb76eb..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_hw.c
+++ /dev/null
@@ -1,647 +0,0 @@
-#include <linux/delay.h>
-#include <asm/io.h>
-#include <mach/io.h>
-#include "rk30_hdmi.h"
-#include "rk30_hdmi_hw.h"
-
-static char edid_result = 0;
-
-static inline void delay100us(void)
-{
-	msleep(1);
-}
-
-int rk30_hdmi_initial(void)
-{
-	int rc = HDMI_ERROR_SUCESS;
-	// internal hclk = hdmi_hclk/20
-	HDMIWrReg(0x800, HDMI_INTERANL_CLK_DIV);
-	
-	if(hdmi->hdcp_power_on_cb)
-		rc = hdmi->hdcp_power_on_cb();
-
-	return rc;
-}
-
-static void rk30_hdmi_set_pwr_mode(int mode)
-{
-	if(hdmi->pwr_mode == mode)
-		return;
-	hdmi_dbg(hdmi->dev, "[%s] mode %d\n", __FUNCTION__, mode);	
-	switch(mode)
-	{
-		case PWR_SAVE_MODE_A:
-			HDMIWrReg(SYS_CTRL, 0x10);
-			break;
-		case PWR_SAVE_MODE_B:
-			HDMIWrReg(SYS_CTRL, 0x20);
-			break;
-		case PWR_SAVE_MODE_D:
-			// reset PLL A&B
-			HDMIWrReg(SYS_CTRL, 0x4C);
-			delay100us();
-			// release PLL A reset
-			HDMIWrReg(SYS_CTRL, 0x48);
-			delay100us();
-			// release PLL B reset
-			HDMIWrReg(SYS_CTRL, 0x40);
-			break;
-		case PWR_SAVE_MODE_E:
-			HDMIWrReg(SYS_CTRL, 0x80);
-			break;
-	}
-	hdmi->pwr_mode = mode;
-	if(mode != PWR_SAVE_MODE_A)
-		msleep(10);
-	hdmi_dbg(hdmi->dev, "[%s] curmode %02x\n", __FUNCTION__, HDMIRdReg(SYS_CTRL));
-}
-
-int rk30_hdmi_detect_hotplug(void)
-{
-	int value =	HDMIRdReg(HPD_MENS_STA);
-	
-	hdmi_dbg(hdmi->dev, "[%s] value %02x\n", __FUNCTION__, value);
-	value &= m_HOTPLUG_STATUS | m_MSEN_STATUS;
-	if(value  == (m_HOTPLUG_STATUS | m_MSEN_STATUS) )
-		return HDMI_HPD_ACTIVED;
-	else if(value)
-		return HDMI_HPD_INSERT;
-	else
-		return HDMI_HPD_REMOVED;
-}
-
-#define HDMI_EDID_DDC_CLK	90000
-int rk30_hdmi_read_edid(int block, unsigned char *buff)
-{
-	int value, ret = -1, ddc_bus_freq = 0;
-	char interrupt = 0, trytime = 2;
-	unsigned long flags;
-	
-	hdmi_dbg(hdmi->dev, "[%s] block %d\n", __FUNCTION__, block);
-	spin_lock_irqsave(&hdmi->irq_lock, flags);
-	edid_result = 0;
-	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
-	//Before Phy parameter was set, DDC_CLK is equal to PLLA freq which is 30MHz.
-	//Set DDC I2C CLK which devided from DDC_CLK to 100KHz.
-	ddc_bus_freq = (30000000/HDMI_EDID_DDC_CLK)/4;
-	HDMIWrReg(DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);
-	HDMIWrReg(DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);
-	
-	// Enable edid interrupt
-	HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS | m_INT_EDID_ERR | m_INT_EDID_READY);
-	
-	while(trytime--) {
-		// Config EDID block and segment addr
-		HDMIWrReg(EDID_WORD_ADDR, (block%2) * 0x80);
-		HDMIWrReg(EDID_SEGMENT_POINTER, block/2);	
-	
-		value = 100;
-		while(value--)
-		{
-			spin_lock_irqsave(&hdmi->irq_lock, flags);
-			interrupt = edid_result;
-			edid_result = 0;
-			spin_unlock_irqrestore(&hdmi->irq_lock, flags);
-			if(interrupt & (m_INT_EDID_ERR | m_INT_EDID_READY))
-				break;
-			msleep(10);
-		}
-		hdmi_dbg(hdmi->dev, "[%s] edid read value %d\n", __FUNCTION__, value);
-		if(interrupt & m_INT_EDID_READY)
-		{
-			for(value = 0; value < HDMI_EDID_BLOCK_SIZE; value++) 
-				buff[value] = HDMIRdReg(DDC_READ_FIFO_ADDR);
-			ret = 0;
-			
-			hdmi_dbg(hdmi->dev, "[%s] edid read sucess\n", __FUNCTION__);
-#ifdef HDMI_DEBUG
-			for(value = 0; value < 128; value++) {
-				printk("%02x ,", buff[value]);
-				if( (value + 1) % 16 == 0)
-					printk("\n");
-			}
-#endif
-			break;
-		}		
-		if(interrupt & m_INT_EDID_ERR)
-			hdmi_err(hdmi->dev, "[%s] edid read error\n", __FUNCTION__);
-
-	}
-	// Disable edid interrupt
-	HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS);
-//	msleep(100);
-	return ret;
-}
-
-static inline void rk30_hdmi_config_phy_reg(int reg, int value)
-{
-	HDMIWrReg(reg, value);
-	HDMIWrReg(SYS_CTRL, 0x2C);
-	delay100us();
-	HDMIWrReg(SYS_CTRL, 0x20);
-	msleep(1);
-}
-
-static void rk30_hdmi_config_phy(unsigned char vic)
-{
-	HDMIWrReg(DEEP_COLOR_MODE, 0x22);	// tmds frequency same as input dlck
-	rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
-	switch(vic)
-	{
-		case HDMI_1920x1080p_60Hz:
-		case HDMI_1920x1080p_50Hz:
-			rk30_hdmi_config_phy_reg(0x158, 0x0E);
-			rk30_hdmi_config_phy_reg(0x15c, 0x00);
-			rk30_hdmi_config_phy_reg(0x160, 0x60);
-			rk30_hdmi_config_phy_reg(0x164, 0x00);
-			rk30_hdmi_config_phy_reg(0x168, 0xDA);
-			rk30_hdmi_config_phy_reg(0x16c, 0xA1);
-			rk30_hdmi_config_phy_reg(0x170, 0x0e);
-			rk30_hdmi_config_phy_reg(0x174, 0x22);
-			rk30_hdmi_config_phy_reg(0x178, 0x00);
-			break;
-			
-		case HDMI_1920x1080i_60Hz:
-		case HDMI_1920x1080i_50Hz:
-		case HDMI_1280x720p_60Hz:
-		case HDMI_1280x720p_50Hz:
-			rk30_hdmi_config_phy_reg(0x158, 0x06);
-			rk30_hdmi_config_phy_reg(0x15c, 0x00);
-			rk30_hdmi_config_phy_reg(0x160, 0x60);
-			rk30_hdmi_config_phy_reg(0x164, 0x00);
-			rk30_hdmi_config_phy_reg(0x168, 0xCA);
-			rk30_hdmi_config_phy_reg(0x16c, 0xA3);
-			rk30_hdmi_config_phy_reg(0x170, 0x0e);
-			rk30_hdmi_config_phy_reg(0x174, 0x20);
-			rk30_hdmi_config_phy_reg(0x178, 0x00);
-			break;
-			
-		case HDMI_720x576p_50Hz_4_3:
-		case HDMI_720x576p_50Hz_16_9:
-		case HDMI_720x480p_60Hz_4_3:
-		case HDMI_720x480p_60Hz_16_9:
-			rk30_hdmi_config_phy_reg(0x158, 0x02);
-			rk30_hdmi_config_phy_reg(0x15c, 0x00);
-			rk30_hdmi_config_phy_reg(0x160, 0x60);
-			rk30_hdmi_config_phy_reg(0x164, 0x00);
-			rk30_hdmi_config_phy_reg(0x168, 0xC2);
-			rk30_hdmi_config_phy_reg(0x16c, 0xA2);
-			rk30_hdmi_config_phy_reg(0x170, 0x0e);
-			rk30_hdmi_config_phy_reg(0x174, 0x20);
-			rk30_hdmi_config_phy_reg(0x178, 0x00);
-			break;
-		default:
-			hdmi_err(hdmi->dev, "not support such vic %d\n", vic);
-			break;
-	}
-}
-
-static void rk30_hdmi_config_avi(unsigned char vic, unsigned char output_color)
-{
-	int i, clolorimetry, aspect_ratio;
-	char info[SIZE_AVI_INFOFRAME];
-	
-	memset(info, 0, SIZE_AVI_INFOFRAME);
-	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AVI);
-	info[0] = 0x82;
-	info[1] = 0x02;
-	info[2] = 0x0D;	
-	info[3] = info[0] + info[1] + info[2];
-
-	if(output_color == VIDEO_OUTPUT_YCBCR444)	
-		info[4] = (AVI_COLOR_MODE_YCBCR444 << 5);
-	else if(output_color == VIDEO_OUTPUT_YCBCR422)
-		info[4] = (AVI_COLOR_MODE_YCBCR422 << 5);
-	else
-		info[4] = (AVI_COLOR_MODE_RGB << 5);
-	info[4] |= (1 << 4);	//Enable active format data bits is present in info[2]
-	
-	switch(vic)
-	{
-		case HDMI_720x480i_60Hz_4_3:
-		case HDMI_720x576i_50Hz_4_3:
-		case HDMI_720x480p_60Hz_4_3:
-		case HDMI_720x576p_50Hz_4_3:				
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_4_3;
-			clolorimetry = AVI_COLORIMETRY_SMPTE_170M;
-			break;
-		case HDMI_720x480i_60Hz_16_9:
-		case HDMI_720x576i_50Hz_16_9:
-		case HDMI_720x480p_60Hz_16_9:
-		case HDMI_720x576p_50Hz_16_9:
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-			clolorimetry = AVI_COLORIMETRY_SMPTE_170M;
-			break;
-		default:
-			aspect_ratio = AVI_CODED_FRAME_ASPECT_16_9;
-			clolorimetry = AVI_COLORIMETRY_ITU709;
-	}
-
-	if(output_color == VIDEO_OUTPUT_RGB444)
-		clolorimetry = AVI_COLORIMETRY_NO_DATA;
-	
-	info[5] = (clolorimetry << 6) | (aspect_ratio << 4) | ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME;
-	info[6] = 0;
-	info[7] = vic;
-	info[8] = 0;
-
-	// Calculate AVI InfoFrame ChecKsum
-	for (i = 4; i < SIZE_AVI_INFOFRAME; i++)
-	{
-    	info[3] += info[i];
-	}
-	info[3] = 0x100 - info[3];
-	
-	for(i = 0; i < SIZE_AVI_INFOFRAME; i++)
-		HDMIWrReg(CONTROL_PACKET_HB0 + i*4, info[i]);
-}
- 
-static char coeff_csc[][24] = {
-		//G			B			R			Bias
-	{	//CSC_RGB_0_255_TO_ITU601_16_235
-		0x11, 0xb6, 0x02, 0x0b, 0x10, 0x55, 0x00, 0x80, 	//Cr
-		0x02, 0x59, 0x01, 0x32, 0x00, 0x75, 0x00, 0x10, 	//Y
-		0x11, 0x5b, 0x10, 0xb0, 0x02, 0x0b, 0x00, 0x80, 	//Cb
-	},
-	{	//CSC_RGB_0_255_TO_ITU709_16_235
-		0x11, 0xdb, 0x02, 0x0b, 0x10, 0x30, 0x00, 0x80,		//Cr
-		0x02, 0xdc, 0x00, 0xda, 0x00, 0x4a, 0x00, 0x10, 	//Y
-		0x11, 0x93, 0x10, 0x78, 0x02, 0x0b, 0x00, 0x80, 	//Cb
-	},
-		//Y			Cr			Cb			Bias
-	{	//CSC_ITU601_16_235_TO_RGB_16_235
-		0x04, 0x00, 0x05, 0x7c, 0x00, 0x00, 0x02, 0xaf, 	//R
-		0x04, 0x00, 0x12, 0xcb, 0x11, 0x58, 0x00, 0x84, 	//G
-		0x04, 0x00, 0x00, 0x00, 0x06, 0xee, 0x02, 0xde,		//B
-	},
-	{	//CSC_ITU709_16_235_TO_RGB_16_235
-		0x04, 0x00, 0x06, 0x29, 0x00, 0x00, 0x02, 0xc5, 	//R
-		0x04, 0x00, 0x11, 0xd6, 0x10, 0xbb, 0x00, 0x52, 	//G
-		0x04, 0x00, 0x00, 0x00, 0x07, 0x44, 0x02, 0xe8, 	//B
-	},
-	{	//CSC_ITU601_16_235_TO_RGB_0_255
-		0x04, 0xa8, 0x05, 0x7c, 0x00, 0x00, 0x02, 0xc2, 	//R
-		0x04, 0xa8, 0x12, 0xcb, 0x11, 0x58, 0x00, 0x72, 	//G
-		0x04, 0xa8, 0x00, 0x00, 0x06, 0xee, 0x02, 0xf0, 	//B
-	},
-	{	//CSC_ITU709_16_235_TO_RGB_0_255
-		0x04, 0xa8, 0x06, 0x29, 0x00, 0x00, 0x02, 0xd8, 	//R
-		0x04, 0xa8, 0x11, 0xd6, 0x10, 0xbb, 0x00, 0x40, 	//G
-		0x04, 0xa8, 0x00, 0x00, 0x07, 0x44, 0x02, 0xfb, 	//B
-	},
-	
-};
-
-static void rk30_hdmi_config_csc(struct rk30_hdmi_video_para *vpara)
-{
-	int i, mode;
-	char *coeff = NULL;
-		
-	if( ((vpara->input_color == VIDEO_INPUT_COLOR_RGB) && (vpara->output_color == VIDEO_OUTPUT_RGB444)) ||
-		((vpara->input_color == VIDEO_INPUT_COLOR_YCBCR) && (vpara->output_color != VIDEO_OUTPUT_RGB444) ))
-	{
-		return;
-	}
-	switch(vpara->vic)
-	{
-		case HDMI_720x480i_60Hz_4_3:
-		case HDMI_720x576i_50Hz_4_3:
-		case HDMI_720x480p_60Hz_4_3:
-		case HDMI_720x576p_50Hz_4_3:
-		case HDMI_720x480i_60Hz_16_9:
-		case HDMI_720x576i_50Hz_16_9:
-		case HDMI_720x480p_60Hz_16_9:
-		case HDMI_720x576p_50Hz_16_9:
-			if(vpara->input_color == VIDEO_INPUT_COLOR_RGB)
-				mode = CSC_RGB_0_255_TO_ITU601_16_235;
-			else if(vpara->output_mode == OUTPUT_HDMI)
-				mode = CSC_ITU601_16_235_TO_RGB_16_235;
-			else
-				mode = CSC_ITU601_16_235_TO_RGB_0_255;
-			break;
-		default:
-			if(vpara->input_color == VIDEO_INPUT_COLOR_RGB)
-				mode = CSC_RGB_0_255_TO_ITU709_16_235;
-			else if(vpara->output_mode == OUTPUT_HDMI)
-				mode = CSC_ITU709_16_235_TO_RGB_16_235;
-			else
-				mode = CSC_ITU709_16_235_TO_RGB_0_255;
-			break;
-	}
-	
-	coeff = coeff_csc[mode];
-	
-	HDMIWrReg(CSC_CONFIG1, v_CSC_MODE(CSC_MODE_MANUAL) | v_CSC_BRSWAP_DIABLE(1));
-	
-	for(i = 0; i < 24; i++)
-		HDMIWrReg(CSC_PARA_C0_H + i*4, coeff[i]);
-		
-	HDMIWrReg(AV_CTRL2, v_CSC_ENABLE(1));
-}
-
-int rk30_hdmi_config_video(struct rk30_hdmi_video_para *vpara)
-{
-	int value;
-	struct fb_videomode *mode;
-	
-	hdmi_dbg(hdmi->dev, "[%s]\n", __FUNCTION__);
-	if(vpara == NULL) {
-		hdmi_err(hdmi->dev, "[%s] input parameter error\n", __FUNCTION__);
-		return -1;
-	}
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_E)
-		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_D || hdmi->pwr_mode == PWR_SAVE_MODE_A)
-		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
-	
-	if(hdmi->hdcp_power_off_cb)
-		hdmi->hdcp_power_off_cb();
-		
-	// Input video mode is RGB24bit, Data enable signal from external
-	HDMIMskReg(value, AV_CTRL1, m_INPUT_VIDEO_MODE | m_DE_SIGNAL_SELECT, \
-		v_INPUT_VIDEO_MODE(vpara->input_mode) | EXTERNAL_DE)	
-	HDMIMskReg(value, VIDEO_CTRL1, m_VIDEO_OUTPUT_MODE | m_VIDEO_INPUT_DEPTH | m_VIDEO_INPUT_COLOR_MODE, \
-		v_VIDEO_OUTPUT_MODE(vpara->output_color) | v_VIDEO_INPUT_DEPTH(VIDEO_INPUT_DEPTH_8BIT) | vpara->input_color)
-	HDMIWrReg(DEEP_COLOR_MODE, 0x20);
-	// color space convert
-	rk30_hdmi_config_csc(vpara);
-	// Set HDMI Mode
-	HDMIWrReg(HDCP_CTRL, v_HDMI_DVI(vpara->output_mode));
-
-	// Set ext video
-	mode = (struct fb_videomode *)hdmi_vic_to_videomode(vpara->vic);
-	if(mode == NULL)
-	{
-		hdmi_err(hdmi->dev, "[%s] not found vic %d\n", __FUNCTION__, vpara->vic);
-		return -ENOENT;
-	}
-	hdmi->tmdsclk = mode->pixclock;
-
-	if( (vpara->vic == HDMI_720x480p_60Hz_4_3) || (vpara->vic == HDMI_720x480p_60Hz_16_9) )
-		value = v_VSYNC_OFFSET(6);
-	else
-		value = v_VSYNC_OFFSET(0);
-	value |= v_EXT_VIDEO_ENABLE(1) | v_INTERLACE(mode->vmode);
-	if(mode->sync & FB_SYNC_HOR_HIGH_ACT)
-		value |= v_HSYNC_POLARITY(1);
-	if(mode->sync & FB_SYNC_VERT_HIGH_ACT)
-		value |= v_VSYNC_POLARITY(1);
-	HDMIWrReg(EXT_VIDEO_PARA, value);
-	value = mode->left_margin + mode->xres + mode->right_margin + mode->hsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_HTOTAL_L, value & 0xFF);
-	HDMIWrReg(EXT_VIDEO_PARA_HTOTAL_H, (value >> 8) & 0xFF);
-	
-	value = mode->left_margin + mode->right_margin + mode->hsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_HBLANK_L, value & 0xFF);
-	HDMIWrReg(EXT_VIDEO_PARA_HBLANK_H, (value >> 8) & 0xFF);
-	
-	value = mode->left_margin + mode->hsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_HDELAY_L, value & 0xFF);
-	HDMIWrReg(EXT_VIDEO_PARA_HDELAY_H, (value >> 8) & 0xFF);
-	
-	value = mode->hsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_HSYNCWIDTH_L, value & 0xFF);
-	HDMIWrReg(EXT_VIDEO_PARA_HSYNCWIDTH_H, (value >> 8) & 0xFF);
-	
-	value = mode->upper_margin + mode->yres + mode->lower_margin + mode->vsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_VTOTAL_L, value & 0xFF);
-	HDMIWrReg(EXT_VIDEO_PARA_VTOTAL_H, (value >> 8) & 0xFF);
-	
-	value = mode->upper_margin + mode->vsync_len + mode->lower_margin;
-	HDMIWrReg(EXT_VIDEO_PARA_VBLANK_L, value & 0xFF);
-	
-	if(vpara->vic == HDMI_720x480p_60Hz_4_3 || vpara->vic == HDMI_720x480p_60Hz_16_9)
-		value = 42;
-	else
-		value = mode->upper_margin + mode->vsync_len;
-
-	HDMIWrReg(EXT_VIDEO_PARA_VDELAY, value & 0xFF);
-	
-	value = mode->vsync_len;
-	HDMIWrReg(EXT_VIDEO_PARA_VSYNCWIDTH, value & 0xFF);
-	
-	if(vpara->output_mode == OUTPUT_HDMI) {
-		rk30_hdmi_config_avi(vpara->vic, vpara->output_color);
-		hdmi_dbg(hdmi->dev, "[%s] sucess output HDMI.\n", __FUNCTION__);
-	}
-	else {
-		hdmi_dbg(hdmi->dev, "[%s] sucess output DVI.\n", __FUNCTION__);	
-	}
-	
-	rk30_hdmi_config_phy(vpara->vic);
-	rk30_hdmi_control_output(0);
-	return 0;
-}
-
-static void rk30_hdmi_config_aai(void)
-{
-	int i;
-	char info[SIZE_AUDIO_INFOFRAME];
-	
-	memset(info, 0, SIZE_AUDIO_INFOFRAME);
-	
-	info[0] = 0x84;
-	info[1] = 0x01;
-	info[2] = 0x0A;
-	
-	info[3] = info[0] + info[1] + info[2];	
-	for (i = 4; i < SIZE_AUDIO_INFOFRAME; i++)
-    	info[3] += info[i];
-    	
-	info[3] = 0x100 - info[3];
-	
-	HDMIWrReg(CONTROL_PACKET_BUF_INDEX, INFOFRAME_AAI);
-	for(i = 0; i < SIZE_AUDIO_INFOFRAME; i++)
-		HDMIWrReg(CONTROL_PACKET_HB0 + i*4, info[i]);
-}
-
-int rk30_hdmi_config_audio(struct hdmi_audio *audio)
-{
-	int value, rate, N;
-	char word_length, channel;
-	
-	if(audio->channel < 3)
-		channel = I2S_CHANNEL_1_2;
-	else if(audio->channel < 5)
-		channel = I2S_CHANNEL_3_4;
-	else if(audio->channel < 7)
-		channel = I2S_CHANNEL_5_6;
-	else
-		channel = I2S_CHANNEL_7_8;
-	
-	switch(audio->rate)
-	{
-		case HDMI_AUDIO_FS_32000:
-			rate = AUDIO_32K;
-			N = N_32K;
-			break;
-		case HDMI_AUDIO_FS_44100:
-			rate = AUDIO_441K;
-			N = N_441K;
-			break;
-		case HDMI_AUDIO_FS_48000:
-			rate = AUDIO_48K;
-			N = N_48K;
-			break;
-		case HDMI_AUDIO_FS_88200:
-			rate = AUDIO_882K;
-			N = N_882K;
-			break;
-		case HDMI_AUDIO_FS_96000:
-			rate = AUDIO_96K;
-			N = N_96K;
-			break;
-		case HDMI_AUDIO_FS_176400:
-			rate = AUDIO_1764K;
-			N = N_1764K;
-			break;
-		case HDMI_AUDIO_FS_192000:
-			rate = AUDIO_192K;
-			N = N_192K;
-			break;
-		default:
-			hdmi_err(hdmi->dev, "[%s] not support such sample rate %d\n", __FUNCTION__, audio->rate);
-			return -ENOENT;
-	}
-//	switch(audio->word_length)
-//	{
-//		case HDMI_AUDIO_WORD_LENGTH_16bit:
-//			word_length = 0x02;
-//			break;
-//		case HDMI_AUDIO_WORD_LENGTH_20bit:
-//			word_length = 0x0a;
-//			break;
-//		case HDMI_AUDIO_WORD_LENGTH_24bit:
-//			word_length = 0x0b;
-//			break;
-//		default:
-//			hdmi_err(hdmi->dev, "[%s] not support such word length %d\n", __FUNCTION__, audio->word_length);
-//			return -ENOENT;
-//	}
-	//set_audio_if I2S
-	HDMIWrReg(AUDIO_CTRL1, 0x00); //internal CTS, disable down sample, i2s input, disable MCLK
-	HDMIWrReg(AUDIO_CTRL2, 0x40); 
-	HDMIWrReg(I2S_AUDIO_CTRL, v_I2S_MODE(I2S_MODE_STANDARD) | v_I2S_CHANNEL(channel) );	
-	HDMIWrReg(I2S_INPUT_SWAP, 0x00); //no swap
-	HDMIMskReg(value, AV_CTRL1, m_AUDIO_SAMPLE_RATE, v_AUDIO_SAMPLE_RATE(rate))	
-//	HDMIWrReg(SRC_NUM_AUDIO_LEN, word_length);
-		
-    //Set N value 6144, fs=48kHz
-    HDMIWrReg(N_1, N & 0xFF);
-    HDMIWrReg(N_2, (N >> 8) & 0xFF);
-    HDMIWrReg(LR_SWAP_N3, (N >> 16) & 0x0F); 
-    
-    rk30_hdmi_config_aai();
-    return 0;
-}
-
-static void rk30_hdmi_audio_reset(void)
-{
-	int value;
-	
-	HDMIMskReg(value, VIDEO_SETTING2, m_AUDIO_RESET, AUDIO_CAPTURE_RESET)
-	msleep(1);
-	HDMIMskReg(value, VIDEO_SETTING2, m_AUDIO_RESET, 0)
-}
-
-void rk30_hdmi_control_output(int enable)
-{
-	hdmi_dbg(hdmi->dev, "[%s] %d\n", __FUNCTION__, enable);
-	if(enable == 0) {
-		HDMIWrReg(VIDEO_SETTING2, 0x03);
-	}
-	else {
-		if(hdmi->pwr_mode == PWR_SAVE_MODE_B) {
-			//  Switch to power save mode_d
-			rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
-		}
-		if(hdmi->pwr_mode == PWR_SAVE_MODE_D) {
-			//  Switch to power save mode_e
-			rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_E);
-		}
-		HDMIWrReg(VIDEO_SETTING2, 0x00);
-		rk30_hdmi_audio_reset();
-	}
-}
-
-int rk30_hdmi_removed(void)
-{
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_E)
-	{
-		HDMIWrReg(VIDEO_SETTING2, 0x00);
-		rk30_hdmi_audio_reset();
-		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_D);
-	}
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_D)
-		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_B);
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_B && hdmi->state == HDMI_SLEEP)
-	{
-		HDMIWrReg(INTR_MASK1, m_INT_HOTPLUG | m_INT_MSENS);
-		HDMIWrReg(INTR_MASK2, 0);
-		HDMIWrReg(INTR_MASK3, 0);
-		HDMIWrReg(INTR_MASK4, 0);
-		// Disable color space convertion
-		HDMIWrReg(AV_CTRL2, v_CSC_ENABLE(0));
-		HDMIWrReg(CSC_CONFIG1, v_CSC_MODE(CSC_MODE_AUTO) | v_CSC_BRSWAP_DIABLE(1));
-		if(hdmi->hdcp_power_off_cb)
-			hdmi->hdcp_power_off_cb();
-		rk30_hdmi_set_pwr_mode(PWR_SAVE_MODE_A);
-	}
-	dev_printk(KERN_INFO , hdmi->dev , "Removed.\n");
-	return HDMI_ERROR_SUCESS;
-}
-
-
-irqreturn_t hdmi_irq(int irq, void *priv)
-{		
-	char interrupt1 = 0, interrupt2 = 0, interrupt3 = 0, interrupt4 = 0;
-	
-	if(hdmi->pwr_mode == PWR_SAVE_MODE_A)
-	{
-		HDMIWrReg(SYS_CTRL, 0x20);
-		hdmi->pwr_mode = PWR_SAVE_MODE_B;
-		
-		hdmi_dbg(hdmi->dev, "hdmi irq wake up\n");
-		// HDMI was inserted when system is sleeping, irq was triggered only once
-		// when wake up. So we need to check hotplug status.
-		if(HDMIRdReg(HPD_MENS_STA) & (m_HOTPLUG_STATUS | m_MSEN_STATUS)) {			
-			queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));
-		}
-	}
-	else
-	{
-		interrupt1 = HDMIRdReg(INTR_STATUS1);
-		interrupt2 = HDMIRdReg(INTR_STATUS2);
-		interrupt3 = HDMIRdReg(INTR_STATUS3);
-		interrupt4 = HDMIRdReg(INTR_STATUS4);
-		HDMIWrReg(INTR_STATUS1, interrupt1);
-		HDMIWrReg(INTR_STATUS2, interrupt2);
-		HDMIWrReg(INTR_STATUS3, interrupt3);
-		HDMIWrReg(INTR_STATUS4, interrupt4);
-#if 0
-		hdmi_dbg(hdmi->dev, "[%s] interrupt1 %02x interrupt2 %02x interrupt3 %02x interrupt4 %02x\n",\
-			 __FUNCTION__, interrupt1, interrupt2, interrupt3, interrupt4);
-#endif
-		if(interrupt1 & (m_INT_HOTPLUG | m_INT_MSENS))
-		{
-			if(hdmi->state == HDMI_SLEEP)
-				hdmi->state = WAIT_HOTPLUG;
-			interrupt1 &= ~(m_INT_HOTPLUG | m_INT_MSENS);
-			queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, msecs_to_jiffies(10));	
-		}
-		else if(interrupt1 & (m_INT_EDID_READY | m_INT_EDID_ERR)) {
-			spin_lock(&hdmi->irq_lock);
-			edid_result = interrupt1;
-			spin_unlock(&hdmi->irq_lock);
-		}
-		else if(hdmi->state == HDMI_SLEEP) {
-			hdmi_dbg(hdmi->dev, "hdmi return to sleep mode\n");
-			HDMIWrReg(SYS_CTRL, 0x10);
-			hdmi->pwr_mode = PWR_SAVE_MODE_A;
-		}
-		if(interrupt2 && hdmi->hdcp_irq_cb)
-			hdmi->hdcp_irq_cb(interrupt2);
-	}
-	return IRQ_HANDLED;
-}
-
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_hw.h b/drivers/video/rockchip/hdmi/rk30_hdmi_hw.h
deleted file mode 100755
index 6a5fc33..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_hw.h
+++ /dev/null
@@ -1,446 +0,0 @@
-#ifndef __RK30_HDMI_HW_H__
-#define __RK30_HDMI_HW_H__
-
-/* HDMI_SYS_CONTROL */
-#define SYS_CTRL	0x0
-
-enum {
-	PWR_SAVE_MODE_A = 1,
-	PWR_SAVE_MODE_B = 2,
-	PWR_SAVE_MODE_D = 4,
-	PWR_SAVE_MODE_E = 8
-};
-#define m_PWR_SAVE_MODE		0xF0
-#define v_PWR_SAVE_MODE(n)	(n << 4)
-#define PLL_B_RESET			(1 << 3)
-
-#define N_32K 		0x1000
-#define N_441K 		0x1880
-#define N_882K 		0x3100
-#define N_1764K 	0x6200
-#define N_48K 		0x1800
-#define N_96K		0x3000
-#define N_192K 		0x6000
-
-#define LR_SWAP_N3			0x04
-#define N_2					0x08
-#define N_1					0x0c
-
-#define AUDIO_CTRL1			0x28
-#define AUDIO_CTRL2 		0x2c
-#define I2S_AUDIO_CTRL		0x30
-enum {
-	I2S_MODE_STANDARD = 0,
-	I2S_MODE_RIGHT_JUSTIFIED,
-	I2S_MODE_LEFT_JUSTIFIED
-};
-#define v_I2S_MODE(n)		n
-enum {
-	I2S_CHANNEL_1_2 = 1,
-	I2S_CHANNEL_3_4 = 3,
-	I2S_CHANNEL_5_6 = 7,
-	I2S_CHANNEL_7_8 = 0xf
-};
-#define v_I2S_CHANNEL(n)	( (n) << 2 )
-
-#define I2S_INPUT_SWAP		0x40
-
-#define SRC_NUM_AUDIO_LEN	0x50
-
-/* HDMI_AV_CTRL1*/
-#define AV_CTRL1	0x54
-enum {
-	AUDIO_32K	= 0x3,
-	AUDIO_441K	= 0x0,
-	AUDIO_48K	= 0x2,
-	AUDIO_882K	= 0x8,
-	AUDIO_96K	= 0xa,
-	AUDIO_1764K	= 0xc,
-	AUDIO_192K	= 0xe,
-};
-#define m_AUDIO_SAMPLE_RATE		0xF0
-#define v_AUDIO_SAMPLE_RATE(n)	(n << 4)
-enum {
-	VIDEO_INPUT_RGB_YCBCR_444 = 0,
-	VIDEO_INPUT_YCBCR422,
-	VIDEO_INPUT_YCBCR422_EMBEDDED_SYNC,
-	VIDEO_INPUT_2X_CLOCK,
-	VIDEO_INPUT_2X_CLOCK_EMBEDDED_SYNC,
-	VIDEO_INPUT_RGB444_DDR,
-	VIDEO_INPUT_YCBCR422_DDR
-};
-#define m_INPUT_VIDEO_MODE			(7 << 1)
-#define v_INPUT_VIDEO_MODE(n)		(n << 1)
-enum {
-	INTERNAL_DE = 0,
-	EXTERNAL_DE
-};
-#define m_DE_SIGNAL_SELECT			(1 << 0)
-
-/* HDMI_AV_CTRL2 */
-#define AV_CTRL2	0xec
-#define m_CSC_ENABLE				(1 << 0)
-#define v_CSC_ENABLE(n)				(n)
-
-/* HDMI_VIDEO_CTRL1 */
-#define VIDEO_CTRL1	0x58
-enum {
-	VIDEO_OUTPUT_RGB444 = 0,
-	VIDEO_OUTPUT_YCBCR444,
-	VIDEO_OUTPUT_YCBCR422
-};
-#define m_VIDEO_OUTPUT_MODE		(0x3 << 6)
-#define v_VIDEO_OUTPUT_MODE(n)	(n << 6)
-enum {
-	VIDEO_INPUT_DEPTH_12BIT = 0,
-	VIDEO_INPUT_DEPTH_10BIT = 0x1,
-	VIDEO_INPUT_DEPTH_8BIT = 0x3
-};
-#define m_VIDEO_INPUT_DEPTH		(3 << 4)
-#define v_VIDEO_INPUT_DEPTH(n)	(n << 4)
-enum {
-	VIDEO_EMBEDDED_SYNC_LOCATION_0 = 0,
-	VIDEO_EMBEDDED_SYNC_LOCATION_1,
-	VIDEO_EMBEDDED_SYNC_LOCATION_2
-};
-#define m_VIDEO_EMBEDDED_SYNC_LOCATION		(3 << 2)
-#define VIDEO_EMBEDDED_SYNC_LOCATION(n)		(n << 2)
-enum {
-	VIDEO_INPUT_COLOR_RGB = 0,
-	VIDEO_INPUT_COLOR_YCBCR
-};
-#define m_VIDEO_INPUT_COLOR_MODE			(1 << 0)
-
-/* DEEP_COLOR_MODE */
-#define DEEP_COLOR_MODE	0x5c
-enum{
-	TMDS_CLOCK_MODE_8BIT = 0,
-	TMDS_CLOKK_MODE_10BIT,
-	TMDS_CLOKK_MODE_12BIT
-};
-#define TMDS_CLOCK_MODE_MASK	0x3 << 6
-#define TMDS_CLOCK_MODE(n)		(n) << 6
-
-/* VIDEO_CTRL2 */
-#define VIDEO_SETTING2	0x114
-#define m_UNMUTE					(1 << 7)
-#define m_MUTE						(1 << 6)
-#define m_AUDIO_RESET				(1 << 2)
-#define m_NOT_SEND_AUDIO			(1 << 1)
-#define m_NOT_SEND_VIDEO			(1 << 0)
-#define AV_UNMUTE					(1 << 7)		// Unmute video and audio, send normal video and audio data
-#define AV_MUTE						(1 << 6)		// Mute video and audio, send black video data and silent audio data
-#define AUDIO_CAPTURE_RESET			(1 << 2)		// Reset audio process logic, only available in pwr_e mode.
-#define NOT_SEND_AUDIO				(1 << 1)		// Send silent audio data
-#define NOT_SEND_VIDEO				(1 << 0)		// Send black video data
-
-/* Color Space Convertion Parameter*/
-#define CSC_PARA_C0_H	0x60
-#define CSC_PARA_C0_L	0x64
-#define CSC_PARA_C1_H	0x68
-#define CSC_PARA_C1_L	0x6c
-#define CSC_PARA_C2_H	0x70
-#define CSC_PARA_C2_L	0x74
-#define CSC_PARA_C3_H	0x78
-#define CSC_PARA_C3_L	0x7c
-#define CSC_PARA_C4_H	0x80
-#define CSC_PARA_C4_L	0x84
-#define CSC_PARA_C5_H	0x88
-#define CSC_PARA_C5_L	0x8c
-#define CSC_PARA_C6_H	0x90
-#define CSC_PARA_C6_L	0x94
-#define CSC_PARA_C7_H	0x98
-#define CSC_PARA_C7_L	0x9c
-#define CSC_PARA_C8_H	0xa0
-#define CSC_PARA_C8_L	0xa4
-#define CSC_PARA_C9_H	0xa8
-#define CSC_PARA_C9_L	0xac
-#define CSC_PARA_C10_H	0xac
-#define CSC_PARA_C10_L	0xb4
-#define CSC_PARA_C11_H	0xb8
-#define CSC_PARA_C11_L	0xbc
-
-#define CSC_CONFIG1		0x34c
-#define m_CSC_MODE			(1 << 7)
-#define m_CSC_COEF_MODE 	(0xF << 3)	//Only used in auto csc mode
-#define m_CSC_STATUS		(1 << 2)
-#define m_CSC_VID_SELECT	(1 << 1)
-#define m_CSC_BRSWAP_DIABLE	(1)
-
-enum {
-	CSC_MODE_MANUAL	= 0,
-	CSC_MODE_AUTO
-};
-#define v_CSC_MODE(n)			(n << 7)
-enum {
-	COE_SDTV_LIMITED_RANGE = 0x08,
-	COE_SDTV_FULL_RANGE = 0x04,
-	COE_HDTV_60Hz = 0x2,
-	COE_HDTV_50Hz = 0x1
-};
-#define v_CSC_COE_MODE(n)		(n << 3)
-enum {
-	CSC_INPUT_VID_5_19 = 0,
-	CSC_INPUT_VID_28_29
-};
-#define v_CSC_VID_SELECT(n)		(n << 1)
-#define v_CSC_BRSWAP_DIABLE(n)	(n)
-
-/* CONTROL_PACKET_BUF_INDEX */
-#define CONTROL_PACKET_BUF_INDEX	0x17c
-enum {
-	INFOFRAME_AVI = 0x06,
-	INFOFRAME_AAI = 0x08
-};
-#define CONTROL_PACKET_HB0			0x180
-#define CONTROL_PACKET_HB1			0x184
-#define CONTROL_PACKET_HB2			0x188
-#define CONTROL_PACKET_PB_ADDR		0x18c
-#define SIZE_AVI_INFOFRAME			0x11	// 17 bytes
-#define SIZE_AUDIO_INFOFRAME		0x0F	// 15 bytes
-enum {
-	AVI_COLOR_MODE_RGB = 0,
-	AVI_COLOR_MODE_YCBCR422,
-	AVI_COLOR_MODE_YCBCR444
-};
-enum {
-	AVI_COLORIMETRY_NO_DATA = 0,
-	AVI_COLORIMETRY_SMPTE_170M,
-	AVI_COLORIMETRY_ITU709,
-	AVI_COLORIMETRY_EXTENDED
-};
-enum {
-	AVI_CODED_FRAME_ASPECT_NO_DATA,
-	AVI_CODED_FRAME_ASPECT_4_3,
-	AVI_CODED_FRAME_ASPECT_16_9
-};
-enum {
-	ACTIVE_ASPECT_RATE_SAME_AS_CODED_FRAME = 0x08,
-	ACTIVE_ASPECT_RATE_4_3,
-	ACTIVE_ASPECT_RATE_16_9,
-	ACTIVE_ASPECT_RATE_14_9
-};
-
-/* External Video Parameter Setting*/
-#define EXT_VIDEO_PARA			0xC0
-#define m_VSYNC_OFFSET			(0xF << 4)
-#define m_VSYNC_POLARITY		(1 << 3)
-#define m_HSYNC_POLARITY		(1 << 2)
-#define m_INTERLACE				(1 << 1)
-#define m_EXT_VIDEO_ENABLE		(1 << 0)
-
-#define v_VSYNC_OFFSET(n)		(n << 4)
-#define v_VSYNC_POLARITY(n)		(n << 3)
-#define v_HSYNC_POLARITY(n)		(n << 2)
-#define v_INTERLACE(n)			(n << 1)
-#define v_EXT_VIDEO_ENABLE(n)	(n << 0) 
-
-#define EXT_VIDEO_PARA_HTOTAL_L		0xC4
-#define EXT_VIDEO_PARA_HTOTAL_H		0xC8
-#define EXT_VIDEO_PARA_HBLANK_L		0xCC
-#define EXT_VIDEO_PARA_HBLANK_H		0xD0
-#define EXT_VIDEO_PARA_HDELAY_L		0xD4
-#define EXT_VIDEO_PARA_HDELAY_H		0xD8
-#define EXT_VIDEO_PARA_HSYNCWIDTH_L	0xDC
-#define EXT_VIDEO_PARA_HSYNCWIDTH_H	0xE0
-
-#define EXT_VIDEO_PARA_VTOTAL_L		0xE4
-#define EXT_VIDEO_PARA_VTOTAL_H		0xE8
-#define EXT_VIDEO_PARA_VBLANK_L		0xF4
-#define EXT_VIDEO_PARA_VDELAY		0xF8
-#define EXT_VIDEO_PARA_VSYNCWIDTH	0xFC
-
-#define PHY_PLL_SPEED				0x158
-	#define v_TEST_EN(n)			(n << 6)
-	#define v_PLLA_BYPASS(n)		(n << 4)
-	#define v_PLLB_SPEED(n)			(n << 2)
-	#define v_PLLA_SPEED(n)			(n)
-	enum {
-		PLL_SPEED_LOWEST = 0,
-		PLL_SPEED_MIDLOW,
-		PLL_SPEED_MIDHIGH,
-		PLL_SPEED_HIGHEST
-	};
-
-#define PHY_PLL_17					0x15c		// PLL A & B config bit 17
-	#define v_PLLA_BIT17(n)			(n << 2)
-	#define v_PLLB_BIT17(n)			(n << 1)
-	
-#define PHY_BGR						0x160
-	#define v_BGR_DISCONNECT(n)		(n << 7)
-	#define v_BGR_V_OFFSET(n)		(n << 4)
-	#define v_BGR_I_OFFSET(n)		(n)
-
-#define PHY_PLLA_1					0x164
-#define PHY_PLLA_2					0x168
-#define PHY_PLLB_1					0x16c
-#define PHY_PLLB_2					0x170
-
-#define PHY_DRIVER_PREEMPHASIS		0x174
-	#define v_TMDS_SWING(n)			(n << 4)
-	#define v_PRE_EMPHASIS(n)		(n)
-	
-#define PHY_PLL_16_AML				0x178		// PLL A & B config bit 16 and AML control
-	#define v_PLLA_BIT16(n)			(n << 5)
-	#define v_PLLB_BIT16(n)			(n << 4)
-	#define v_AML(n)				(n)
-
-/* Interrupt Setting */
-#define INTR_MASK1					0x248
-#define INTR_STATUS1				0x250
-	#define m_INT_HOTPLUG				(1 << 7)
-	#define m_INT_MSENS					(1 << 6)
-	#define m_INT_VSYNC					(1 << 5)
-	#define m_INT_AUDIO_FIFO_FULL		(1 << 4)
-	#define m_INT_EDID_READY			(1 << 2)
-	#define m_INT_EDID_ERR				(1 << 1)
-#define INTR_MASK2					0x24c
-#define INTR_STATUS2				0x254
-	#define m_INT_HDCP_ERR				(1 << 7)	// HDCP error detected
-	#define m_INT_BKSV_RPRDY			(1 << 6)	// BKSV list ready from repeater
-	#define m_INT_BKSV_RCRDY			(1 << 5)	// BKSV list ready from receiver
-	#define m_INT_AUTH_DONE				(1 << 4)	// HDCP authentication done
-	#define m_INT_AUTH_READY			(1 << 3)	// HDCP authentication ready
-#define INTR_MASK3					0x258
-#define INTR_STATUS3				0x260
-
-#define INTR_MASK4					0x25c
-#define INTR_STATUS4				0x264
-
-#define DDC_READ_FIFO_ADDR			0x200
-#define DDC_BUS_FREQ_L				0x204
-#define DDC_BUS_FREQ_H				0x208
-#define DDC_BUS_CTRL				0x2dc
-#define DDC_I2C_LEN					0x278
-#define DDC_I2C_OFFSET				0x280
-#define DDC_I2C_CTRL				0x284
-#define DDC_I2C_READ_BUF0			0x288
-#define DDC_I2C_READ_BUF1			0x28c
-#define DDC_I2C_READ_BUF2			0x290
-#define DDC_I2C_READ_BUF3			0x294
-#define DDC_I2C_WRITE_BUF0			0x298
-#define DDC_I2C_WRITE_BUF1			0x29c
-#define DDC_I2C_WRITE_BUF2			0x2a0
-#define DDC_I2C_WRITE_BUF3			0x2a4
-#define DDC_I2C_WRITE_BUF4			0x2ac
-#define DDC_I2C_WRITE_BUF5			0x2b0
-#define DDC_I2C_WRITE_BUF6			0x2b4
-
-#define EDID_SEGMENT_POINTER		0x310
-#define EDID_WORD_ADDR				0x314
-#define EDID_FIFO_ADDR				0x318
-
-#define HPD_MENS_STA				0x37c
-#define m_HOTPLUG_STATUS			(1 << 7)
-#define m_MSEN_STATUS				(1 << 6)
-
-/* HDCP_CTRL */
-#define HDCP_CTRL		0x2bc
-	enum {
-		OUTPUT_DVI = 0,
-		OUTPUT_HDMI
-	};
-	#define m_HDCP_AUTH_START			(1 << 7)	// start hdcp
-	#define m_HDCP_BKSV_PASS			(1 << 6)	// bksv valid
-	#define m_HDCP_BKSV_FAILED			(1 << 5)	// bksv invalid
-	#define m_HDCP_FRAMED_ENCRYPED		(1 << 4)
-	#define m_HDCP_AUTH_STOP			(1 << 3)	// stop hdcp
-	#define m_HDCP_ADV_CIPHER			(1 << 2)	// advanced cipher mode
-	#define m_HDMI_DVI					(1 << 1)
-	#define m_HDCP_RESET				(1 << 0)	// reset hdcp
-	#define v_HDCP_AUTH_START(n)		(n << 7)
-	#define v_HDCP_BKSV_PASS(n)			(n << 6)
-	#define v_HDCP_BKSV_FAILED(n)		(n << 5)
-	#define v_HDCP_FRAMED_ENCRYPED(n)	(n << 4)
-	#define v_HDCP_AUTH_STOP(n)			(n << 3)
-	#define v_HDCP_ADV_CIPHER(n)		(n << 2)
-	#define v_HDMI_DVI(n)				(n << 1)
-	#define v_HDCP_RESET(n)				(n << 0)
-#define HDCP_CTRL2		0x340
-
-/* HDCP Key Memory Access Control */
-#define HDCP_KEY_ACCESS_CTRL1	0x338
-#define HDCP_KEY_ACCESS_CTRL2	0x33c
-	#define m_LOAD_FACSIMILE_HDCP_KEY	(1 << 1)
-	#define m_LOAD_HDCP_KEY				(1 << 0)
-/* HDCP Key Memory Control */
-#define HDCP_KEY_MEM_CTRL	0x348
-	#define m_USE_KEY1		(1 << 6)
-	#define m_USE_KEY2		(1 << 5)
-	#define m_LOAD_AKSV		(1 << 4)
-	#define m_KSV_SELECTED	(1 << 3)
-	#define m_KSV_VALID		(1 << 2)
-	#define m_KEY_VALID		(1 << 1)
-	#define m_KEY_READY		(1 << 0)
-	#define v_USE_KEY1(n)	(n << 6)
-	#define v_USE_KEY2(n)	(n << 5)
-	#define v_LOAD_AKSV(n)	(n << 4)
-
-/* HDCP B device capacity */
-#define HDCP_BCAPS				0x2f8
-	#define m_HDMI_RECEIVED			(1 << 7) //If HDCP receiver support HDMI, this bit must be 1.
-	#define m_REPEATER				(1 << 6)
-	#define m_KSV_FIFO_READY		(1 << 5)
-	#define m_DDC_FAST				(1 << 4)
-	#define m_1_1_FEATURE			(1 << 1)
-	#define m_FAST_REAUTHENTICATION	(1 << 0) //For HDMI, this function is supported whether this bit is enabled or not.
-
-/* HDCP KSV Value */
-#define HDCP_KSV_BYTE0			0x2fc
-#define HDCP_KSV_BYTE1			0x300
-#define HDCP_KSV_BYTE2			0x304
-#define HDCP_KSV_BYTE3			0x308
-#define HDCP_KSV_BYTE4			0x30c
-
-/* HDCP error status */
-#define HDCP_ERROR				0x320
-
-/* HDCP 100 ms timer */
-#define HDCP_TIMER_100MS		0x324
-/* HDCP 5s timer */
-#define HDCP_TIMER_5S			0x328
-
-/* HDCP Key ram address */
-#define HDCP_RAM_KEY_KSV1		0x400
-#define HDCP_RAM_KEY_KSV2		0x407
-#define HDCP_RAM_KEY_PRIVATE	0x40e
-#define HDCP_KEY_LENGTH			0x13C
-
-
-#define HDCP_ENABLE_HW_AUTH		// Enable hardware authentication mode	
-#define HDMI_INTERANL_CLK_DIV	0x19
-
-#define HDMIRdReg(addr)						__raw_readl(hdmi->regbase + addr)
-#define HDMIWrReg(addr, val)        		__raw_writel((val), hdmi->regbase + addr);
-#define HDMIMskReg(temp, addr, msk, val)	\
-	temp = __raw_readl(hdmi->regbase + addr) & (0xFF - (msk)) ; \
-	__raw_writel(temp | ( (val) & (msk) ),  hdmi->regbase + addr); 
-
-/* RK30 HDMI Video Configure Parameters */
-struct rk30_hdmi_video_para {
-	int vic;
-	int input_mode;		//input video data interface
-	int input_color;	//input video color mode
-	int output_mode;	//output hdmi or dvi
-	int output_color;	//output video color mode
-};
-
-/* Color Space Convertion Mode */
-enum {
-	CSC_RGB_0_255_TO_ITU601_16_235 = 0,	//RGB 0-255 input to YCbCr 16-235 output according BT601
-	CSC_RGB_0_255_TO_ITU709_16_235,		//RGB 0-255 input to YCbCr 16-235 output accroding BT709
-	CSC_ITU601_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT601
-	CSC_ITU709_16_235_TO_RGB_16_235,	//YCbCr 16-235 input to RGB 16-235 output according BT709
-	CSC_ITU601_16_235_TO_RGB_0_255,		//YCbCr 16-235 input to RGB 0-255 output according BT601
-	CSC_ITU709_16_235_TO_RGB_0_255		//YCbCr 16-235 input to RGB 0-255 output according BT709
-};
-
-extern int rk30_hdmi_initial(void);
-extern int rk30_hdmi_detect_hotplug(void);
-extern int rk30_hdmi_read_edid(int block, unsigned char *buff);
-extern int rk30_hdmi_removed(void);
-extern int rk30_hdmi_config_video(struct rk30_hdmi_video_para *vpara);
-extern int rk30_hdmi_config_audio(struct hdmi_audio *audio);
-extern void rk30_hdmi_control_output(int enable);
-
-#endif
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_lcdc.c b/drivers/video/rockchip/hdmi/rk30_hdmi_lcdc.c
deleted file mode 100755
index 406837e..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_lcdc.c
+++ /dev/null
@@ -1,527 +0,0 @@
-#include <linux/console.h>
-#include "rk30_hdmi.h"
-#include "rk30_hdmi_hw.h"
-#include<linux/rk_fb.h>
-
-#define OUT_TYPE		SCREEN_HDMI
-#define OUT_FACE		OUT_P888
-#define DCLK_POL		1
-#define SWAP_RB			0
-#define LCD_ACLK		800000000
-
-const struct fb_videomode hdmi_mode [] = {
-	//name				refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag(used for vic)
-//{	"640x480p@60Hz",	60,			640,	480,	25175000,	48,		16,		33,		10,		96,		2,		0,			0,		1	},
-//{	"720x480i@60Hz",	60,			720,	480,	27000000,	114,	38,		15,		4,		124,	3,		0,			1,		6	},
-//{	"720x576i@50Hz",	50,			720,	576,	27000000,	138,	24,		19,		2,		126,	3,		0,			1,		21	},
-{	"720x480p@60Hz",	60,			720,	480,	27000000,	60,		16,		30,		9,		62,		6,		0,			0,		2	},
-{	"720x576p@50Hz",	50,			720,	576,	27000000,	68,		12,		39,		5,		64,		5,		0,			0,		17	},
-//{	"1280x720p@24Hz",	24,			1280,	720,	59400000,	220,	1760,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		60	},
-//{	"1280x720p@25Hz",	25,			1280,	720,	74250000,	220,	2420,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		61	},
-//{	"1280x720p@30Hz",	30,			1280,	720,	74250000,	220,	1760,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		62	},
-{	"1280x720p@50Hz",	50,			1280,	720,	74250000,	220,	440,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		19	},
-{	"1280x720p@60Hz",	60,			1280,	720,	74250000,	220,	110,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		4	},
-//{	"1920x1080p@24Hz",	24,			1920,	1080,	74250000,	148,	638,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		32	},
-//{	"1920x1080p@25Hz",	25,			1920,	1080,	74250000,	148,	528,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		33	},
-//{	"1920x1080p@30Hz",	30,			1920,	1080,	74250000,	148,	88,		36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		34	},	
-//{	"1920x1080i@50Hz_2",50,			1920,	1080,	72000000,	184,	32,		57,		23,		168,	5,		FB_SYNC_HOR_HIGH_ACT,			1,		39	},
-//{	"1920x1080i@50Hz",	50,			1920,	1080,	74250000,	148,	528,	15,		2,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			1,		20	},
-//{	"1920x1080i@60Hz",	60,			1920,	1080,	74250000,	148,	88,		15,		2,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			1,		5	},
-{	"1920x1080p@50Hz",	50,			1920,	1080,	148500000,	148,	528,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		31	},
-{	"1920x1080p@60Hz",	60,			1920,	1080,	148500000,	148,	88,		36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		16	},
-/*
-{	"1440x288p@50Hz",	50,			720,	480,	27000000,	138,	24,		19,		2,		126,	3,		0,			0,		23	},
-{	"2880x576i@50Hz",	50,			1440,	240,	54000000,	276,	48,		19,		2,		252,	3,		0,			1,		25	},
-{	"2880x288p@50Hz",	50,			2880,	480,	54000000,	276,	48,		19,		3,		252,	3,		0,			0,		27	},
-{	"1440x576p@50Hz",	50,			2880,	480,	54000000,	136,	24,		39,		5,		128,	5,		0,			0,		29	},
-{	"2880x576p@50Hz",	50,			1920,	1080,	108000000,	272,	48,		39,		5,		256,	5,		0,			0,		37	},
-{	"1440x240p@60Hz",	60,			1440,	240,	27000000,	114,	38,		15,		4,		124,	3,		0,			0,		8	},
-{	"2880x480i@60Hz",	60,			2880,	480,	54000000,	228,	76,		15,		4,		248,	3,		0,			1,		10	},
-{	"2880x480p@60Hz",	60,			2880,	480,	54000000,	228,	76,		15,		4,		248,	3,		0,			0,		12	},
-{	"1440x480p@60Hz",	60,			1440,	480,	54000000,	120,	32,		30,		9,		124,	6,		0,			0,		14	},
-{	"2880x480p@60Hz",	60,			2880,	480,	54000000,	240,	64,		30,		9,		248,	6,		0,			0,		35	},
-
-{	"1920x1080i@100Hz",	100,		1920,	1080,	148500000,	148,	528,	15,		2,		44,		5,		1,			1,		40	},
-{	"1280x720p@100Hz",	100,		1280,	720,	148500000,	220,	440,	20,		5,		40,		5,		1,			0,		41	},
-{	"720x576p@100Hz",	100,		720,	576,	54000000,	68,		12,		39,		5,		64,		5,		0,			0,		42	},
-{	"1440x576i@100Hz",	100,		1440,	576,	54000000,	138,	24,		19,		2,		12,		3,		0,			1,		44	},
-{	"1920x1080p@100Hz",	100,		1920,	1080,	297000000,	148,	528,	36,		4,		44,		5,		1,			0,		64	},
-
-{	"1920x1080i@120Hz",	120,		1920,	1080,	148500000,	148,	88,		15,		2,		44,		5,		1,			1,		46	},
-{	"1280x720p@120Hz",	120,		1280,	720,	148500000,	220,	110,	20,		5,		40,		5,		1,			0,		47	},
-{	"720x480p@120Hz",	120,		720,	480,	54000000,	60,		16,		30,		9,		62,		6,		0,			0,		48	},
-{	"1440x480i@120Hz",	120,		1440,	480,	54000000,	114,	38,		15,		4,		12,		3,		0,			1,		50	},
-{	"1920x1080p@120Hz",	120,		1920,	1080,	297000000,	148,	88,		36,		4,		44,		5,		1,			0,		63	},
-
-{	"720x576p@200Hz",	200,		720,	576,	108000000,	68,		12,		39,		5,		64,		5,		0,			0,		52	},
-{	"1440x576i@200Hz",	200,		1920,	1080,	108000000,	138,	24,		19,		2,		12,		3,		0,			1,		54	},
-
-{	"720x480p@240Hz",	240,		720,	480,	108000000,	60,		16,		30,		9,		62,		6,		0,			0,		56	},
-{	"1440x480i@240Hz",	240,		1440,	480,	108000000,	114,	38,		15,		4,		12,		3,		0,			1,		58	},
-*/
-
-};
-
-void hdmi_init_lcdc(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info)
-{
-	hdmi_set_info(screen, HDMI_VIDEO_DEFAULT_MODE);
-}
-
-int hdmi_set_info(struct rk29fb_screen *screen, unsigned int vic)
-{
-    int i;
-    
-    if(screen == NULL)
-    	return -1;
-    
-    if(vic == 0)
-    	vic = HDMI_VIDEO_DEFAULT_MODE;
-    	
-    for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
-    {
-    	if(hdmi_mode[i].flag == vic)
-    		break;
-    }
-    if(i == ARRAY_SIZE(hdmi_mode))
-    	return -1;
-    
-    memset(screen, 0, sizeof(struct rk29fb_screen));
-    
-    /* screen type & face */
-    screen->type = OUT_TYPE;
-    screen->face = OUT_FACE;
-
-    /* Screen size */
-    screen->x_res = hdmi_mode[i].xres;
-    screen->y_res = hdmi_mode[i].yres;
-    
-    /* Timing */
-    screen->pixclock = hdmi_mode[i].pixclock;
-	screen->lcdc_aclk = LCD_ACLK;
-	screen->left_margin = hdmi_mode[i].left_margin;
-	screen->right_margin = hdmi_mode[i].right_margin;
-	screen->hsync_len = hdmi_mode[i].hsync_len;
-	screen->upper_margin = hdmi_mode[i].upper_margin;
-	screen->lower_margin = hdmi_mode[i].lower_margin;
-	screen->vsync_len = hdmi_mode[i].vsync_len;
-
-	/* Pin polarity */
-	if(FB_SYNC_HOR_HIGH_ACT & hdmi_mode[i].sync)
-		screen->pin_hsync = 1;
-	else
-		screen->pin_hsync = 0;
-	if(FB_SYNC_VERT_HIGH_ACT & hdmi_mode[i].sync)
-		screen->pin_vsync = 1;
-	else
-		screen->pin_vsync = 0;
-	screen->pin_den = 0;
-	screen->pin_dclk = DCLK_POL;
-
-	/* Swap rule */
-    screen->swap_rb = SWAP_RB;
-    screen->swap_rg = 0;
-    screen->swap_gb = 0;
-    screen->swap_delta = 0;
-    screen->swap_dumy = 0;
-
-    /* Operation function*/
-    screen->init = NULL;
-    screen->standby = NULL;
-    
-    return 0;
-}
-
-static void hdmi_show_sink_info(struct hdmi *hdmi)
-{
-	struct list_head *pos, *head = &hdmi->edid.modelist;
-	struct fb_modelist *modelist;
-	struct fb_videomode *m;
-	int i;
-	struct hdmi_audio *audio;
-
-	hdmi_dbg(hdmi->dev, "******** Show Sink Info ********\n");
-	hdmi_dbg(hdmi->dev, "Support video mode: \n");
-	list_for_each(pos, head) {
-		modelist = list_entry(pos, struct fb_modelist, list);
-		m = &modelist->mode;
-		hdmi_dbg(hdmi->dev, "	%s.\n", m->name);
-	}
-	
-	for(i = 0; i < hdmi->edid.audio_num; i++)
-	{
-		audio = &(hdmi->edid.audio[i]);
-		switch(audio->type)
-		{
-			case HDMI_AUDIO_LPCM:
-				hdmi_dbg(hdmi->dev, "Support audio type: LPCM\n");
-				break;
-			case HDMI_AUDIO_AC3:
-				hdmi_dbg(hdmi->dev, "Support audio type: AC3\n");
-				break;
-			case HDMI_AUDIO_MPEG1:
-				hdmi_dbg(hdmi->dev, "Support audio type: MPEG1\n");
-				break;
-			case HDMI_AUDIO_MP3:
-				hdmi_dbg(hdmi->dev, "Support audio type: MP3\n");
-				break;
-			case HDMI_AUDIO_MPEG2:
-				hdmi_dbg(hdmi->dev, "Support audio type: MPEG2\n");
-				break;
-			case HDMI_AUDIO_AAC_LC:
-				hdmi_dbg(hdmi->dev, "Support audio type: AAC\n");
-				break;
-			case HDMI_AUDIO_DTS:
-				hdmi_dbg(hdmi->dev, "Support audio type: DTS\n");
-				break;
-			case HDMI_AUDIO_ATARC:
-				hdmi_dbg(hdmi->dev, "Support audio type: ATARC\n");
-				break;
-			case HDMI_AUDIO_DSD:
-				hdmi_dbg(hdmi->dev, "Support audio type: DSD\n");
-				break;
-			case HDMI_AUDIO_E_AC3:
-				hdmi_dbg(hdmi->dev, "Support audio type: E-AC3\n");
-				break;
-			case HDMI_AUDIO_DTS_HD:
-				hdmi_dbg(hdmi->dev, "Support audio type: DTS-HD\n");
-				break;
-			case HDMI_AUDIO_MLP:
-				hdmi_dbg(hdmi->dev, "Support audio type: MLP\n");
-				break;
-			case HDMI_AUDIO_DST:
-				hdmi_dbg(hdmi->dev, "Support audio type: DST\n");
-				break;
-			case HDMI_AUDIO_WMA_PRO:
-				hdmi_dbg(hdmi->dev, "Support audio type: WMP-PRO\n");
-				break;
-			default:
-				hdmi_dbg(hdmi->dev, "Support audio type: Unkown\n");
-				break;
-		}
-		
-		hdmi_dbg(hdmi->dev, "Support audio sample rate: \n");
-		if(audio->rate & HDMI_AUDIO_FS_32000)
-			hdmi_dbg(hdmi->dev, "	32000\n");
-		if(audio->rate & HDMI_AUDIO_FS_44100)
-			hdmi_dbg(hdmi->dev, "	44100\n");
-		if(audio->rate & HDMI_AUDIO_FS_48000)
-			hdmi_dbg(hdmi->dev, "	48000\n");
-		if(audio->rate & HDMI_AUDIO_FS_88200)
-			hdmi_dbg(hdmi->dev, "	88200\n");
-		if(audio->rate & HDMI_AUDIO_FS_96000)
-			hdmi_dbg(hdmi->dev, "	96000\n");
-		if(audio->rate & HDMI_AUDIO_FS_176400)
-			hdmi_dbg(hdmi->dev, "	176400\n");
-		if(audio->rate & HDMI_AUDIO_FS_192000)
-			hdmi_dbg(hdmi->dev, "	192000\n");
-		
-		hdmi_dbg(hdmi->dev, "Support audio word lenght: \n");
-		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_16bit)
-			hdmi_dbg(hdmi->dev, "	16bit\n");
-		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_20bit)
-			hdmi_dbg(hdmi->dev, "	20bit\n");
-		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_24bit)
-			hdmi_dbg(hdmi->dev, "	24bit\n");
-	}
-	hdmi_dbg(hdmi->dev, "******** Show Sink Info ********\n");
-}
-
-/**
- * hdmi_ouputmode_select - select hdmi transmitter output mode: hdmi or dvi?
- * @hdmi: handle of hdmi
- * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCESS means success.
- */
-int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
-{
-	struct list_head *head = &hdmi->edid.modelist;
-	struct fb_monspecs	*specs = hdmi->edid.specs;
-	struct fb_videomode *modedb = NULL;
-	int i, pixclock;
-	
-	if(edid_ok != HDMI_ERROR_SUCESS) {
-		dev_err(hdmi->dev, "warning: EDID error, assume sink as HDMI !!!!");
-		hdmi->edid.sink_hdmi = 1;
-	}
-
-	if(edid_ok != HDMI_ERROR_SUCESS) {
-		hdmi->edid.ycbcr444 = 0;
-		hdmi->edid.ycbcr422 = 0;
-		hdmi->autoconfig = HDMI_DISABLE;
-	}
-	if(head->next == head) {
-		dev_info(hdmi->dev, "warning: no CEA video mode parsed from EDID !!!!");
-		// If EDID get error, list all system supported mode.
-		// If output mode is set to DVI and EDID is ok, check
-		// the output timing.
-		
-		if(hdmi->edid.sink_hdmi == 0 && specs && specs->modedb_len) {
-			/* Get max resolution timing */
-			modedb = &specs->modedb[0];
-			for (i = 0; i < specs->modedb_len; i++) {
-				if(specs->modedb[i].xres > modedb->xres)
-					modedb = &specs->modedb[i];
-				else if(specs->modedb[i].yres > modedb->yres)
-					modedb = &specs->modedb[i];
-			}
-			// For some monitor, the max pixclock read from EDID is smaller
-			// than the clock of max resolution mode supported. We fix it.
-			pixclock = PICOS2KHZ(modedb->pixclock);
-			pixclock /= 250;
-			pixclock *= 250;
-			pixclock *= 1000;
-			if(pixclock == 148250000)
-				pixclock = 148500000;
-			if(pixclock > specs->dclkmax)
-				specs->dclkmax = pixclock;
-		}
-		
-		for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
-			if(modedb) {
-				if( (hdmi_mode[i].pixclock < specs->dclkmin) || 
-					(hdmi_mode[i].pixclock > specs->dclkmax) || 
-					(hdmi_mode[i].refresh < specs->vfmin) ||
-					(hdmi_mode[i].refresh > specs->vfmax) ||
-					(hdmi_mode[i].xres > modedb->xres) ||
-					(hdmi_mode[i].yres > modedb->yres) )
-				continue;
-			}
-			hdmi_add_videomode(&hdmi_mode[i], head);
-		}
-	}
-	
-	#ifdef HDMI_DEBUG
-	hdmi_show_sink_info(hdmi);
-	#endif
-	return HDMI_ERROR_SUCESS;
-}
-/**
- * hdmi_videomode_compare - compare 2 videomodes
- * @mode1: first videomode
- * @mode2: second videomode
- *
- * RETURNS:
- * 1 if mode1 > mode2, 0 if mode1 = mode2, -1 mode1 < mode2
- */
-static int hdmi_videomode_compare(const struct fb_videomode *mode1,
-		     const struct fb_videomode *mode2)
-{
-	if(mode1->xres > mode2->xres)
-		return 1;
-	else if(mode1->xres == mode2->xres)
-	{ 
-		if(mode1->yres > mode2->yres)
-			return 1;
-		else if(mode1->yres == mode2->yres)
-		{
-			if(mode1->pixclock > mode2->pixclock)	
-				return 1;
-			else if(mode1->pixclock == mode2->pixclock)
-			{	
-				if(mode1->refresh > mode2->refresh)
-					return 1;
-				else if(mode1->refresh == mode2->refresh) 
-					return 0;
-			}
-		}
-	}
-	return -1;		
-}
-/**
- * hdmi_add_videomode: adds videomode entry to modelist
- * @mode: videomode to add
- * @head: struct list_head of modelist
- *
- * NOTES:
- * Will only add unmatched mode entries
- */
-int hdmi_add_videomode(const struct fb_videomode *mode, struct list_head *head)
-{
-	struct list_head *pos;
-	struct fb_modelist *modelist, *modelist_new;
-	struct fb_videomode *m;
-	int i, found = 0;
-
-	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
-    {
-    	m =(struct fb_videomode*) &hdmi_mode[i];
-    	if (fb_mode_is_equal(m, mode)) {
-			found = 1;
-			break;
-		}
-    }
-
-	if (found) {
-		list_for_each(pos, head) {
-			modelist = list_entry(pos, struct fb_modelist, list);
-			m = &modelist->mode;
-			if (fb_mode_is_equal(m, mode)) {
-			// m == mode	
-				return 0;
-			}
-			else
-			{ 
-				if(hdmi_videomode_compare(m, mode) == -1) {
-					break;
-				}
-			}
-		}
-
-		modelist_new = kmalloc(sizeof(struct fb_modelist),
-				  GFP_KERNEL);					
-		if (!modelist_new)
-			return -ENOMEM;	
-		modelist_new->mode = hdmi_mode[i];
-		list_add_tail(&modelist_new->list, pos);
-	}
-	
-	return 0;
-}
-
-/**
- * hdmi_videomode_to_vic: transverse video mode to vic
- * @vmode: videomode to transverse
- * 
- */
-int hdmi_videomode_to_vic(struct fb_videomode *vmode)
-{
-	unsigned char vic = 0;
-	int i = 0;
-	
-	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
-	{
-		if(	vmode->vmode == hdmi_mode[i].vmode &&
-			vmode->refresh == hdmi_mode[i].refresh &&
-			vmode->xres == hdmi_mode[i].xres && 
-			vmode->left_margin == hdmi_mode[i].left_margin &&
-			vmode->right_margin == hdmi_mode[i].right_margin &&
-			vmode->upper_margin == hdmi_mode[i].upper_margin &&
-			vmode->lower_margin == hdmi_mode[i].lower_margin && 
-			vmode->hsync_len == hdmi_mode[i].hsync_len && 
-			vmode->vsync_len == hdmi_mode[i].vsync_len)
-		{
-			if( (vmode->vmode == FB_VMODE_NONINTERLACED && vmode->yres == hdmi_mode[i].yres) || 
-				(vmode->vmode == FB_VMODE_INTERLACED && vmode->yres == hdmi_mode[i].yres/2))
-			{								
-				vic = hdmi_mode[i].flag;
-				break;
-			}
-		}
-	}
-	return vic;
-}
-
-/**
- * hdmi_vic_to_videomode: transverse vic mode to video mode
- * @vmode: vic to transverse
- * 
- */
-const struct fb_videomode* hdmi_vic_to_videomode(int vic)
-{
-	int i;
-	
-	if(vic == 0)
-		return NULL;
-	
-	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
-	{
-		if(hdmi_mode[i].flag == vic)
-			return &hdmi_mode[i];
-	}
-	return NULL;
-}
-
-/**
- * hdmi_find_best_mode: find the video mode nearest to input vic
- * @hdmi: 
- * @vic: input vic
- * 
- * NOTES:
- * If vic is zero, return the high resolution video mode vic.
- */
-int hdmi_find_best_mode(struct hdmi* hdmi, int vic)
-{
-	struct list_head *pos, *head = &hdmi->edid.modelist;
-	struct fb_modelist *modelist;
-	struct fb_videomode *m = NULL;
-	int found = 0;
-	
-	if(vic)
-	{
-		list_for_each(pos, head) {
-			modelist = list_entry(pos, struct fb_modelist, list);
-			m = &modelist->mode;
-			if(m->flag == vic)
-			{
-				found = 1;	
-				break;
-			}
-		}
-	}
-	if( (vic == 0 || found == 0) && head->next != head)
-	{
-		modelist = list_entry(head->next, struct fb_modelist, list);
-		m = &modelist->mode;
-	}
-	if(m != NULL)
-		return m->flag;
-	else
-		return 0;
-}
-
-const char *hdmi_get_video_mode_name(unsigned char vic)
-{
-	int i;
-	
-	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
-	{
-		if(vic == hdmi_mode[i].flag)
-			break;
-	}
-	if(i == ARRAY_SIZE(hdmi_mode))
-		return NULL;
-	else
-		return hdmi_mode[i].name;
-}
-
-/**
- * hdmi_switch_fb: switch lcdc mode to required video mode
- * @hdmi: 
- * @type:
- * 
- * NOTES:
- * 
- */
-int hdmi_switch_fb(struct hdmi *hdmi, int vic)
-{
-	int rc = 0;
-
-	if(hdmi->vic == 0)
-		hdmi->vic = HDMI_VIDEO_DEFAULT_MODE;
-		
-	if(hdmi->lcdc == NULL || hdmi->lcdc->screen == NULL) {
-		dev_err(hdmi->dev, "lcdc %d not exist\n", HDMI_SOURCE_DEFAULT);
-		return -1;
-	}
-
-	rc = hdmi_set_info(hdmi->lcdc->screen, hdmi->vic);
-
-	if(rc == 0) {		
-		rk_fb_switch_screen(hdmi->lcdc->screen, 1, HDMI_SOURCE_DEFAULT);
-		rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, HDMI_SOURCE_DEFAULT);
-	}
-	return rc;
-}
-
-/**
- * hdmi_get_status: get hdmi hotplug status
- * 
- * NOTES:
- * 
- */
-int hdmi_get_hotplug(void)
-{
-	if(hdmi)
-		return hdmi->hotplug;
-	else
-		return HDMI_HPD_REMOVED;
-}
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_sysfs.c b/drivers/video/rockchip/hdmi/rk30_hdmi_sysfs.c
deleted file mode 100755
index 828b771..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_sysfs.c
+++ /dev/null
@@ -1,177 +0,0 @@
-#include <linux/ctype.h>
-#include <linux/string.h>
-#include <linux/display-sys.h>
-#include <linux/interrupt.h>
-#include "rk30_hdmi.h"
-
-static int hdmi_get_enable(struct rk_display_device *device)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int enable;
-	
-	mutex_lock(&hdmi->enable_mutex);
-	enable = hdmi->enable;
-	mutex_unlock(&hdmi->enable_mutex);
-	
-	return enable;
-}
-
-static int hdmi_set_enable(struct rk_display_device *device, int enable)
-{
-	struct hdmi *hdmi = device->priv_data;
-	
-	mutex_lock(&hdmi->enable_mutex);
-	if(hdmi->enable == enable) {
-		mutex_unlock(&hdmi->enable_mutex);
-		return 0;
-	}
-	hdmi->enable = enable;
-	
-	if(hdmi->suspend ) {
-		mutex_unlock(&hdmi->enable_mutex);
-		return 0;
-	}
-	
-	if(enable == 0) {
-		disable_irq(hdmi->irq);
-		mutex_unlock(&hdmi->enable_mutex);
-		hdmi->command = HDMI_CONFIG_ENABLE;
-		queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
-	}
-	else {
-		enable_irq(hdmi->irq);
-		mutex_unlock(&hdmi->enable_mutex);
-	}
-	return 0;
-}
-
-static int hdmi_get_status(struct rk_display_device *device)
-{
-	struct hdmi *hdmi = device->priv_data;
-	if(hdmi->hotplug == HDMI_HPD_ACTIVED)
-		return 1;
-	else
-		return 0;
-}
-
-static int hdmi_get_modelist(struct rk_display_device *device, struct list_head **modelist)
-{
-	struct hdmi *hdmi = device->priv_data;
-	if(!hdmi->hotplug)
-		return -1;
-	*modelist = &hdmi->edid.modelist;
-	return 0;
-}
-
-static int hdmi_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
-{
-	struct hdmi *hdmi = device->priv_data;
-	int vic = hdmi_videomode_to_vic(mode);
-	
-	if(!hdmi->hotplug)
-		return -1;
-	hdmi->autoconfig = HDMI_DISABLE;
-	if(vic && hdmi->vic != vic)
-	{
-		hdmi->vic = vic;
-		hdmi->command = HDMI_CONFIG_VIDEO;
-		init_completion(&hdmi->complete);
-		hdmi->wait = 1;
-		queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
-		wait_for_completion_interruptible_timeout(&hdmi->complete,
-								msecs_to_jiffies(10000));
-	}
-	return 0;
-}
-
-static int hdmi_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
-{
-	struct hdmi *hdmi = device->priv_data;
-	struct fb_videomode *vmode;
-	
-	if(!hdmi->hotplug)
-		return -1;
-		
-	vmode = (struct fb_videomode*) hdmi_vic_to_videomode(hdmi->vic);
-	if(unlikely(vmode == NULL))
-		return -1;
-	*mode = *vmode;
-	return 0;
-}
-
-static int hdmi_set_scale(struct rk_display_device *device, int direction, int value)
-{
-	struct hdmi *hdmi = device->priv_data;
-	
-	if(!hdmi || value < 0 || value > 100)
-		return -1;
-			
-	if(direction == DISPLAY_SCALE_X)
-		hdmi->xscale = value;
-	else if(direction == DISPLAY_SCALE_Y)
-		hdmi->yscale = value;
-	else
-		return -1;
-	rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, HDMI_SOURCE_DEFAULT);
-	return 0;
-}
-
-static int hdmi_get_scale(struct rk_display_device *device, int direction)
-{
-	struct hdmi *hdmi = device->priv_data;
-	
-	if(!hdmi)
-		return -1;
-		
-	if(direction == DISPLAY_SCALE_X)
-		return hdmi->xscale;
-	else if(direction == DISPLAY_SCALE_Y)
-		return hdmi->yscale;
-	else
-		return -1;
-}
-
-struct rk_display_ops hdmi_display_ops = {
-	.setenable = hdmi_set_enable,
-	.getenable = hdmi_get_enable,
-	.getstatus = hdmi_get_status,
-	.getmodelist = hdmi_get_modelist,
-	.setmode = hdmi_set_mode,
-	.getmode = hdmi_get_mode,
-	.setscale = hdmi_set_scale,
-	.getscale = hdmi_get_scale,
-};
-
-#if 1
-static int hdmi_display_probe(struct rk_display_device *device, void *devdata)
-{
-	device->owner = THIS_MODULE;
-	strcpy(device->type, "HDMI");
-	device->priority = DISPLAY_PRIORITY_HDMI;
-//	device->name = kmalloc(strlen(name), GFP_KERNEL);
-//	if(device->name)
-//	{
-//		strcpy(device->name, name);
-//	}
-	device->priv_data = devdata;
-	device->ops = &hdmi_display_ops;
-	return 1;
-}
-
-static struct rk_display_driver display_hdmi = {
-	.probe = hdmi_display_probe,
-};
-
-static struct rk_display_device *display_device_hdmi = NULL;
-
-void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent)
-{
-	display_device_hdmi = rk_display_device_register(&display_hdmi, parent, hdmi);
-}
-
-void hdmi_unregister_display_sysfs(struct hdmi *hdmi)
-{
-	if(display_device_hdmi)
-		rk_display_device_unregister(display_device_hdmi);
-}
-#endif
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk30_hdmi_task.c b/drivers/video/rockchip/hdmi/rk30_hdmi_task.c
deleted file mode 100755
index cbee83a..0000000
--- a/drivers/video/rockchip/hdmi/rk30_hdmi_task.c
+++ /dev/null
@@ -1,312 +0,0 @@
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include "rk30_hdmi.h"
-#include "rk30_hdmi_hw.h"
-
-#ifdef CONFIG_HDMI_RK30_CTL_CODEC
-extern void codec_set_spk(bool on);
-#endif
-
-#define HDMI_MAX_TRY_TIMES	1
-
-static char *envp[] = {"INTERFACE=HDMI", NULL};
-
-static void hdmi_sys_show_state(int state)
-{
-	switch(state)
-	{
-		case HDMI_SLEEP:
-			dev_printk(KERN_INFO, hdmi->dev, "HDMI_SLEEP\n");
-			break;
-		case HDMI_INITIAL:
-			dev_printk(KERN_INFO, hdmi->dev, "HDMI_INITIAL\n");
-			break;
-		case WAIT_HOTPLUG:
-			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HOTPLUG\n");
-			break;
-		case READ_PARSE_EDID:
-			dev_printk(KERN_INFO, hdmi->dev, "READ_PARSE_EDID\n");
-			break;
-		case WAIT_HDMI_ENABLE:
-			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HDMI_ENABLE\n");
-			break;
-		case SYSTEM_CONFIG:
-			dev_printk(KERN_INFO, hdmi->dev, "SYSTEM_CONFIG\n");
-			break;
-		case CONFIG_VIDEO:
-			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_VIDEO\n");
-			break;
-		case CONFIG_AUDIO:
-			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_AUDIO\n");
-			break;
-		case PLAY_BACK:
-			dev_printk(KERN_INFO, hdmi->dev, "PLAY_BACK\n");
-			break;
-		default:
-			dev_printk(KERN_INFO, hdmi->dev, "Unkown State %d\n", state);
-			break;
-	}
-}
-
-int hdmi_sys_init(void)
-{
-	hdmi->pwr_mode			= PWR_SAVE_MODE_A;
-	hdmi->hotplug			= HDMI_HPD_REMOVED;
-	hdmi->state				= HDMI_SLEEP;
-	hdmi->enable			= HDMI_ENABLE;
-	hdmi->autoconfig		= HDMI_AUTO_CONFIGURE;
-	hdmi->display			= HDMI_DISABLE;
-	
-	hdmi->vic				= HDMI_VIDEO_DEFAULT_MODE;
-	hdmi->audio.channel 	= HDMI_AUDIO_DEFAULT_CHANNEL;
-	hdmi->audio.rate		= HDMI_AUDIO_DEFAULT_RATE;
-	hdmi->audio.word_length	= HDMI_AUDIO_DEFAULT_WORD_LENGTH;
-	
-	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
-	INIT_LIST_HEAD(&hdmi->edid.modelist);
-	return 0;
-}
-
-void hdmi_sys_remove(void)
-{
-	fb_destroy_modelist(&hdmi->edid.modelist);
-	if(hdmi->edid.audio)
-		kfree(hdmi->edid.audio);
-	if(hdmi->edid.specs)
-	{
-		if(hdmi->edid.specs->modedb)
-			kfree(hdmi->edid.specs->modedb);
-		kfree(hdmi->edid.specs);
-	}
-	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
-	INIT_LIST_HEAD(&hdmi->edid.modelist);
-	hdmi->display	= HDMI_DISABLE;
-	rk_fb_switch_screen(hdmi->lcdc->screen, 0, HDMI_SOURCE_DEFAULT);
-	kobject_uevent_env(&hdmi->dev->kobj, KOBJ_REMOVE, envp);
-	#ifdef CONFIG_SWITCH
-	switch_set_state(&(hdmi->switch_hdmi), 0);
-	#endif
-	#ifdef CONFIG_HDMI_RK30_CTL_CODEC
-	codec_set_spk(1);
-	#endif
-}
-
-static void hdmi_sys_sleep(void)
-{
-	mutex_lock(&hdmi->enable_mutex);
-	if(hdmi->enable)
-		disable_irq(hdmi->irq);				
-	hdmi->state = HDMI_SLEEP;
-	rk30_hdmi_removed();
-	if(hdmi->enable)
-		enable_irq(hdmi->irq);
-	mutex_unlock(&hdmi->enable_mutex);
-}
-
-static int hdmi_process_command(void)
-{
-	int change, state = hdmi->state;
-	
-	change = hdmi->command;
-	if(change != HDMI_CONFIG_NONE)	
-	{		
-		hdmi->command = HDMI_CONFIG_NONE;
-		switch(change)
-		{	
-			case HDMI_CONFIG_ENABLE:
-				/* disable HDMI */
-				mutex_lock(&hdmi->enable_mutex);
-				if(!hdmi->enable || hdmi->suspend)
-				{
-					if(hdmi->hotplug == HDMI_HPD_ACTIVED)
-						hdmi_sys_remove();
-					hdmi->state = HDMI_SLEEP;
-					hdmi->hotplug = HDMI_HPD_REMOVED;
-					rk30_hdmi_removed();
-					state = HDMI_SLEEP;
-				}
-				mutex_unlock(&hdmi->enable_mutex);
-				if(hdmi->wait == 1) {
-					complete(&hdmi->complete);
-					hdmi->wait = 0;	
-				}
-				break;	
-			case HDMI_CONFIG_COLOR:
-				if(state > CONFIG_VIDEO)
-					state = CONFIG_VIDEO;	
-				break;
-			case HDMI_CONFIG_HDCP:
-				break;
-			case HDMI_CONFIG_DISPLAY:
-				break;
-			case HDMI_CONFIG_AUDIO:
-				if(state > CONFIG_AUDIO)
-					state = CONFIG_AUDIO;
-				break;
-			case HDMI_CONFIG_VIDEO:
-			default:
-				if(state > SYSTEM_CONFIG)
-					state = SYSTEM_CONFIG;
-				else
-				{
-					if(hdmi->wait == 1) {
-						complete(&hdmi->complete);
-						hdmi->wait = 0;	
-					}					
-				}
-				break;
-		}
-	}
-	else if(state == HDMI_SLEEP)
-		state = WAIT_HOTPLUG;
-	return state;
-}
-
-static DEFINE_MUTEX(work_mutex);
-
-void hdmi_work(struct work_struct *work)
-{
-	int hotplug, state_last;
-	int rc = HDMI_ERROR_SUCESS, trytimes = 0;
-	struct rk30_hdmi_video_para video;
-	
-	mutex_lock(&work_mutex);
-	/* Process hdmi command */
-	hdmi->state = hdmi_process_command();
-	
-	if(!hdmi->enable || hdmi->suspend) {
-		mutex_unlock(&work_mutex);
-		return;
-	}
-	hotplug = rk30_hdmi_detect_hotplug();
-	hdmi_dbg(hdmi->dev, "[%s] hotplug %02x curvalue %d\n", __FUNCTION__, hotplug, hdmi->hotplug);
-	
-	if(hotplug != hdmi->hotplug)
-	{
-		if(hotplug  == HDMI_HPD_ACTIVED){
-			hdmi->state = READ_PARSE_EDID;
-		}
-		else if(hdmi->hotplug == HDMI_HPD_ACTIVED) {
-			hdmi_sys_remove();
-			hdmi->hotplug = hotplug;
-			if(hotplug == HDMI_HPD_REMOVED)
-				hdmi_sys_sleep();
-			else {
-				hdmi->state = WAIT_HOTPLUG;
-				rk30_hdmi_removed();
-			}
-			if(hdmi->wait == 1) {
-				complete(&hdmi->complete);
-				hdmi->wait = 0;	
-			}
-			mutex_unlock(&work_mutex);
-			return;
-		}
-		else if(hotplug == HDMI_HPD_REMOVED) {
-			hdmi->state = HDMI_SLEEP;
-			rk30_hdmi_removed();
-		}
-		hdmi->hotplug  = hotplug;
-	}
-	else if(hotplug == HDMI_HPD_REMOVED)
-		hdmi_sys_sleep();
-	
-	do {
-		hdmi_sys_show_state(hdmi->state);
-		state_last = hdmi->state;
-		switch(hdmi->state)
-		{
-			case READ_PARSE_EDID:
-				rc = hdmi_sys_parse_edid(hdmi);
-				if(rc == HDMI_ERROR_SUCESS)
-				{
-					hdmi->state = SYSTEM_CONFIG;	
-					kobject_uevent_env(&hdmi->dev->kobj, KOBJ_ADD, envp);
-					#ifdef CONFIG_SWITCH
-					switch_set_state(&(hdmi->switch_hdmi), 1);
-					#endif
-					#ifdef CONFIG_HDMI_RK30_CTL_CODEC
-					codec_set_spk(0);
-					#endif
-				}
-				break;
-			case SYSTEM_CONFIG:
-				if(hdmi->autoconfig)	
-					hdmi->vic = hdmi_find_best_mode(hdmi, 0);
-				else
-					hdmi->vic = hdmi_find_best_mode(hdmi, hdmi->vic);
-				rc = hdmi_switch_fb(hdmi, hdmi->vic);
-				if(rc == HDMI_ERROR_SUCESS)
-					hdmi->state = CONFIG_VIDEO;
-				break;
-			case CONFIG_VIDEO:
-				hdmi->display = HDMI_DISABLE;
-				video.vic = hdmi->vic;
-				video.input_mode = VIDEO_INPUT_RGB_YCBCR_444;
-				video.input_color = VIDEO_INPUT_COLOR_RGB;//VIDEO_INPUT_COLOR_YCBCR
-				video.output_mode = hdmi->edid.sink_hdmi;
-				
-				if(hdmi->edid.ycbcr444)
-					video.output_color = VIDEO_OUTPUT_YCBCR444;
-				else if(hdmi->edid.ycbcr422)
-					video.output_color = VIDEO_OUTPUT_YCBCR422;
-				else
-					video.output_color = VIDEO_OUTPUT_RGB444;
-				// For DVI, output RGB
-				if(hdmi->edid.sink_hdmi == 0)
-					video.output_color = VIDEO_OUTPUT_RGB444;
-				
-				rc = rk30_hdmi_config_video(&video);
-				if(rc == HDMI_ERROR_SUCESS)
-				{
-					if(hdmi->edid.sink_hdmi)
-						hdmi->state = CONFIG_AUDIO;
-					else
-						hdmi->state = PLAY_BACK;
-				}
-				break;
-			case CONFIG_AUDIO:
-				rc = rk30_hdmi_config_audio(&(hdmi->audio));
-							
-				if(rc == HDMI_ERROR_SUCESS)
-					hdmi->state = PLAY_BACK;
-				break;
-			case PLAY_BACK:
-				if(hdmi->display != HDMI_ENABLE) {
-					rk30_hdmi_control_output(HDMI_ENABLE);
-					hdmi->display = HDMI_ENABLE;
-					if(hdmi->hdcp_cb) {
-						hdmi->hdcp_cb();
-					}
-				}
-				
-				if(hdmi->wait == 1) {	
-					complete(&hdmi->complete);
-					hdmi->wait = 0;						
-				}
-				break;
-			default:
-				break;
-		}
-		if(rc != HDMI_ERROR_SUCESS)
-		{
-			trytimes++;
-			msleep(10);
-		}
-		if(hdmi->state != state_last) 
-			trytimes = 0;
-	
-	}while((hdmi->state != state_last || (rc != HDMI_ERROR_SUCESS) ) && trytimes < HDMI_MAX_TRY_TIMES);
-	
-//	if(trytimes == HDMI_MAX_TRY_TIMES)
-//	{
-//		if(hdmi->hotplug) {
-//			hdmi_sys_remove();
-//			hdmi->hotplug = HDMI_HPD_REMOVED;
-//			hdmi_sys_sleep();
-//
-//		}
-//	}
-	hdmi_dbg(hdmi->dev, "[%s] done\n", __FUNCTION__);
-	mutex_unlock(&work_mutex);
-}
\ No newline at end of file
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi.h b/drivers/video/rockchip/hdmi/rk_hdmi.h
index 534ba51..5c4cf8a 100755
--- a/drivers/video/rockchip/hdmi/rk_hdmi.h
+++ b/drivers/video/rockchip/hdmi/rk_hdmi.h
@@ -1,6 +1,62 @@
 #ifndef __RK_HDMI_H__
 #define __RK_HDMI_H__
 
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/display-sys.h>
+#ifdef CONFIG_SWITCH
+#include <linux/switch.h>
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <asm/atomic.h>
+#include<linux/rk_screen.h>
+#include <linux/rk_fb.h>
+
+/* default HDMI output video mode */
+#define HDMI_VIDEO_DEFAULT_MODE			HDMI_1280x720p_60Hz//HDMI_1920x1080p_60Hz
+
+// HDMI video source
+enum {
+	HDMI_SOURCE_LCDC0 = 0,
+	HDMI_SOURCE_LCDC1 = 1
+};
+
+/* If HDMI_ENABLE, system will auto configure output mode according to EDID 
+ * If HDMI_DISABLE, system will output mode according to macro HDMI_VIDEO_DEFAULT_MODE
+ */
+#define HDMI_AUTO_CONFIGURE			HDMI_DISABLE
+
+/* default HDMI output audio mode */
+#define HDMI_AUDIO_DEFAULT_CHANNEL		2
+#define HDMI_AUDIO_DEFAULT_RATE			HDMI_AUDIO_FS_44100
+#define HDMI_AUDIO_DEFAULT_WORD_LENGTH	HDMI_AUDIO_WORD_LENGTH_16bit
+
+enum {
+	VIDEO_INPUT_RGB_YCBCR_444 = 0,
+	VIDEO_INPUT_YCBCR422,
+	VIDEO_INPUT_YCBCR422_EMBEDDED_SYNC,
+	VIDEO_INPUT_2X_CLOCK,
+	VIDEO_INPUT_2X_CLOCK_EMBEDDED_SYNC,
+	VIDEO_INPUT_RGB444_DDR,
+	VIDEO_INPUT_YCBCR422_DDR
+};
+
+enum {
+	VIDEO_OUTPUT_RGB444 = 0,
+	VIDEO_OUTPUT_YCBCR444,
+	VIDEO_OUTPUT_YCBCR422
+};
+
+enum {
+	VIDEO_INPUT_COLOR_RGB = 0,
+	VIDEO_INPUT_COLOR_YCBCR
+};
 /********************************************************************
 **                          结构定义                                *
 ********************************************************************/
@@ -185,7 +241,73 @@ struct hdmi_edid {
 	int	audio_num;						//Device supported audio type number
 };
 
-extern const struct fb_videomode hdmi_mode[];
+/* RK HDMI Video Configure Parameters */
+struct hdmi_video_para {
+	int vic;
+	int input_mode;		//input video data interface
+	int input_color;	//input video color mode
+	int output_mode;	//output hdmi or dvi
+	int output_color;	//output video color mode
+};
+
+struct hdmi {
+	struct device	*dev;
+	struct clk		*hclk;				//HDMI AHP clk
+	int             id;
+	int 			regbase;
+	int				irq;
+	int				regbase_phy;
+	int				regsize_phy;
+	struct rk_lcdc_device_driver *lcdc;
+	
+	#ifdef CONFIG_SWITCH
+	struct switch_dev	switch_hdmi;
+	#endif
+	
+	struct workqueue_struct *workqueue;
+	struct delayed_work delay_work;
+	
+	spinlock_t	irq_lock;
+	struct mutex enable_mutex;
+	
+	int wait;
+	struct completion	complete;
+	
+	int suspend;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend	early_suspend;
+#endif
+	
+	struct hdmi_edid edid;
+	int enable;					// Enable HDMI output or not
+	int vic;					// HDMI output video mode code
+	struct hdmi_audio audio;	// HDMI output audio type.
+	
+	int pwr_mode;				// power mode
+	int hotplug;				// hot plug status
+	int state;					// hdmi state machine status
+	int autoconfig;				// if true, auto config hdmi output mode according to EDID.
+	int command;				// HDMI configuration command
+	int display;				// HDMI display status
+	int xscale;					// x direction scale value
+	int yscale;					// y directoon scale value
+	int tmdsclk;				// TDMS Clock frequency
+	
+	int (*insert)(void);
+	int (*remove)(void);
+	void (*control_output)(int enable);
+	int (*config_video)(struct hdmi_video_para *vpara);
+	int (*config_audio)(struct hdmi_audio *audio);
+	int (*detect_hotplug)(void);
+	// call back for edid
+	int (*read_edid)(int block, unsigned char *buff);
+
+	// call back for hdcp operatoion
+	void (*hdcp_cb)(void);
+	void (*hdcp_irq_cb)(int);
+	int (*hdcp_power_on_cb)(void);
+	void (*hdcp_power_off_cb)(void);
+};
 
 #define hdmi_err(dev, format, arg...)		\
 	dev_printk(KERN_ERR , dev , format , ## arg)
@@ -197,7 +319,19 @@ extern const struct fb_videomode hdmi_mode[];
 #define hdmi_dbg(dev, format, arg...)	
 #endif
 
+extern struct hdmi *hdmi;
 extern int hdmi_get_hotplug(void);
 extern int hdmi_set_info(struct rk29fb_screen *screen, unsigned int vic);
 extern void hdmi_init_lcdc(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info);
+extern int hdmi_sys_init(void);
+extern int hdmi_sys_parse_edid(struct hdmi* hdmi);
+extern const char *hdmi_get_video_mode_name(unsigned char vic);
+extern int hdmi_videomode_to_vic(struct fb_videomode *vmode);
+extern const struct fb_videomode* hdmi_vic_to_videomode(int vic);
+extern int hdmi_add_videomode(const struct fb_videomode *mode, struct list_head *head);
+extern struct hdmi_video_timing * hdmi_find_mode(int vic);
+extern int hdmi_find_best_mode(struct hdmi* hdmi, int vic);
+extern int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok);
+extern int hdmi_switch_fb(struct hdmi *hdmi, int vic);
+extern void hdmi_work(struct work_struct *work);
 #endif
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_edid.c b/drivers/video/rockchip/hdmi/rk_hdmi_edid.c
new file mode 100755
index 0000000..6a7d33f
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_edid.c
@@ -0,0 +1,409 @@
+#include "rk_hdmi.h"
+#include "../../edid.h"
+
+#define hdmi_edid_error(fmt, ...) \
+        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+
+#if 0
+#define hdmi_edid_debug(fmt, ...) \
+        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+#else
+#define hdmi_edid_debug(fmt, ...)	
+#endif
+
+typedef enum HDMI_EDID_ERRORCODE
+{
+	E_HDMI_EDID_SUCCESS = 0,
+	E_HDMI_EDID_PARAM,
+	E_HDMI_EDID_HEAD,
+	E_HDMI_EDID_CHECKSUM,
+	E_HDMI_EDID_VERSION,
+	E_HDMI_EDID_UNKOWNDATA,
+	E_HDMI_EDID_NOMEMORY
+}HDMI_EDID_ErrorCode;
+
+static const unsigned int double_aspect_vic[] = {3, 7, 9, 11, 13, 15, 18, 22, 24, 26, 28, 30, 36, 38, 43, 45, 49, 51, 53, 55, 57, 59};
+static int hdmi_edid_checksum(unsigned char *buf)
+{
+	int i;
+	int checksum = 0;
+	
+	for(i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
+		checksum += buf[i];	
+	
+	checksum &= 0xff;
+	
+	if(checksum == 0)
+		return E_HDMI_EDID_SUCCESS;
+	else
+		return E_HDMI_EDID_CHECKSUM;
+}
+
+/*
+	@Des	Parse Detail Timing Descriptor.
+	@Param	buf	:	pointer to DTD data.
+	@Param	pvic:	VIC of DTD descripted.
+ */
+static int hdmi_edid_parse_dtd(unsigned char *block, struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+//	mode->pixclock /= 1000;
+//	mode->pixclock = KHZ2PICOS(mode->pixclock);
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
+				     (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	hdmi_edid_debug("<<<<<<<<Detailed Time>>>>>>>>>\n");
+	hdmi_edid_debug("%d KHz Refresh %d Hz",  PIXEL_CLOCK/1000, mode->refresh);
+	hdmi_edid_debug("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	hdmi_edid_debug("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	hdmi_edid_debug("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	       (VSYNC_POSITIVE) ? "+" : "-");
+	return E_HDMI_EDID_SUCCESS;
+}
+
+static int hdmi_edid_parse_base(unsigned char *buf, int *extend_num, struct hdmi_edid *pedid)
+{
+	int rc, i;
+	
+	if(buf == NULL || extend_num == NULL)
+		return E_HDMI_EDID_PARAM;
+		
+	#ifdef DEBUG	
+	for(i = 0; i < HDMI_EDID_BLOCK_SIZE; i++)
+	{
+		hdmi_edid_debug("%02x ", buf[i]&0xff);
+		if((i+1) % 16 == 0)
+			hdmi_edid_debug("\n");
+	}
+	#endif
+	
+	// Check first 8 byte to ensure it is an edid base block.
+	if( buf[0] != 0x00 ||
+	    buf[1] != 0xFF ||
+	    buf[2] != 0xFF ||
+	    buf[3] != 0xFF ||
+	    buf[4] != 0xFF ||
+	    buf[5] != 0xFF ||
+	    buf[6] != 0xFF ||
+	    buf[7] != 0x00)
+    {
+        hdmi_edid_error("[EDID] check header error\n");
+        return E_HDMI_EDID_HEAD;
+    }
+    
+    *extend_num = buf[0x7e];
+    #ifdef DEBUG
+    hdmi_edid_debug("[EDID] extend block num is %d\n", buf[0x7e]);
+    #endif
+    
+    // Checksum
+    rc = hdmi_edid_checksum(buf);
+    if( rc != E_HDMI_EDID_SUCCESS)
+    {
+    	hdmi_edid_error("[EDID] base block checksum error\n");
+    	return E_HDMI_EDID_CHECKSUM;
+    }
+
+	pedid->specs = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);
+	if(pedid->specs == NULL)
+		return E_HDMI_EDID_NOMEMORY;
+		
+	fb_edid_to_monspecs(buf, pedid->specs);
+	
+    return E_HDMI_EDID_SUCCESS;
+}
+
+// Parse CEA Short Video Descriptor
+static int hdmi_edid_get_cea_svd(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	const struct fb_videomode *mode;
+	int count, i, j, vic;
+
+	count = buf[0] & 0x1F;
+	for(i = 0; i < count; i++)
+	{
+		hdmi_edid_debug("[EDID-CEA] %02x VID %d native %d\n", buf[1 + i], buf[1 + i] & 0x7f, buf[1 + i] >> 7);
+		vic = buf[1 + i] & 0x7f;
+		for(j = 0; j < ARRAY_SIZE(double_aspect_vic); j++)
+		{
+			if(vic == double_aspect_vic[j])
+			{	
+				vic--;
+				break;
+			}
+		}
+		if(vic)
+		{
+			mode = hdmi_vic_to_videomode(vic);
+			if(mode)
+			{	
+				hdmi_add_videomode(mode, &pedid->modelist);
+			}
+		}
+	}
+	return 0;
+}
+
+// Parse CEA Short Audio Descriptor
+static int hdmi_edid_parse_cea_sad(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	int i, count;
+	
+	count = buf[0] & 0x1F;
+	pedid->audio = kmalloc((count/3)*sizeof(struct hdmi_audio), GFP_KERNEL);
+	if(pedid->audio == NULL)
+		return E_HDMI_EDID_NOMEMORY;
+	pedid->audio_num = count/3;
+	for(i = 0; i < pedid->audio_num; i++)
+	{
+		pedid->audio[i].type = (buf[1 + i*3] >> 3) & 0x0F;
+		pedid->audio[i].channel = (buf[1 + i*3] & 0x07) + 1;
+		pedid->audio[i].rate = buf[1 + i*3 + 1];
+		if(pedid->audio[i].type == HDMI_AUDIO_LPCM)//LPCM 
+		{
+			pedid->audio[i].word_length = buf[1 + i*3 + 2];
+		}
+//		printk("[EDID-CEA] type %d channel %d rate %d word length %d\n", 
+//			pedid->audio[i].type, pedid->audio[i].channel, pedid->audio[i].rate, pedid->audio[i].word_length);
+	}
+	return E_HDMI_EDID_SUCCESS;
+}
+// Parse CEA 861 Serial Extension.
+static int hdmi_edid_parse_extensions_cea(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	unsigned int ddc_offset, native_dtd_num, cur_offset = 4;
+	unsigned int underscan_support, baseaudio_support;
+	unsigned int tag, IEEEOUI = 0;
+//	unsigned int supports_ai,  dc_48bit, dc_36bit, dc_30bit, dc_y444;
+//	unsigned char vic;
+	
+	if(buf == NULL)
+		return E_HDMI_EDID_PARAM;
+		
+	// Check ces extension version
+	if(buf[1] != 3)
+	{
+		hdmi_edid_error("[EDID-CEA] error version.\n");
+		return E_HDMI_EDID_VERSION;
+	}
+	
+	ddc_offset = buf[2];
+	underscan_support = (buf[3] >> 7) & 0x01;
+	baseaudio_support = (buf[3] >> 6) & 0x01;
+	pedid->ycbcr444 = (buf[3] >> 5) & 0x01;
+	pedid->ycbcr422 = (buf[3] >> 4) & 0x01;
+	native_dtd_num = buf[3] & 0x0F;
+//	hdmi_edid_debug("[EDID-CEA] ddc_offset %d underscan_support %d baseaudio_support %d yuv_support %d native_dtd_num %d\n", ddc_offset, underscan_support, baseaudio_support, yuv_support, native_dtd_num);
+	// Parse data block
+	while(cur_offset < ddc_offset)
+	{
+		tag = buf[cur_offset] >> 5;
+		switch(tag)
+		{
+			case 0x02:	// Video Data Block
+				hdmi_edid_debug("[EDID-CEA] It is a Video Data Block.\n");
+				hdmi_edid_get_cea_svd(buf + cur_offset, pedid);
+				break;
+			case 0x01:	// Audio Data Block
+				hdmi_edid_debug("[EDID-CEA] It is a Audio Data Block.\n");
+				hdmi_edid_parse_cea_sad(buf + cur_offset, pedid);
+				break;
+			case 0x04:	// Speaker Allocation Data Block
+				hdmi_edid_debug("[EDID-CEA] It is a Speaker Allocatio Data Block.\n");
+				break;
+			case 0x03:	// Vendor Specific Data Block
+				hdmi_edid_debug("[EDID-CEA] It is a Vendor Specific Data Block.\n");
+
+				IEEEOUI = buf[cur_offset + 2 + 1];
+				IEEEOUI <<= 8;
+				IEEEOUI += buf[cur_offset + 1 + 1];
+				IEEEOUI <<= 8;
+				IEEEOUI += buf[cur_offset + 1];
+				hdmi_edid_debug("[EDID-CEA] IEEEOUI is 0x%08x.\n", IEEEOUI);
+				if(IEEEOUI == 0x0c03)
+					pedid->sink_hdmi = 1;
+//				if(count > 5)
+//				{
+//					pedid->deepcolor = (buf[cur_offset + 5] >> 3) & 0x0F;
+//					supports_ai = buf[cur_offset + 5] >> 7;
+//					dc_48bit = (buf[cur_offset + 5] >> 6) & 0x1;
+//					dc_36bit = (buf[cur_offset + 5] >> 5) & 0x1;
+//					dc_30bit = (buf[cur_offset + 5] >> 4) & 0x1;
+//					dc_y444 = (buf[cur_offset + 5] >> 3) & 0x1;
+//					hdmi_edid_debug("[EDID-CEA] supports_ai %d dc_48bit %d dc_36bit %d dc_30bit %d dc_y444 %d \n", supports_ai, dc_48bit, dc_36bit, dc_30bit, dc_y444);
+//				}
+//				if(count > 6)
+//					pedid->maxtmdsclock = buf[cur_offset + 6] * 5000000;
+//				if(count > 7)
+//				{
+//					pedid->latency_fields_present = (buf[cur_offset + 7] & 0x80) ? 1:0;
+//					pedid->i_latency_fields_present = (buf[cur_offset + 7] & 0x40) ? 1:0;
+//				}
+//				if(count > 9 && pedid->latency_fields_present)
+//				{
+//					pedid->video_latency = buf[cur_offset + 8];
+//					pedid->audio_latency = buf[cur_offset + 9];
+//				}
+//				if(count > 11 && pedid->i_latency_fields_present)
+//				{
+//					pedid->interlaced_video_latency = buf[cur_offset + 10];
+//					pedid->interlaced_audio_latency = buf[cur_offset + 11];
+//				}
+				break;		
+			case 0x05:	// VESA DTC Data Block
+				hdmi_edid_debug("[EDID-CEA] It is a VESA DTC Data Block.\n");
+				break;
+			case 0x07:	// Use Extended Tag
+				hdmi_edid_debug("[EDID-CEA] It is a Use Extended Tag Data Block.\n");
+				break;
+			default:
+				hdmi_edid_error("[EDID-CEA] unkowned data block tag.\n");
+				break;
+		}
+		cur_offset += (buf[cur_offset] & 0x1F) + 1;
+	}
+#if 1	
+{
+	// Parse DTD
+	struct fb_videomode *vmode = kmalloc(sizeof(struct fb_videomode), GFP_KERNEL);
+	if(vmode == NULL)
+		return E_HDMI_EDID_SUCCESS; 
+	while(ddc_offset < HDMI_EDID_BLOCK_SIZE - 2)	//buf[126] = 0 and buf[127] = checksum
+	{
+		if(!buf[ddc_offset] && !buf[ddc_offset + 1])
+			break;
+		memset(vmode, 0, sizeof(struct fb_videomode));
+		hdmi_edid_parse_dtd(buf + ddc_offset, vmode);
+		hdmi_add_videomode(vmode, &pedid->modelist);
+		ddc_offset += 18;
+	}
+	kfree(vmode);
+}
+#endif
+	return E_HDMI_EDID_SUCCESS;
+}
+
+static int hdmi_edid_parse_extensions(unsigned char *buf, struct hdmi_edid *pedid)
+{
+	int rc;
+	
+	if(buf == NULL || pedid == NULL)
+		return E_HDMI_EDID_PARAM;
+		
+	// Checksum
+    rc = hdmi_edid_checksum(buf);
+    if( rc != E_HDMI_EDID_SUCCESS)
+    {
+    	hdmi_edid_error("[EDID] extensions block checksum error\n");
+    	return E_HDMI_EDID_CHECKSUM;
+    }
+    
+    switch(buf[0])
+    {
+    	case 0xF0:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a extensions block map.\n");
+    		break;
+    	case 0x02:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a  CEA 861 Series Extension.\n");
+    		hdmi_edid_parse_extensions_cea(buf, pedid);
+    		break;
+    	case 0x10:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a Video Timing Block Extension.\n");
+    		break;
+    	case 0x40:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a Display Information Extension.\n");
+    		break;
+    	case 0x50:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a Localized String Extension.\n");
+    		break;
+    	case 0x60:
+    		hdmi_edid_debug("[EDID-EXTEND] It is a Digital Packet Video Link Extension.\n");
+    		break;
+    	default:
+    		hdmi_edid_error("[EDID-EXTEND] Unkowned extension.\n");
+    		return E_HDMI_EDID_UNKOWNDATA;
+    }
+    
+    return E_HDMI_EDID_SUCCESS;
+}
+
+
+int hdmi_sys_parse_edid(struct hdmi* hdmi)
+{
+	struct hdmi_edid *pedid;
+	unsigned char *buff = NULL;
+	int rc = HDMI_ERROR_SUCESS, extendblock = 0, i;
+	
+	if(hdmi == NULL)
+		return HDMI_ERROR_FALSE;
+
+	pedid = &(hdmi->edid);
+	memset(pedid, 0, sizeof(struct hdmi_edid));
+	INIT_LIST_HEAD(&pedid->modelist);
+	
+	buff = kmalloc(HDMI_EDID_BLOCK_SIZE, GFP_KERNEL);
+	if(buff == NULL)
+	{		
+		hdmi_dbg(hdmi->dev, "[%s] can not allocate memory for edid buff.\n", __FUNCTION__);
+		return -1;
+	}
+	// Read base block edid.
+	memset(buff, 0 , HDMI_EDID_BLOCK_SIZE);
+	rc = hdmi->read_edid(0, buff);
+	if(rc)
+	{
+		dev_err(hdmi->dev, "[HDMI] read edid base block error\n");
+		goto out;
+	}
+	rc = hdmi_edid_parse_base(buff, &extendblock, pedid);
+	if(rc)
+	{
+		dev_err(hdmi->dev, "[HDMI] parse edid base block error\n");
+		goto out;
+	}
+	for(i = 1; i < extendblock + 1; i++)
+	{
+		memset(buff, 0 , HDMI_EDID_BLOCK_SIZE);
+		rc = hdmi->read_edid(i, buff);
+		if(rc)
+		{
+			printk("[HDMI] read edid block %d error\n", i);	
+			goto out;
+		}
+		rc = hdmi_edid_parse_extensions(buff, pedid);
+		if(rc)
+		{
+			dev_err(hdmi->dev, "[HDMI] parse edid block %d error\n", i);
+			continue;
+		}
+	}
+out:
+	if(buff)
+		kfree(buff);
+	rc = hdmi_ouputmode_select(hdmi, rc);
+	return rc;
+}
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_lcdc.c b/drivers/video/rockchip/hdmi/rk_hdmi_lcdc.c
new file mode 100755
index 0000000..2703d98
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_lcdc.c
@@ -0,0 +1,532 @@
+#include <linux/console.h>
+#include<linux/rk_fb.h>
+#include "rk_hdmi.h"
+
+#define OUT_TYPE		SCREEN_HDMI
+#define OUT_FACE		OUT_P888
+#define DCLK_POL		1
+#define SWAP_RB			0
+#define LCD_ACLK		800000000
+
+static const struct fb_videomode hdmi_mode [] = {
+	//name				refresh		xres	yres	pixclock	h_bp	h_fp	v_bp	v_fp	h_pw	v_pw	polariry	PorI	flag(used for vic)
+//{	"640x480p@60Hz",	60,			640,	480,	25175000,	48,		16,		33,		10,		96,		2,		0,			0,		1	},
+//{	"720x480i@60Hz",	60,			720,	480,	27000000,	114,	38,		15,		4,		124,	3,		0,			1,		6	},
+//{	"720x576i@50Hz",	50,			720,	576,	27000000,	138,	24,		19,		2,		126,	3,		0,			1,		21	},
+{	"720x480p@60Hz",	60,			720,	480,	27000000,	60,		16,		30,		9,		62,		6,		0,			0,		2	},
+{	"720x576p@50Hz",	50,			720,	576,	27000000,	68,		12,		39,		5,		64,		5,		0,			0,		17	},
+//{	"1280x720p@24Hz",	24,			1280,	720,	59400000,	220,	1760,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		60	},
+//{	"1280x720p@25Hz",	25,			1280,	720,	74250000,	220,	2420,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		61	},
+//{	"1280x720p@30Hz",	30,			1280,	720,	74250000,	220,	1760,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		62	},
+{	"1280x720p@50Hz",	50,			1280,	720,	74250000,	220,	440,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		19	},
+{	"1280x720p@60Hz",	60,			1280,	720,	74250000,	220,	110,	20,		5,		40,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		4	},
+//{	"1920x1080p@24Hz",	24,			1920,	1080,	74250000,	148,	638,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		32	},
+//{	"1920x1080p@25Hz",	25,			1920,	1080,	74250000,	148,	528,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		33	},
+//{	"1920x1080p@30Hz",	30,			1920,	1080,	74250000,	148,	88,		36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		34	},	
+//{	"1920x1080i@50Hz_2",50,			1920,	1080,	72000000,	184,	32,		57,		23,		168,	5,		FB_SYNC_HOR_HIGH_ACT,			1,		39	},
+//{	"1920x1080i@50Hz",	50,			1920,	1080,	74250000,	148,	528,	15,		2,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			1,		20	},
+//{	"1920x1080i@60Hz",	60,			1920,	1080,	74250000,	148,	88,		15,		2,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			1,		5	},
+{	"1920x1080p@50Hz",	50,			1920,	1080,	148500000,	148,	528,	36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		31	},
+{	"1920x1080p@60Hz",	60,			1920,	1080,	148500000,	148,	88,		36,		4,		44,		5,		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,			0,		16	},
+/*
+{	"1440x288p@50Hz",	50,			720,	480,	27000000,	138,	24,		19,		2,		126,	3,		0,			0,		23	},
+{	"2880x576i@50Hz",	50,			1440,	240,	54000000,	276,	48,		19,		2,		252,	3,		0,			1,		25	},
+{	"2880x288p@50Hz",	50,			2880,	480,	54000000,	276,	48,		19,		3,		252,	3,		0,			0,		27	},
+{	"1440x576p@50Hz",	50,			2880,	480,	54000000,	136,	24,		39,		5,		128,	5,		0,			0,		29	},
+{	"2880x576p@50Hz",	50,			1920,	1080,	108000000,	272,	48,		39,		5,		256,	5,		0,			0,		37	},
+{	"1440x240p@60Hz",	60,			1440,	240,	27000000,	114,	38,		15,		4,		124,	3,		0,			0,		8	},
+{	"2880x480i@60Hz",	60,			2880,	480,	54000000,	228,	76,		15,		4,		248,	3,		0,			1,		10	},
+{	"2880x480p@60Hz",	60,			2880,	480,	54000000,	228,	76,		15,		4,		248,	3,		0,			0,		12	},
+{	"1440x480p@60Hz",	60,			1440,	480,	54000000,	120,	32,		30,		9,		124,	6,		0,			0,		14	},
+{	"2880x480p@60Hz",	60,			2880,	480,	54000000,	240,	64,		30,		9,		248,	6,		0,			0,		35	},
+
+{	"1920x1080i@100Hz",	100,		1920,	1080,	148500000,	148,	528,	15,		2,		44,		5,		1,			1,		40	},
+{	"1280x720p@100Hz",	100,		1280,	720,	148500000,	220,	440,	20,		5,		40,		5,		1,			0,		41	},
+{	"720x576p@100Hz",	100,		720,	576,	54000000,	68,		12,		39,		5,		64,		5,		0,			0,		42	},
+{	"1440x576i@100Hz",	100,		1440,	576,	54000000,	138,	24,		19,		2,		12,		3,		0,			1,		44	},
+{	"1920x1080p@100Hz",	100,		1920,	1080,	297000000,	148,	528,	36,		4,		44,		5,		1,			0,		64	},
+
+{	"1920x1080i@120Hz",	120,		1920,	1080,	148500000,	148,	88,		15,		2,		44,		5,		1,			1,		46	},
+{	"1280x720p@120Hz",	120,		1280,	720,	148500000,	220,	110,	20,		5,		40,		5,		1,			0,		47	},
+{	"720x480p@120Hz",	120,		720,	480,	54000000,	60,		16,		30,		9,		62,		6,		0,			0,		48	},
+{	"1440x480i@120Hz",	120,		1440,	480,	54000000,	114,	38,		15,		4,		12,		3,		0,			1,		50	},
+{	"1920x1080p@120Hz",	120,		1920,	1080,	297000000,	148,	88,		36,		4,		44,		5,		1,			0,		63	},
+
+{	"720x576p@200Hz",	200,		720,	576,	108000000,	68,		12,		39,		5,		64,		5,		0,			0,		52	},
+{	"1440x576i@200Hz",	200,		1920,	1080,	108000000,	138,	24,		19,		2,		12,		3,		0,			1,		54	},
+
+{	"720x480p@240Hz",	240,		720,	480,	108000000,	60,		16,		30,		9,		62,		6,		0,			0,		56	},
+{	"1440x480i@240Hz",	240,		1440,	480,	108000000,	114,	38,		15,		4,		12,		3,		0,			1,		58	},
+*/
+
+};
+
+void hdmi_init_lcdc(struct rk29fb_screen *screen, struct rk29lcd_info *lcd_info)
+{
+	hdmi_set_info(screen, HDMI_VIDEO_DEFAULT_MODE);
+}
+
+int hdmi_set_info(struct rk29fb_screen *screen, unsigned int vic)
+{
+    int i;
+    
+    if(screen == NULL)
+    	return -1;
+    
+    if(vic == 0)
+    	vic = HDMI_VIDEO_DEFAULT_MODE;
+    	
+    for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
+    {
+    	if(hdmi_mode[i].flag == vic)
+    		break;
+    }
+    if(i == ARRAY_SIZE(hdmi_mode))
+    	return -1;
+    
+    memset(screen, 0, sizeof(struct rk29fb_screen));
+    
+    /* screen type & face */
+    screen->type = OUT_TYPE;
+    screen->face = OUT_FACE;
+
+    /* Screen size */
+    screen->x_res = hdmi_mode[i].xres;
+    screen->y_res = hdmi_mode[i].yres;
+    
+    /* Timing */
+    screen->pixclock = hdmi_mode[i].pixclock;
+	screen->lcdc_aclk = LCD_ACLK;
+	screen->left_margin = hdmi_mode[i].left_margin;
+	screen->right_margin = hdmi_mode[i].right_margin;
+	screen->hsync_len = hdmi_mode[i].hsync_len;
+	screen->upper_margin = hdmi_mode[i].upper_margin;
+	screen->lower_margin = hdmi_mode[i].lower_margin;
+	screen->vsync_len = hdmi_mode[i].vsync_len;
+	screen->hdmi_resolution = hdmi_mode[i].flag;
+
+	/* Pin polarity */
+	if(FB_SYNC_HOR_HIGH_ACT & hdmi_mode[i].sync)
+		screen->pin_hsync = 1;
+	else
+		screen->pin_hsync = 0;
+	if(FB_SYNC_VERT_HIGH_ACT & hdmi_mode[i].sync)
+		screen->pin_vsync = 1;
+	else
+		screen->pin_vsync = 0;
+	screen->pin_den = 0;
+	screen->pin_dclk = DCLK_POL;
+
+	/* Swap rule */
+    screen->swap_rb = SWAP_RB;
+    screen->swap_rg = 0;
+    screen->swap_gb = 0;
+    screen->swap_delta = 0;
+    screen->swap_dumy = 0;
+
+    /* Operation function*/
+    screen->init = NULL;
+    screen->standby = NULL;
+    
+    return 0;
+}
+
+static void hdmi_show_sink_info(struct hdmi *hdmi)
+{
+	struct list_head *pos, *head = &hdmi->edid.modelist;
+	struct fb_modelist *modelist;
+	struct fb_videomode *m;
+	int i;
+	struct hdmi_audio *audio;
+
+	hdmi_dbg(hdmi->dev, "******** Show Sink Info ********\n");
+	hdmi_dbg(hdmi->dev, "Support video mode: \n");
+	list_for_each(pos, head) {
+		modelist = list_entry(pos, struct fb_modelist, list);
+		m = &modelist->mode;
+		hdmi_dbg(hdmi->dev, "	%s.\n", m->name);
+	}
+	
+	for(i = 0; i < hdmi->edid.audio_num; i++)
+	{
+		audio = &(hdmi->edid.audio[i]);
+		switch(audio->type)
+		{
+			case HDMI_AUDIO_LPCM:
+				hdmi_dbg(hdmi->dev, "Support audio type: LPCM\n");
+				break;
+			case HDMI_AUDIO_AC3:
+				hdmi_dbg(hdmi->dev, "Support audio type: AC3\n");
+				break;
+			case HDMI_AUDIO_MPEG1:
+				hdmi_dbg(hdmi->dev, "Support audio type: MPEG1\n");
+				break;
+			case HDMI_AUDIO_MP3:
+				hdmi_dbg(hdmi->dev, "Support audio type: MP3\n");
+				break;
+			case HDMI_AUDIO_MPEG2:
+				hdmi_dbg(hdmi->dev, "Support audio type: MPEG2\n");
+				break;
+			case HDMI_AUDIO_AAC_LC:
+				hdmi_dbg(hdmi->dev, "Support audio type: AAC\n");
+				break;
+			case HDMI_AUDIO_DTS:
+				hdmi_dbg(hdmi->dev, "Support audio type: DTS\n");
+				break;
+			case HDMI_AUDIO_ATARC:
+				hdmi_dbg(hdmi->dev, "Support audio type: ATARC\n");
+				break;
+			case HDMI_AUDIO_DSD:
+				hdmi_dbg(hdmi->dev, "Support audio type: DSD\n");
+				break;
+			case HDMI_AUDIO_E_AC3:
+				hdmi_dbg(hdmi->dev, "Support audio type: E-AC3\n");
+				break;
+			case HDMI_AUDIO_DTS_HD:
+				hdmi_dbg(hdmi->dev, "Support audio type: DTS-HD\n");
+				break;
+			case HDMI_AUDIO_MLP:
+				hdmi_dbg(hdmi->dev, "Support audio type: MLP\n");
+				break;
+			case HDMI_AUDIO_DST:
+				hdmi_dbg(hdmi->dev, "Support audio type: DST\n");
+				break;
+			case HDMI_AUDIO_WMA_PRO:
+				hdmi_dbg(hdmi->dev, "Support audio type: WMP-PRO\n");
+				break;
+			default:
+				hdmi_dbg(hdmi->dev, "Support audio type: Unkown\n");
+				break;
+		}
+		
+		hdmi_dbg(hdmi->dev, "Support audio sample rate: \n");
+		if(audio->rate & HDMI_AUDIO_FS_32000)
+			hdmi_dbg(hdmi->dev, "	32000\n");
+		if(audio->rate & HDMI_AUDIO_FS_44100)
+			hdmi_dbg(hdmi->dev, "	44100\n");
+		if(audio->rate & HDMI_AUDIO_FS_48000)
+			hdmi_dbg(hdmi->dev, "	48000\n");
+		if(audio->rate & HDMI_AUDIO_FS_88200)
+			hdmi_dbg(hdmi->dev, "	88200\n");
+		if(audio->rate & HDMI_AUDIO_FS_96000)
+			hdmi_dbg(hdmi->dev, "	96000\n");
+		if(audio->rate & HDMI_AUDIO_FS_176400)
+			hdmi_dbg(hdmi->dev, "	176400\n");
+		if(audio->rate & HDMI_AUDIO_FS_192000)
+			hdmi_dbg(hdmi->dev, "	192000\n");
+		
+		hdmi_dbg(hdmi->dev, "Support audio word lenght: \n");
+		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_16bit)
+			hdmi_dbg(hdmi->dev, "	16bit\n");
+		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_20bit)
+			hdmi_dbg(hdmi->dev, "	20bit\n");
+		if(audio->rate & HDMI_AUDIO_WORD_LENGTH_24bit)
+			hdmi_dbg(hdmi->dev, "	24bit\n");
+	}
+	hdmi_dbg(hdmi->dev, "******** Show Sink Info ********\n");
+}
+
+/**
+ * hdmi_ouputmode_select - select hdmi transmitter output mode: hdmi or dvi?
+ * @hdmi: handle of hdmi
+ * @edid_ok: get EDID data success or not, HDMI_ERROR_SUCESS means success.
+ */
+int hdmi_ouputmode_select(struct hdmi *hdmi, int edid_ok)
+{
+	struct list_head *head = &hdmi->edid.modelist;
+	struct fb_monspecs	*specs = hdmi->edid.specs;
+	struct fb_videomode *modedb = NULL;
+	int i, pixclock;
+	
+	if(edid_ok != HDMI_ERROR_SUCESS) {
+		dev_err(hdmi->dev, "warning: EDID error, assume sink as HDMI !!!!");
+		hdmi->edid.sink_hdmi = 1;
+	}
+
+	if(edid_ok != HDMI_ERROR_SUCESS) {
+		hdmi->edid.ycbcr444 = 0;
+		hdmi->edid.ycbcr422 = 0;
+		hdmi->autoconfig = HDMI_DISABLE;
+	}
+	if(head->next == head) {
+		dev_info(hdmi->dev, "warning: no CEA video mode parsed from EDID !!!!");
+		// If EDID get error, list all system supported mode.
+		// If output mode is set to DVI and EDID is ok, check
+		// the output timing.
+		
+		if(hdmi->edid.sink_hdmi == 0 && specs && specs->modedb_len) {
+			/* Get max resolution timing */
+			modedb = &specs->modedb[0];
+			for (i = 0; i < specs->modedb_len; i++) {
+				if(specs->modedb[i].xres > modedb->xres)
+					modedb = &specs->modedb[i];
+				else if(specs->modedb[i].yres > modedb->yres)
+					modedb = &specs->modedb[i];
+			}
+			// For some monitor, the max pixclock read from EDID is smaller
+			// than the clock of max resolution mode supported. We fix it.
+			pixclock = PICOS2KHZ(modedb->pixclock);
+			pixclock /= 250;
+			pixclock *= 250;
+			pixclock *= 1000;
+			if(pixclock == 148250000)
+				pixclock = 148500000;
+			if(pixclock > specs->dclkmax)
+				specs->dclkmax = pixclock;
+		}
+		
+		for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++) {
+			if(modedb) {
+				if( (hdmi_mode[i].pixclock < specs->dclkmin) || 
+					(hdmi_mode[i].pixclock > specs->dclkmax) || 
+					(hdmi_mode[i].refresh < specs->vfmin) ||
+					(hdmi_mode[i].refresh > specs->vfmax) ||
+					(hdmi_mode[i].xres > modedb->xres) ||
+					(hdmi_mode[i].yres > modedb->yres) )
+				continue;
+			}
+			hdmi_add_videomode(&hdmi_mode[i], head);
+		}
+	}
+	
+	#ifdef HDMI_DEBUG
+	hdmi_show_sink_info(hdmi);
+	#endif
+	return HDMI_ERROR_SUCESS;
+}
+/**
+ * hdmi_videomode_compare - compare 2 videomodes
+ * @mode1: first videomode
+ * @mode2: second videomode
+ *
+ * RETURNS:
+ * 1 if mode1 > mode2, 0 if mode1 = mode2, -1 mode1 < mode2
+ */
+static int hdmi_videomode_compare(const struct fb_videomode *mode1,
+		     const struct fb_videomode *mode2)
+{
+	if(mode1->xres > mode2->xres)
+		return 1;
+	else if(mode1->xres == mode2->xres)
+	{ 
+		if(mode1->yres > mode2->yres)
+			return 1;
+		else if(mode1->yres == mode2->yres)
+		{
+			if(mode1->pixclock > mode2->pixclock)	
+				return 1;
+			else if(mode1->pixclock == mode2->pixclock)
+			{	
+				if(mode1->refresh > mode2->refresh)
+					return 1;
+				else if(mode1->refresh == mode2->refresh) 
+					return 0;
+			}
+		}
+	}
+	return -1;		
+}
+/**
+ * hdmi_add_videomode: adds videomode entry to modelist
+ * @mode: videomode to add
+ * @head: struct list_head of modelist
+ *
+ * NOTES:
+ * Will only add unmatched mode entries
+ */
+int hdmi_add_videomode(const struct fb_videomode *mode, struct list_head *head)
+{
+	struct list_head *pos;
+	struct fb_modelist *modelist, *modelist_new;
+	struct fb_videomode *m;
+	int i, found = 0;
+
+	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
+    {
+    	m =(struct fb_videomode*) &hdmi_mode[i];
+    	if (fb_mode_is_equal(m, mode)) {
+			found = 1;
+			break;
+		}
+    }
+
+	if (found) {
+		list_for_each(pos, head) {
+			modelist = list_entry(pos, struct fb_modelist, list);
+			m = &modelist->mode;
+			if (fb_mode_is_equal(m, mode)) {
+			// m == mode	
+				return 0;
+			}
+			else
+			{ 
+				if(hdmi_videomode_compare(m, mode) == -1) {
+					break;
+				}
+			}
+		}
+
+		modelist_new = kmalloc(sizeof(struct fb_modelist),
+				  GFP_KERNEL);					
+		if (!modelist_new)
+			return -ENOMEM;	
+		modelist_new->mode = hdmi_mode[i];
+		list_add_tail(&modelist_new->list, pos);
+	}
+	
+	return 0;
+}
+
+/**
+ * hdmi_videomode_to_vic: transverse video mode to vic
+ * @vmode: videomode to transverse
+ * 
+ */
+int hdmi_videomode_to_vic(struct fb_videomode *vmode)
+{
+	unsigned char vic = 0;
+	int i = 0;
+	
+	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
+	{
+		if(	vmode->vmode == hdmi_mode[i].vmode &&
+			vmode->refresh == hdmi_mode[i].refresh &&
+			vmode->xres == hdmi_mode[i].xres && 
+			vmode->left_margin == hdmi_mode[i].left_margin &&
+			vmode->right_margin == hdmi_mode[i].right_margin &&
+			vmode->upper_margin == hdmi_mode[i].upper_margin &&
+			vmode->lower_margin == hdmi_mode[i].lower_margin && 
+			vmode->hsync_len == hdmi_mode[i].hsync_len && 
+			vmode->vsync_len == hdmi_mode[i].vsync_len)
+		{
+			if( (vmode->vmode == FB_VMODE_NONINTERLACED && vmode->yres == hdmi_mode[i].yres) || 
+				(vmode->vmode == FB_VMODE_INTERLACED && vmode->yres == hdmi_mode[i].yres/2))
+			{								
+				vic = hdmi_mode[i].flag;
+				break;
+			}
+		}
+	}
+	return vic;
+}
+
+/**
+ * hdmi_vic_to_videomode: transverse vic mode to video mode
+ * @vmode: vic to transverse
+ * 
+ */
+const struct fb_videomode* hdmi_vic_to_videomode(int vic)
+{
+	int i;
+	
+	if(vic == 0)
+		return NULL;
+	
+	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
+	{
+		if(hdmi_mode[i].flag == vic)
+			return &hdmi_mode[i];
+	}
+	return NULL;
+}
+
+/**
+ * hdmi_find_best_mode: find the video mode nearest to input vic
+ * @hdmi: 
+ * @vic: input vic
+ * 
+ * NOTES:
+ * If vic is zero, return the high resolution video mode vic.
+ */
+int hdmi_find_best_mode(struct hdmi* hdmi, int vic)
+{
+	struct list_head *pos, *head = &hdmi->edid.modelist;
+	struct fb_modelist *modelist;
+	struct fb_videomode *m = NULL;
+	int found = 0;
+	
+	if(vic)
+	{
+		list_for_each(pos, head) {
+			modelist = list_entry(pos, struct fb_modelist, list);
+			m = &modelist->mode;
+			if(m->flag == vic)
+			{
+				found = 1;	
+				break;
+			}
+		}
+	}
+	if( (vic == 0 || found == 0) && head->next != head)
+	{
+		modelist = list_entry(head->next, struct fb_modelist, list);
+		m = &modelist->mode;
+	}
+	if(m != NULL)
+		return m->flag;
+	else
+		return 0;
+}
+
+const char *hdmi_get_video_mode_name(unsigned char vic)
+{
+	int i;
+	
+	for(i = 0; i < ARRAY_SIZE(hdmi_mode); i++)
+	{
+		if(vic == hdmi_mode[i].flag)
+			break;
+	}
+	if(i == ARRAY_SIZE(hdmi_mode))
+		return NULL;
+	else
+		return hdmi_mode[i].name;
+}
+
+/**
+ * hdmi_switch_fb: switch lcdc mode to required video mode
+ * @hdmi: 
+ * @type:
+ * 
+ * NOTES:
+ * 
+ */
+int hdmi_switch_fb(struct hdmi *hdmi, int vic)
+{
+	int rc = 0;
+	rk_screen *screen;
+	
+	
+	screen =  kzalloc(sizeof(struct rk29fb_screen), GFP_KERNEL);
+	if(screen == NULL)
+		return -1;
+	
+	if(hdmi->vic == 0)
+		hdmi->vic = HDMI_VIDEO_DEFAULT_MODE;
+		
+
+	rc = hdmi_set_info(screen, hdmi->vic);
+
+	if(rc == 0) {		
+		rk_fb_switch_screen(screen, 1, hdmi->lcdc->id);
+		rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, hdmi->lcdc->id);
+	}
+	
+	kfree(screen);
+	
+	return rc;
+}
+
+/**
+ * hdmi_get_status: get hdmi hotplug status
+ * 
+ * NOTES:
+ * 
+ */
+int hdmi_get_hotplug(void)
+{
+	if(hdmi)
+		return hdmi->hotplug;
+	else
+		return HDMI_HPD_REMOVED;
+}
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_sysfs.c b/drivers/video/rockchip/hdmi/rk_hdmi_sysfs.c
new file mode 100755
index 0000000..a93c321
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_sysfs.c
@@ -0,0 +1,182 @@
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/display-sys.h>
+#include <linux/interrupt.h>
+#include "rk_hdmi.h"
+
+static int hdmi_get_enable(struct rk_display_device *device)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int enable;
+	
+	mutex_lock(&hdmi->enable_mutex);
+	enable = hdmi->enable;
+	mutex_unlock(&hdmi->enable_mutex);
+	
+	return enable;
+}
+
+static int hdmi_set_enable(struct rk_display_device *device, int enable)
+{
+	struct hdmi *hdmi = device->priv_data;
+	
+	mutex_lock(&hdmi->enable_mutex);
+	if(hdmi->enable == enable) {
+		mutex_unlock(&hdmi->enable_mutex);
+		return 0;
+	}
+	hdmi->enable = enable;
+	
+	if(hdmi->suspend ) {
+		mutex_unlock(&hdmi->enable_mutex);
+		return 0;
+	}
+	
+	if(enable == 0) {
+		if(hdmi->irq)
+			disable_irq(hdmi->irq);
+		mutex_unlock(&hdmi->enable_mutex);
+		hdmi->command = HDMI_CONFIG_ENABLE;
+		queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+	}
+	else {
+		if(hdmi->irq)
+			enable_irq(hdmi->irq);
+		#ifdef CONFIG_HDMI_RK610
+			queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+		#endif
+		mutex_unlock(&hdmi->enable_mutex);
+	}
+	return 0;
+}
+
+static int hdmi_get_status(struct rk_display_device *device)
+{
+	struct hdmi *hdmi = device->priv_data;
+	if(hdmi->hotplug == HDMI_HPD_ACTIVED)
+		return 1;
+	else
+		return 0;
+}
+
+static int hdmi_get_modelist(struct rk_display_device *device, struct list_head **modelist)
+{
+	struct hdmi *hdmi = device->priv_data;
+	if(!hdmi->hotplug)
+		return -1;
+	*modelist = &hdmi->edid.modelist;
+	return 0;
+}
+
+static int hdmi_set_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	struct hdmi *hdmi = device->priv_data;
+	int vic = hdmi_videomode_to_vic(mode);
+	
+	if(!hdmi->hotplug)
+		return -1;
+	hdmi->autoconfig = HDMI_DISABLE;
+	if(vic && hdmi->vic != vic)
+	{
+		hdmi->vic = vic;
+		hdmi->command = HDMI_CONFIG_VIDEO;
+		init_completion(&hdmi->complete);
+		hdmi->wait = 1;
+		queue_delayed_work(hdmi->workqueue, &hdmi->delay_work, 0);
+		wait_for_completion_interruptible_timeout(&hdmi->complete,
+								msecs_to_jiffies(10000));
+	}
+	return 0;
+}
+
+static int hdmi_get_mode(struct rk_display_device *device, struct fb_videomode *mode)
+{
+	struct hdmi *hdmi = device->priv_data;
+	struct fb_videomode *vmode;
+	
+	if(!hdmi->hotplug)
+		return -1;
+		
+	vmode = (struct fb_videomode*) hdmi_vic_to_videomode(hdmi->vic);
+	if(unlikely(vmode == NULL))
+		return -1;
+	*mode = *vmode;
+	return 0;
+}
+
+static int hdmi_set_scale(struct rk_display_device *device, int direction, int value)
+{
+	struct hdmi *hdmi = device->priv_data;
+	
+	if(!hdmi || value < 0 || value > 100)
+		return -1;
+			
+	if(direction == DISPLAY_SCALE_X)
+		hdmi->xscale = value;
+	else if(direction == DISPLAY_SCALE_Y)
+		hdmi->yscale = value;
+	else
+		return -1;
+	rk_fb_disp_scale(hdmi->xscale, hdmi->yscale, hdmi->lcdc->id);
+	return 0;
+}
+
+static int hdmi_get_scale(struct rk_display_device *device, int direction)
+{
+	struct hdmi *hdmi = device->priv_data;
+	
+	if(!hdmi)
+		return -1;
+		
+	if(direction == DISPLAY_SCALE_X)
+		return hdmi->xscale;
+	else if(direction == DISPLAY_SCALE_Y)
+		return hdmi->yscale;
+	else
+		return -1;
+}
+
+struct rk_display_ops hdmi_display_ops = {
+	.setenable = hdmi_set_enable,
+	.getenable = hdmi_get_enable,
+	.getstatus = hdmi_get_status,
+	.getmodelist = hdmi_get_modelist,
+	.setmode = hdmi_set_mode,
+	.getmode = hdmi_get_mode,
+	.setscale = hdmi_set_scale,
+	.getscale = hdmi_get_scale,
+};
+
+#if 1
+static int hdmi_display_probe(struct rk_display_device *device, void *devdata)
+{
+	device->owner = THIS_MODULE;
+	strcpy(device->type, "HDMI");
+	device->priority = DISPLAY_PRIORITY_HDMI;
+//	device->name = kmalloc(strlen(name), GFP_KERNEL);
+//	if(device->name)
+//	{
+//		strcpy(device->name, name);
+//	}
+	device->priv_data = devdata;
+	device->ops = &hdmi_display_ops;
+	return 1;
+}
+
+static struct rk_display_driver display_hdmi = {
+	.probe = hdmi_display_probe,
+};
+
+static struct rk_display_device *display_device_hdmi = NULL;
+
+void hdmi_register_display_sysfs(struct hdmi *hdmi, struct device *parent)
+{
+	display_device_hdmi = rk_display_device_register(&display_hdmi, parent, hdmi);
+}
+
+void hdmi_unregister_display_sysfs(struct hdmi *hdmi)
+{
+	if(display_device_hdmi)
+		rk_display_device_unregister(display_device_hdmi);
+}
+#endif
diff --git a/drivers/video/rockchip/hdmi/rk_hdmi_task.c b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
new file mode 100755
index 0000000..3fe5274
--- /dev/null
+++ b/drivers/video/rockchip/hdmi/rk_hdmi_task.c
@@ -0,0 +1,305 @@
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include "rk_hdmi.h"
+
+#ifdef CONFIG_RK_HDMI_CTL_CODEC
+extern void codec_set_spk(bool on);
+#endif
+
+#define HDMI_MAX_TRY_TIMES	1
+#define HDMI_MAX_ID 1
+
+static char *envp[] = {"INTERFACE=HDMI", NULL};
+
+static void hdmi_sys_show_state(int state)
+{
+	switch(state)
+	{
+		case HDMI_SLEEP:
+			dev_printk(KERN_INFO, hdmi->dev, "HDMI_SLEEP\n");
+			break;
+		case HDMI_INITIAL:
+			dev_printk(KERN_INFO, hdmi->dev, "HDMI_INITIAL\n");
+			break;
+		case WAIT_HOTPLUG:
+			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HOTPLUG\n");
+			break;
+		case READ_PARSE_EDID:
+			dev_printk(KERN_INFO, hdmi->dev, "READ_PARSE_EDID\n");
+			break;
+		case WAIT_HDMI_ENABLE:
+			dev_printk(KERN_INFO, hdmi->dev, "WAIT_HDMI_ENABLE\n");
+			break;
+		case SYSTEM_CONFIG:
+			dev_printk(KERN_INFO, hdmi->dev, "SYSTEM_CONFIG\n");
+			break;
+		case CONFIG_VIDEO:
+			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_VIDEO\n");
+			break;
+		case CONFIG_AUDIO:
+			dev_printk(KERN_INFO, hdmi->dev, "CONFIG_AUDIO\n");
+			break;
+		case PLAY_BACK:
+			dev_printk(KERN_INFO, hdmi->dev, "PLAY_BACK\n");
+			break;
+		default:
+			dev_printk(KERN_INFO, hdmi->dev, "Unkown State %d\n", state);
+			break;
+	}
+}
+
+int hdmi_sys_init(void)
+{
+	hdmi->hotplug			= HDMI_HPD_REMOVED;
+	hdmi->state				= HDMI_SLEEP;
+	hdmi->enable			= HDMI_ENABLE;
+	hdmi->autoconfig		= HDMI_AUTO_CONFIGURE;
+	hdmi->display			= HDMI_DISABLE;
+	
+	hdmi->vic				= HDMI_VIDEO_DEFAULT_MODE;
+	hdmi->audio.channel 	= HDMI_AUDIO_DEFAULT_CHANNEL;
+	hdmi->audio.rate		= HDMI_AUDIO_DEFAULT_RATE;
+	hdmi->audio.word_length	= HDMI_AUDIO_DEFAULT_WORD_LENGTH;
+	
+	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
+	INIT_LIST_HEAD(&hdmi->edid.modelist);
+	return 0;
+}
+
+void hdmi_sys_remove(void)
+{
+	fb_destroy_modelist(&hdmi->edid.modelist);
+	if(hdmi->edid.audio)
+		kfree(hdmi->edid.audio);
+	if(hdmi->edid.specs)
+	{
+		if(hdmi->edid.specs->modedb)
+			kfree(hdmi->edid.specs->modedb);
+		kfree(hdmi->edid.specs);
+	}
+	memset(&hdmi->edid, 0, sizeof(struct hdmi_edid));
+	INIT_LIST_HEAD(&hdmi->edid.modelist);
+	hdmi->display	= HDMI_DISABLE;
+	rk_fb_switch_screen(hdmi->lcdc->screen1, 0, hdmi->lcdc->id);
+	kobject_uevent_env(&hdmi->dev->kobj, KOBJ_REMOVE, envp);
+	#ifdef CONFIG_SWITCH
+	switch_set_state(&(hdmi->switch_hdmi), 0);
+	#endif
+	#ifdef CONFIG_RK_HDMI_CTL_CODEC
+	codec_set_spk(1);
+	#endif
+}
+
+static void hdmi_sys_sleep(void)
+{
+	mutex_lock(&hdmi->enable_mutex);
+	if(hdmi->enable && hdmi->irq)
+		disable_irq(hdmi->irq);				
+	hdmi->state = HDMI_SLEEP;
+	hdmi->remove();
+	if(hdmi->enable && hdmi->irq)
+		enable_irq(hdmi->irq);
+	mutex_unlock(&hdmi->enable_mutex);
+}
+
+static int hdmi_process_command(void)
+{
+	int change, state = hdmi->state;
+	
+	change = hdmi->command;
+	if(change != HDMI_CONFIG_NONE)	
+	{		
+		hdmi->command = HDMI_CONFIG_NONE;
+		switch(change)
+		{	
+			case HDMI_CONFIG_ENABLE:
+				/* disable HDMI */
+				mutex_lock(&hdmi->enable_mutex);
+				if(!hdmi->enable || hdmi->suspend)
+				{
+					if(hdmi->hotplug == HDMI_HPD_ACTIVED)
+						hdmi_sys_remove();
+					hdmi->state = HDMI_SLEEP;
+					hdmi->hotplug = HDMI_HPD_REMOVED;
+					hdmi->remove();
+					state = HDMI_SLEEP;
+				}
+				mutex_unlock(&hdmi->enable_mutex);
+				if(hdmi->wait == 1) {
+					complete(&hdmi->complete);
+					hdmi->wait = 0;	
+				}
+				break;	
+			case HDMI_CONFIG_COLOR:
+				if(state > CONFIG_VIDEO)
+					state = CONFIG_VIDEO;	
+				break;
+			case HDMI_CONFIG_HDCP:
+				break;
+			case HDMI_CONFIG_DISPLAY:
+				break;
+			case HDMI_CONFIG_AUDIO:
+				if(state > CONFIG_AUDIO)
+					state = CONFIG_AUDIO;
+				break;
+			case HDMI_CONFIG_VIDEO:
+			default:
+				if(state > SYSTEM_CONFIG)
+					state = SYSTEM_CONFIG;
+				else
+				{
+					if(hdmi->wait == 1) {
+						complete(&hdmi->complete);
+						hdmi->wait = 0;	
+					}					
+				}
+				break;
+		}
+	}
+	else if(state == HDMI_SLEEP)
+		state = WAIT_HOTPLUG;
+	return state;
+}
+
+static DEFINE_MUTEX(work_mutex);
+
+void hdmi_work(struct work_struct *work)
+{
+	int hotplug, state_last;
+	int rc = HDMI_ERROR_SUCESS, trytimes = 0;
+	struct hdmi_video_para video;
+	
+	mutex_lock(&work_mutex);
+	/* Process hdmi command */
+	hdmi->state = hdmi_process_command();
+	
+	if(!hdmi->enable || hdmi->suspend) {
+		mutex_unlock(&work_mutex);
+		return;
+	}
+	hotplug = hdmi->detect_hotplug();
+	hdmi_dbg(hdmi->dev, "[%s] hotplug %02x curvalue %d\n", __FUNCTION__, hotplug, hdmi->hotplug);
+	
+	if(hotplug != hdmi->hotplug)
+	{
+		if(hotplug  == HDMI_HPD_ACTIVED){
+			if(hdmi->insert)
+				hdmi->insert();
+			hdmi->state = READ_PARSE_EDID;
+		}
+		else if(hdmi->hotplug == HDMI_HPD_ACTIVED) {
+			hdmi_sys_remove();
+			hdmi->hotplug = hotplug;
+			if(hotplug == HDMI_HPD_REMOVED)
+				hdmi_sys_sleep();
+			else {
+				hdmi->state = WAIT_HOTPLUG;
+				hdmi->remove();
+			}
+			if(hdmi->wait == 1) {
+				complete(&hdmi->complete);
+				hdmi->wait = 0;	
+			}
+			mutex_unlock(&work_mutex);
+			return;
+		}
+		else if(hotplug == HDMI_HPD_REMOVED) {
+			hdmi->state = HDMI_SLEEP;
+			hdmi->remove();
+		}
+		hdmi->hotplug  = hotplug;
+	}
+	else if(hotplug == HDMI_HPD_REMOVED)
+		hdmi_sys_sleep();
+	
+	do {
+		hdmi_sys_show_state(hdmi->state);
+		state_last = hdmi->state;
+		switch(hdmi->state)
+		{
+			case READ_PARSE_EDID:
+				rc = hdmi_sys_parse_edid(hdmi);
+				if(rc == HDMI_ERROR_SUCESS)
+				{
+					hdmi->state = SYSTEM_CONFIG;	
+					kobject_uevent_env(&hdmi->dev->kobj, KOBJ_ADD, envp);
+					#ifdef CONFIG_SWITCH
+					switch_set_state(&(hdmi->switch_hdmi), 1);
+					#endif
+					#ifdef CONFIG_RK_HDMI_CTL_CODEC
+					codec_set_spk(0);
+					#endif
+				}
+				break;
+			case SYSTEM_CONFIG:
+				if(hdmi->autoconfig)	
+					hdmi->vic = hdmi_find_best_mode(hdmi, 0);
+				else
+					hdmi->vic = hdmi_find_best_mode(hdmi, hdmi->vic);
+				rc = hdmi_switch_fb(hdmi, hdmi->vic);
+				if(rc == HDMI_ERROR_SUCESS)
+					hdmi->state = CONFIG_VIDEO;
+				break;
+			case CONFIG_VIDEO:
+				hdmi->display = HDMI_DISABLE;
+				video.vic = hdmi->vic;
+				video.input_mode = VIDEO_INPUT_RGB_YCBCR_444;
+				video.input_color = VIDEO_INPUT_COLOR_RGB;//VIDEO_INPUT_COLOR_YCBCR
+				video.output_mode = hdmi->edid.sink_hdmi;
+				
+				if(hdmi->edid.ycbcr444)
+					video.output_color = VIDEO_OUTPUT_YCBCR444;
+				else if(hdmi->edid.ycbcr422)
+					video.output_color = VIDEO_OUTPUT_YCBCR422;
+				else
+					video.output_color = VIDEO_OUTPUT_RGB444;
+				// For DVI, output RGB
+				if(hdmi->edid.sink_hdmi == 0)
+					video.output_color = VIDEO_OUTPUT_RGB444;
+				
+				rc = hdmi->config_video(&video);
+				if(rc == HDMI_ERROR_SUCESS)
+				{
+					if(hdmi->edid.sink_hdmi)
+						hdmi->state = CONFIG_AUDIO;
+					else
+						hdmi->state = PLAY_BACK;
+				}
+				break;
+			case CONFIG_AUDIO:
+				rc = hdmi->config_audio(&(hdmi->audio));
+							
+				if(rc == HDMI_ERROR_SUCESS)
+					hdmi->state = PLAY_BACK;
+				break;
+			case PLAY_BACK:
+				if(hdmi->display != HDMI_ENABLE) {
+					hdmi->control_output(HDMI_ENABLE);
+					hdmi->display = HDMI_ENABLE;
+					if(hdmi->hdcp_cb) {
+						hdmi->hdcp_cb();
+					}
+				}
+				
+				if(hdmi->wait == 1) {	
+					complete(&hdmi->complete);
+					hdmi->wait = 0;						
+				}
+				break;
+			default:
+				break;
+		}
+		if(rc != HDMI_ERROR_SUCESS)
+		{
+			trytimes++;
+			msleep(10);
+		}
+		if(hdmi->state != state_last) 
+			trytimes = 0;
+	
+	}while((hdmi->state != state_last || (rc != HDMI_ERROR_SUCESS) ) && trytimes < HDMI_MAX_TRY_TIMES);
+	
+	hdmi_dbg(hdmi->dev, "[%s] done\n", __FUNCTION__);
+	mutex_unlock(&work_mutex);
+}
+
diff --git a/drivers/video/rockchip/lcdc/rk30_lcdc.c b/drivers/video/rockchip/lcdc/rk30_lcdc.c
new file mode 100755
index 0000000..35354ac
--- /dev/null
+++ b/drivers/video/rockchip/lcdc/rk30_lcdc.c
@@ -0,0 +1,1425 @@
+/*
+ * drivers/video/rockchip/chips/rk30_lcdc.c
+ *
+ * Copyright (C) 2012 ROCKCHIP, Inc.
+ *Author:yzq<yzq@rock-chips.com>
+ *	yxj<yxj@rock-chips.com>
+ *This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/earlysuspend.h>
+#include <asm/div64.h>
+#include <asm/uaccess.h>
+#include "rk30_lcdc.h"
+
+
+
+
+
+
+static int dbg_thresd = 0;
+module_param(dbg_thresd, int, S_IRUGO|S_IWUSR);
+#define DBG(level,x...) do { if(unlikely(dbg_thresd >= level)) printk(KERN_INFO x); } while (0)
+
+
+static int rk30_lcdc_init(struct rk_lcdc_device_driver *dev_drv)
+{
+	int i = 0;
+	int __iomem *c;
+	int v;
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	if(lcdc_dev->id == 0) //lcdc0
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc0");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc0"); 
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc0");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc0");
+	}
+	else if(lcdc_dev->id == 1)
+	{
+		lcdc_dev->pd = clk_get(NULL,"pd_lcdc1");
+		lcdc_dev->hclk = clk_get(NULL,"hclk_lcdc1");  
+		lcdc_dev->aclk = clk_get(NULL,"aclk_lcdc1");
+		lcdc_dev->dclk = clk_get(NULL,"dclk_lcdc1");
+	}
+	else
+	{
+		printk(KERN_ERR "invalid lcdc device!\n");
+		return -EINVAL;
+	}
+	if (IS_ERR(lcdc_dev->pd) || (IS_ERR(lcdc_dev->aclk)) ||(IS_ERR(lcdc_dev->dclk)) || (IS_ERR(lcdc_dev->hclk)))
+    	{
+       		printk(KERN_ERR "failed to get lcdc%d clk source\n",lcdc_dev->id);
+   	}
+	clk_enable(lcdc_dev->pd);
+	clk_enable(lcdc_dev->hclk);  //enable aclk and hclk for register config
+	clk_enable(lcdc_dev->aclk);  
+	lcdc_dev->clk_on = 1;
+	LcdMskReg(lcdc_dev,SYS_CTRL0,m_HWC_CHANNEL_ID | m_WIN2_CHANNEL_ID | m_WIN1_CBR_CHANNEL_ID |
+		m_WIN1_YRGB_CHANNEL_ID | m_WIN0_CBR_CHANNEL1_ID | m_WIN0_YRGB_CHANNEL1_ID | 
+		m_WIN0_CBR_CHANNEL0_ID | m_WIN0_YRGB_CHANNEL0_ID,v_HWC_CHANNEL_ID(7) | 
+		v_WIN2_CHANNEL_ID(6) | v_WIN1_CBR_CHANNEL_ID(5) | v_WIN1_YRGB_CHANNEL_ID(4) | 
+		v_WIN0_CBR_CHANNEL1_ID(3) | v_WIN0_YRGB_CHANNEL1_ID(2) | v_WIN0_CBR_CHANNEL0_ID(1) |
+		v_WIN0_YRGB_CHANNEL0_ID(0));			//channel id ,just use default value
+	LcdSetBit(lcdc_dev,DSP_CTRL0, m_LCDC_AXICLK_AUTO_ENABLE);//eanble axi-clk auto gating for low power
+	LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR | m_BUS_ERR_INT_CLEAR | m_LINE_FLAG_INT_EN |
+              m_FRM_START_INT_EN | m_HOR_START_INT_EN,v_FRM_START_INT_CLEAR(1) | v_BUS_ERR_INT_CLEAR(0) |
+              v_LINE_FLAG_INT_EN(0) | v_FRM_START_INT_EN(0) | v_HOR_START_INT_EN(0));  //enable frame start interrupt for sync
+        if(dev_drv->cur_screen->dsp_lut)
+        {
+        	LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+		LCDC_REG_CFG_DONE();
+		msleep(25);
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+			
+		}
+		LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+        }
+	LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+	return 0;
+}
+
+static int rk30_lcdc_deinit(struct rk30_lcdc_device *lcdc_dev)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		LcdMskReg(lcdc_dev, INT_STATUS, m_HOR_START_INT_EN | m_FRM_START_INT_EN | 
+			m_LINE_FLAG_INT_EN | m_BUS_ERR_INT_EN,v_HOR_START_INT_EN(0) | v_FRM_START_INT_EN(0) | 
+			v_LINE_FLAG_INT_EN(0) | v_BUS_ERR_INT_EN(0));  //disable all lcdc interrupt
+		LcdSetBit(lcdc_dev,SYS_CTRL0,m_LCDC_STANDBY);
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else   //clk already disabled 
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	mdelay(1);
+	
+	return 0;
+}
+
+static int rk30_load_screen(struct rk_lcdc_device_driver *dev_drv, bool initscreen)
+{
+	int ret = -EINVAL;
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	rk_screen *screen = dev_drv->cur_screen;
+	u64 ft;
+	int fps;
+	u16 face;
+	u16 mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend;
+	u16 right_margin = screen->right_margin;
+	u16 lower_margin = screen->lower_margin;
+	u16 x_res = screen->x_res, y_res = screen->y_res;
+
+	// set the rgb or mcu
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(screen->type==SCREEN_MCU)
+		{
+	    		LcdMskReg(lcdc_dev, MCU_CTRL, m_MCU_OUTPUT_SELECT,v_MCU_OUTPUT_SELECT(1));
+			// set out format and mcu timing
+	   		mcu_total  = (screen->mcu_wrperiod*150*1000)/1000000;
+	    		if(mcu_total>31)    
+				mcu_total = 31;
+	   		if(mcu_total<3)    
+				mcu_total = 3;
+	    		mcu_rwstart = (mcu_total+1)/4 - 1;
+	    		mcu_rwend = ((mcu_total+1)*3)/4 - 1;
+	    		mcu_csstart = (mcu_rwstart>2) ? (mcu_rwstart-3) : (0);
+	    		mcu_csend = (mcu_rwend>15) ? (mcu_rwend-1) : (mcu_rwend);
+
+	    		//DBG(1,">> mcu_total=%d, mcu_rwstart=%d, mcu_csstart=%d, mcu_rwend=%d, mcu_csend=%d \n",
+	        	//	mcu_total, mcu_rwstart, mcu_csstart, mcu_rwend, mcu_csend);
+
+			// set horizontal & vertical out timing
+		
+		    	right_margin = x_res/6; 
+			screen->pixclock = 150000000; //mcu fix to 150 MHz
+			LcdMskReg(lcdc_dev, MCU_CTRL,m_MCU_CS_ST | m_MCU_CS_END| m_MCU_RW_ST | m_MCU_RW_END |
+	             		m_MCU_WRITE_PERIOD | m_MCU_HOLDMODE_SELECT | m_MCU_HOLDMODE_FRAME_ST,
+	            		v_MCU_CS_ST(mcu_csstart) | v_MCU_CS_END(mcu_csend) | v_MCU_RW_ST(mcu_rwstart) |
+	            		v_MCU_RW_END(mcu_rwend) |  v_MCU_WRITE_PERIOD(mcu_total) |
+	            		v_MCU_HOLDMODE_SELECT((SCREEN_MCU==screen->type)?(1):(0)) | v_MCU_HOLDMODE_FRAME_ST(0));
+	
+		}
+
+		switch (screen->face)
+		{
+	        	case OUT_P565:
+	            		face = OUT_P565;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_P666:
+	            		face = OUT_P666;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_D888_P565:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	case OUT_D888_P666:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(1) | v_DITHER_DOWN_MODE(1));
+	            		break;
+	        	case OUT_P888:
+	            		face = OUT_P888;
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(1));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		break;
+	        	default:
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_UP_EN, v_DITHER_UP_EN(0));
+	            		LcdMskReg(lcdc_dev, DSP_CTRL0, m_DITHER_DOWN_EN | m_DITHER_DOWN_MODE, v_DITHER_DOWN_EN(0) | v_DITHER_DOWN_MODE(0));
+	            		face = screen->face;
+	            		break;
+		}
+
+		//use default overlay,set vsyn hsync den dclk polarity
+		LcdMskReg(lcdc_dev, DSP_CTRL0,m_DISPLAY_FORMAT | m_HSYNC_POLARITY | m_VSYNC_POLARITY |
+	     		m_DEN_POLARITY |m_DCLK_POLARITY,v_DISPLAY_FORMAT(face) | 
+	     		v_HSYNC_POLARITY(screen->pin_hsync) | v_VSYNC_POLARITY(screen->pin_vsync) |
+	        	v_DEN_POLARITY(screen->pin_den) | v_DCLK_POLARITY(screen->pin_dclk));
+
+		//set background color to black,set swap according to the screen panel,disable blank mode
+		LcdMskReg(lcdc_dev, DSP_CTRL1, m_BG_COLOR | m_OUTPUT_RB_SWAP | m_OUTPUT_RG_SWAP | m_DELTA_SWAP | 
+		 	m_DUMMY_SWAP | m_BLANK_MODE,v_BG_COLOR(0x000000) | v_OUTPUT_RB_SWAP(screen->swap_rb) | 
+		 	v_OUTPUT_RG_SWAP(screen->swap_rg) | v_DELTA_SWAP(screen->swap_delta) | v_DUMMY_SWAP(screen->swap_dumy) |
+		 	v_BLACK_MODE(0));
+
+		
+		LcdWrReg(lcdc_dev, DSP_HTOTAL_HS_END,v_HSYNC(screen->hsync_len) |
+	             v_HORPRD(screen->hsync_len + screen->left_margin + x_res + right_margin));
+		LcdWrReg(lcdc_dev, DSP_HACT_ST_END, v_HAEP(screen->hsync_len + screen->left_margin + x_res) |
+	             v_HASP(screen->hsync_len + screen->left_margin));
+
+		LcdWrReg(lcdc_dev, DSP_VTOTAL_VS_END, v_VSYNC(screen->vsync_len) |
+	              v_VERPRD(screen->vsync_len + screen->upper_margin + y_res + lower_margin));
+		LcdWrReg(lcdc_dev, DSP_VACT_ST_END,  v_VAEP(screen->vsync_len + screen->upper_margin+y_res)|
+	              v_VASP(screen->vsync_len + screen->upper_margin));
+		// let above to take effect
+		LCDC_REG_CFG_DONE();
+	}
+ 	spin_unlock(&lcdc_dev->reg_lock);
+
+	ret = clk_set_rate(lcdc_dev->dclk, screen->pixclock);
+	if(ret)
+	{
+        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+	}
+    	lcdc_dev->driver.pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+	clk_enable(lcdc_dev->dclk);
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+		(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps;
+    	printk("%s: dclk:%lu>>fps:%d ",lcdc_dev->driver.name,clk_get_rate(lcdc_dev->dclk),fps);
+
+    	if(screen->init)
+    	{
+    		screen->init();
+    	}
+	
+	printk("%s for lcdc%d ok!\n",__func__,lcdc_dev->id);
+	return 0;
+}
+
+static int mcu_refresh(struct rk30_lcdc_device *lcdc_dev)
+{
+   
+    return 0;
+}
+
+
+
+//enable layer,open:1,enable;0 disable
+static int win0_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[0]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W0_EN, v_W0_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		LCDC_REG_CFG_DONE();	
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win0 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+static int win1_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		if(open)
+		{
+			if(!lcdc_dev->atv_layer_cnt)
+			{
+				printk("lcdc%d wakeup from stanby\n",lcdc_dev->id);
+				LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+			}
+			lcdc_dev->atv_layer_cnt++;
+		}
+		else
+		{
+			lcdc_dev->atv_layer_cnt--;
+		}
+		lcdc_dev->driver.layer_par[1]->state = open;
+		
+		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W1_EN, v_W1_EN(open));
+		if(!lcdc_dev->atv_layer_cnt)  //if no layer used,disable lcdc
+		{
+			printk(KERN_INFO "no layer of lcdc%d is used,go to standby!",lcdc_dev->id);
+			LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win1 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+
+static int win2_open(struct rk30_lcdc_device *lcdc_dev,bool open)
+{
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W2_EN, v_W2_EN(open));
+		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
+		lcdc_dev->driver.layer_par[1]->state = open;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	printk(KERN_INFO "lcdc%d win2 %s\n",lcdc_dev->id,open?"open":"closed");
+	return 0;
+}
+
+static int rk30_lcdc_blank(struct rk_lcdc_device_driver*lcdc_drv,int layer_id,int blank_mode)
+{
+	struct rk30_lcdc_device * lcdc_dev = container_of(lcdc_drv,struct rk30_lcdc_device ,driver);
+
+	printk(KERN_INFO "%s>>>>>%d\n",__func__, blank_mode);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch(blank_mode)
+	    	{
+	    		case FB_BLANK_UNBLANK:
+	      			LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(0));
+				break;
+	    		case FB_BLANK_NORMAL:
+	         		LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+	    		default:
+				LcdMskReg(lcdc_dev,DSP_CTRL1,m_BLANK_MODE ,v_BLANK_MODE(1));
+				break;
+		}
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+    	return 0;
+}
+
+static  int win0_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s:y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_YRGB_MST0, y_addr);
+	    	LcdWrReg(lcdc_dev, WIN0_CBR_MST0, uv_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return 0;
+	
+}
+
+static  int win1_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN1_YRGB_MST, y_addr);
+	    	LcdWrReg(lcdc_dev, WIN1_CBR_MST, uv_addr);
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win2_display(struct rk30_lcdc_device *lcdc_dev,struct layer_par *par )
+{
+	u32 y_addr;
+	u32 uv_addr;
+	y_addr = par->smem_start + par->y_offset;
+    	uv_addr = par->cbr_start + par->c_offset;
+	DBG(2,KERN_INFO "lcdc%d>>%s>>y_addr:0x%x>>uv_addr:0x%x\n",lcdc_dev->id,__func__,y_addr,uv_addr);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN2_MST, y_addr);
+		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return 0;
+}
+
+static  int win0_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+
+	xact = par->xact;			    //active (origin) picture window width/height		
+	yact = par->yact;
+	xvir = par->xvir;			   // virtual resolution		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+   
+	
+	ScaleYrgbX = CalScale(xact, par->xsize); //both RGB and yuv need this two factor
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	switch (par->format)
+	{
+		case YUV422:// yuv422
+			ScaleCbrX = CalScale((xact/2), par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		case YUV420: // yuv420
+			ScaleCbrX = CalScale(xact/2, par->xsize);
+		   	ScaleCbrY = CalScale(yact/2, par->ysize);
+		   	break;
+		case YUV444:// yuv444
+			ScaleCbrX = CalScale(xact, par->xsize);
+			ScaleCbrY = CalScale(yact, par->ysize);
+			break;
+		default:
+		   break;
+	}
+
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		LcdWrReg(lcdc_dev, WIN0_SCL_FACTOR_CBR,v_X_SCL_FACTOR(ScaleCbrX)| v_Y_SCL_FACTOR(ScaleCbrY));
+		LcdMskReg(lcdc_dev, SYS_CTRL1, m_W0_FORMAT, v_W0_FORMAT(par->format));		//(inf->video_mode==0)
+		LcdWrReg(lcdc_dev, WIN0_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		LcdWrReg(lcdc_dev, WIN0_DSP_ST, v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN0_DSP_INFO, v_DSP_WIDTH(par->xsize)| v_DSP_HEIGHT(par->ysize));
+		LcdMskReg(lcdc_dev, WIN0_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,
+			v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format) 
+		{
+			case ARGB888:
+				LcdWrReg(lcdc_dev, WIN0_VIR,v_ARGB888_VIRWIDTH(xvir));
+				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+			case RGB888:  //rgb888
+				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
+				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W0_RGB_RB_SWAP,v_W0_RGB_RB_SWAP(1));
+				break;
+			case RGB565:  //rgb565
+				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB565_VIRWIDTH(xvir));
+				break;
+			case YUV422:
+			case YUV420:   
+				LcdWrReg(lcdc_dev, WIN0_VIR,v_YUV_VIRWIDTH(xvir));
+				break;
+			default:
+				LcdWrReg(lcdc_dev, WIN0_VIR,v_RGB888_VIRWIDTH(xvir));
+				break;
+		}
+
+		LCDC_REG_CFG_DONE();
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+    return 0;
+
+}
+
+static int win1_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	ScaleYrgbX = CalScale(xact, par->xsize);
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		switch (par->format)
+	 	{
+			case YUV422:// yuv422
+				ScaleCbrX = CalScale((xact/2), par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			case YUV420: // yuv420
+				ScaleCbrX = CalScale(xact/2, par->xsize);
+				ScaleCbrY = CalScale(yact/2, par->ysize);
+				break;
+			case YUV444:// yuv444
+				ScaleCbrX = CalScale(xact, par->xsize);
+				ScaleCbrY = CalScale(yact, par->ysize);
+				break;
+			default:
+				break;
+		}
+
+		LcdWrReg(lcdc_dev, WIN1_SCL_FACTOR_YRGB, v_X_SCL_FACTOR(ScaleYrgbX) | v_Y_SCL_FACTOR(ScaleYrgbY));
+		LcdWrReg(lcdc_dev, WIN1_SCL_FACTOR_CBR,  v_X_SCL_FACTOR(ScaleCbrX) | v_Y_SCL_FACTOR(ScaleCbrY));
+		LcdMskReg(lcdc_dev,SYS_CTRL1, m_W1_FORMAT, v_W1_FORMAT(par->format));
+		LcdWrReg(lcdc_dev, WIN1_ACT_INFO,v_ACT_WIDTH(xact) | v_ACT_HEIGHT(yact));
+		LcdWrReg(lcdc_dev, WIN1_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN1_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		LcdMskReg(lcdc_dev, WIN1_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format)
+	    	{
+		        case ARGB888:
+				LcdWrReg(lcdc_dev, WIN1_VIR,v_ARGB888_VIRWIDTH(xvir));
+				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+		        case RGB888:  //rgb888
+				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
+				// LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+		        case RGB565:  //rgb565
+				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB565_VIRWIDTH(xvir));
+				break;
+		        case YUV422:
+		        case YUV420:   
+				LcdWrReg(lcdc_dev, WIN1_VIR,v_YUV_VIRWIDTH(xvir));
+				break;
+		        default:
+				LcdWrReg(lcdc_dev, WIN1_VIR,v_RGB888_VIRWIDTH(xvir));
+				break;
+	    	}
+		
+		LCDC_REG_CFG_DONE(); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int win2_set_par(struct rk30_lcdc_device *lcdc_dev,rk_screen *screen,
+	struct layer_par *par )
+{
+	u32 xact, yact, xvir, yvir, xpos, ypos;
+	u32 ScaleYrgbX = 0x1000;
+	u32 ScaleYrgbY = 0x1000;
+	u32 ScaleCbrX = 0x1000;
+	u32 ScaleCbrY = 0x1000;
+	
+	xact = par->xact;			
+	yact = par->yact;
+	xvir = par->xvir;		
+	yvir = par->yvir;
+	xpos = par->xpos+screen->left_margin + screen->hsync_len;
+	ypos = par->ypos+screen->upper_margin + screen->vsync_len;
+	
+	ScaleYrgbX = CalScale(xact, par->xsize);
+	ScaleYrgbY = CalScale(yact, par->ysize);
+	DBG(1,"%s for lcdc%d>>format:%d>>>xact:%d>>yact:%d>>xsize:%d>>ysize:%d>>xvir:%d>>yvir:%d>>xpos:%d>>ypos:%d>>\n",
+		__func__,lcdc_dev->id,par->format,xact,yact,par->xsize,par->ysize,xvir,yvir,xpos,ypos);
+
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+
+		LcdMskReg(lcdc_dev,SYS_CTRL1, m_W2_FORMAT, v_W2_FORMAT(par->format));
+		LcdWrReg(lcdc_dev, WIN2_DSP_ST,v_DSP_STX(xpos) | v_DSP_STY(ypos));
+		LcdWrReg(lcdc_dev, WIN2_DSP_INFO,v_DSP_WIDTH(par->xsize) | v_DSP_HEIGHT(par->ysize));
+		// enable win1 color key and set the color to black(rgb=0)
+		LcdMskReg(lcdc_dev, WIN2_COLOR_KEY_CTRL, m_COLORKEY_EN | m_KEYCOLOR,v_COLORKEY_EN(1) | v_KEYCOLOR(0));
+		switch(par->format)
+	    	{
+		        case ARGB888:
+				LcdWrReg(lcdc_dev, WIN2_VIR,v_ARGB888_VIRWIDTH(xvir));
+				//LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+		        case RGB888:  //rgb888
+				LcdWrReg(lcdc_dev, WIN2_VIR,v_RGB888_VIRWIDTH(xvir));
+				// LcdMskReg(lcdc_dev,SYS_CTRL1,m_W1_RGB_RB_SWAP,v_W1_RGB_RB_SWAP(1));
+				break;
+		        case RGB565:  //rgb565
+				LcdWrReg(lcdc_dev, WIN2_VIR,v_RGB565_VIRWIDTH(xvir));
+				break;
+		        case YUV422:
+		        case YUV420:   
+				LcdWrReg(lcdc_dev, WIN2_VIR,v_YUV_VIRWIDTH(xvir));
+				break;
+		        default:
+				LcdWrReg(lcdc_dev, WIN2_VIR,v_RGB888_VIRWIDTH(xvir));
+				break;
+	    	}
+		
+		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); 
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+    return 0;
+}
+
+static int rk30_lcdc_open(struct rk_lcdc_device_driver *dev_drv,int layer_id,bool open)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	if(layer_id == 0)
+	{
+		win0_open(lcdc_dev,open);	
+	}
+	else if(layer_id == 1)
+	{
+		win1_open(lcdc_dev,open);
+	}
+	else if(layer_id == 2)
+	{
+		win2_open(lcdc_dev,open);
+	}
+
+	return 0;
+}
+
+static int rk30_lcdc_set_par(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_set_par(lcdc_dev,screen,par);
+	}
+	else if(layer_id == 2)
+	{
+		par = dev_drv->layer_par[2];
+        	win2_set_par(lcdc_dev,screen,par);
+	}
+	
+	return 0;
+}
+
+int rk30_lcdc_pan_display(struct rk_lcdc_device_driver * dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = NULL;
+	rk_screen *screen = dev_drv->cur_screen;
+	unsigned long flags;
+	int timeout;
+	if(!screen)
+	{
+		printk(KERN_ERR "screen is null!\n");
+		return -ENOENT;	
+	}
+	if(layer_id==0)
+	{
+		par = dev_drv->layer_par[0];
+        	win0_display(lcdc_dev,par);
+	}
+	else if(layer_id==1)
+	{
+		par = dev_drv->layer_par[1];
+        	win1_display(lcdc_dev,par);
+	}
+	else if(layer_id == 2)
+	{
+		par = dev_drv->layer_par[2];
+        	win2_display(lcdc_dev,par);
+	}
+	if((dev_drv->first_frame))  //this is the first frame of the system ,enable frame start interrupt
+	{
+		dev_drv->first_frame = 0;
+		LcdMskReg(lcdc_dev,INT_STATUS,m_FRM_START_INT_CLEAR |m_FRM_START_INT_EN ,
+			  v_FRM_START_INT_CLEAR(1) | v_FRM_START_INT_EN(1));
+		LCDC_REG_CFG_DONE();  // write any value to  REG_CFG_DONE let config become effective
+		 
+	}
+
+	if(dev_drv->num_buf < 3) //3buffer ,no need to  wait for sysn
+	{
+		spin_lock_irqsave(&dev_drv->cpl_lock,flags);
+		init_completion(&dev_drv->frame_done);
+		spin_unlock_irqrestore(&dev_drv->cpl_lock,flags);
+		timeout = wait_for_completion_timeout(&dev_drv->frame_done,msecs_to_jiffies(dev_drv->cur_screen->ft+5));
+		if(!timeout&&(!dev_drv->frame_done.done))
+		{
+			printk(KERN_ERR "wait for new frame start time out!\n");
+			return -ETIMEDOUT;
+		}
+	}
+	
+	return 0;
+}
+
+int rk30_lcdc_ioctl(struct rk_lcdc_device_driver * dev_drv,unsigned int cmd, unsigned long arg,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	u32 panel_size[2];
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	switch(cmd)
+	{
+		case FBIOGET_PANEL_SIZE:    //get panel size
+                	panel_size[0] = dev_drv->screen0->x_res;
+                	panel_size[1] = dev_drv->screen0->y_res;
+            		if(copy_to_user(argp, panel_size, 8)) 
+				return -EFAULT;
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+static int rk30_lcdc_get_layer_state(struct rk_lcdc_device_driver *dev_drv,int layer_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	struct layer_par *par = dev_drv->layer_par[layer_id];
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(layer_id == 0)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CTRL1,m_W0_EN);
+		}
+		else if( layer_id == 1)
+		{
+			par->state = LcdReadBit(lcdc_dev,SYS_CTRL1,m_W1_EN);
+		}
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+	return par->state;
+	
+}
+
+/***********************************
+overlay manager
+swap:1 win0 on the top of win1
+        0 win1 on the top of win0
+set  : 1 set overlay 
+        0 get overlay state
+************************************/
+static int rk30_lcdc_ovl_mgr(struct rk_lcdc_device_driver *dev_drv,int swap,bool set)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	int ovl;
+	spin_lock(&lcdc_dev->reg_lock);
+	if(lcdc_dev->clk_on)
+	{
+		if(set)  //set overlay
+		{
+			LcdMskReg(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP,v_W0W1_POSITION_SWAP(swap));
+			LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01);
+			LCDC_REG_CFG_DONE();
+			ovl = swap;
+		}
+		else  //get overlay
+		{
+			ovl = LcdReadBit(lcdc_dev,DSP_CTRL0,m_W0W1_POSITION_SWAP);
+		}
+	}
+	else
+	{
+		ovl = -EPERM;
+	}
+	spin_unlock(&lcdc_dev->reg_lock);
+
+	return ovl;
+}
+
+static ssize_t dump_win0_disp_info(struct rk30_lcdc_device *lcdc_dev,char *buf)
+{
+        char format[9] = "NULL";
+        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CTRL1);
+        u32 xvir,act_info,dsp_info,dsp_st,factor;
+        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
+        u16 x_scale,y_scale;
+        switch((fmt_id&m_W0_FORMAT)>>4)
+        {
+                case 0:
+                        strcpy(format,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format,"RGB888");
+                        break;
+                case 2:
+                        strcpy(format,"RGB565");
+                        break;
+                case 4:
+                        strcpy(format,"YCbCr420");
+                        break;
+                case 5:
+                        strcpy(format,"YCbCr422");
+                        break;
+                case 6:
+                        strcpy(format,"YCbCr444");
+                        break;
+                default:
+                        strcpy(format,"inval\n");
+                        break;
+        }
+
+        xvir = LcdRdReg(lcdc_dev,WIN0_VIR)&0xffff;
+        act_info = LcdRdReg(lcdc_dev,WIN0_ACT_INFO);
+        dsp_info = LcdRdReg(lcdc_dev,WIN0_DSP_INFO);
+        dsp_st = LcdRdReg(lcdc_dev,WIN0_DSP_ST);
+        factor = LcdRdReg(lcdc_dev,WIN0_SCL_FACTOR_YRGB);
+        x_act =  (act_info&0xffff) + 1;
+        y_act = (act_info>>16) + 1;
+        x_dsp = (dsp_info&0xffff) + 1;
+        y_dsp = (dsp_info>>16) + 1;
+	 x_factor = factor&0xffff;
+        y_factor = factor>>16;
+        x_scale = 4096*100/x_factor;
+        y_scale = 4096*100/y_factor;
+        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxact:%d\nyact:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nx_scale:%d.%d\ny_scale:%d.%d\nformat:%s\n",
+                xvir,x_act,y_act,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,x_scale/100,x_scale%100,y_scale/100,y_scale%100,format);
+
+}
+static ssize_t dump_win1_disp_info(struct rk30_lcdc_device *lcdc_dev,char *buf)
+{
+        char format[9] = "NULL";
+        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CTRL1);
+        u32 xvir,act_info,dsp_info,dsp_st,factor;
+        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
+        u16 x_scale,y_scale;
+        switch((fmt_id&m_W1_FORMAT)>>7)
+        {
+                case 0:
+                        strcpy(format,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format,"RGB888");
+                        break;
+                case 2:
+                        strcpy(format,"RGB565");
+                        break;
+                case 4:
+                        strcpy(format,"YCbCr420");
+                        break;
+                case 5:
+                        strcpy(format,"YCbCr422");
+                        break;
+                case 6:
+                        strcpy(format,"YCbCr444");
+                        break;
+                default:
+                        strcpy(format,"inval\n");
+                        break;
+        }
+
+        xvir = LcdRdReg(lcdc_dev,WIN1_VIR)&0xffff;
+        act_info = LcdRdReg(lcdc_dev,WIN1_ACT_INFO);
+        dsp_info = LcdRdReg(lcdc_dev,WIN1_DSP_INFO);
+        dsp_st = LcdRdReg(lcdc_dev,WIN1_DSP_ST);
+        factor = LcdRdReg(lcdc_dev,WIN1_SCL_FACTOR_YRGB);
+        x_act = (act_info&0xffff) + 1;
+        y_act = (act_info>>16) + 1;
+        x_dsp = (dsp_info&0xffff) + 1;
+        y_dsp = (dsp_info>>16) + 1;
+        x_factor = factor&0xffff;
+        y_factor = factor>>16;
+        x_scale = 4096*100/x_factor;
+        y_scale = 4096*100/y_factor;
+	 return snprintf(buf,PAGE_SIZE,"xvir:%d\nxact:%d\nyact:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nx_scale:%d.%d\ny_scale:%d.%d\nformat:%s\n",
+                xvir,x_act,y_act,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,x_scale/100,x_scale%100,y_scale/100,y_scale%100,format);
+
+}
+
+static ssize_t dump_win2_disp_info(struct rk30_lcdc_device *lcdc_dev,char *buf)
+{
+        char format[9] = "NULL";
+        u32 fmt_id = LcdRdReg(lcdc_dev,SYS_CTRL1);
+        u32 xvir,act_info,dsp_info,dsp_st,factor;
+        u16 x_act,y_act,x_dsp,y_dsp,x_factor,y_factor;
+        u16 x_scale,y_scale;
+        switch((fmt_id&m_W2_FORMAT)>>10)
+        {
+                case 0:
+                        strcpy(format,"ARGB888");
+                        break;
+                case 1:
+                        strcpy(format,"RGB888");
+                        break;
+                case 2:
+                        strcpy(format,"RGB565");
+                        break;
+                case 4:
+                        strcpy(format,"8bpp");
+                        break;
+                        case 5:
+                        strcpy(format,"4bpp");
+                        break;
+                case 6:
+                        strcpy(format,"2bpp");
+                        break;
+                case 7:
+                        strcpy(format,"1bpp");
+                        break;
+                default:
+                        strcpy(format,"inval\n");
+                        break;
+        }
+
+        xvir = LcdRdReg(lcdc_dev,WIN2_VIR)&0xffff;
+        dsp_info = LcdRdReg(lcdc_dev,WIN2_DSP_INFO);
+        dsp_st = LcdRdReg(lcdc_dev,WIN2_DSP_ST);
+
+        x_dsp = dsp_info&0xffff;
+        y_dsp = dsp_info>>16;
+
+        return snprintf(buf,PAGE_SIZE,"xvir:%d\nxdsp:%d\nydsp:%d\nx_st:%d\ny_st:%d\nformat:%s\n",
+                xvir,x_dsp,y_dsp,dsp_st&0xffff,dsp_st>>16,format);
+}
+
+static ssize_t  rk30_lcdc_get_disp_info(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id)
+{
+        struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+        if(layer_id == 0)
+        {
+                return dump_win0_disp_info(lcdc_dev,buf);
+        }
+        else if(layer_id == 1)
+        {
+                return dump_win1_disp_info(lcdc_dev,buf);
+        }
+        else if(layer_id == 2)
+        {
+                return dump_win2_disp_info(lcdc_dev,buf);
+        }
+
+        return 0;
+}
+
+
+
+/*******************************************
+lcdc fps manager,set or get lcdc fps
+set:0 get
+     1 set
+********************************************/
+static int rk30_lcdc_fps_mgr(struct rk_lcdc_device_driver *dev_drv,int fps,bool set)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	rk_screen * screen = dev_drv->cur_screen;
+	u64 ft = 0;
+	u32 dotclk;
+	int ret;
+
+	if(set)
+	{
+		ft = div_u64(1000000000000llu,fps);
+		dev_drv->pixclock = div_u64(ft,(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+				(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len));
+		dotclk = div_u64(1000000000000llu,dev_drv->pixclock);
+		ret = clk_set_rate(lcdc_dev->dclk, dotclk);
+		if(ret)
+		{
+	        	printk(KERN_ERR ">>>>>> set lcdc%d dclk failed\n",lcdc_dev->id);
+		}
+	    	dev_drv->pixclock = lcdc_dev->pixclock = div_u64(1000000000000llu, clk_get_rate(lcdc_dev->dclk));
+			
+	}
+	
+	ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
+	(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
+	(dev_drv->pixclock);       // one frame time ,(pico seconds)
+	fps = div64_u64(1000000000000llu,ft);
+	screen->ft = 1000/fps ;  //one frame time in ms
+	return fps;
+}
+
+static int rk30_fb_layer_remap(struct rk_lcdc_device_driver *dev_drv,
+	enum fb_win_map_order order)
+{
+       mutex_lock(&dev_drv->fb_win_id_mutex);
+       if(order == FB_DEFAULT_ORDER )
+	{
+		order = FB0_WIN1_FB1_WIN0_FB2_WIN2;
+	}
+       dev_drv->fb2_win_id  = order/100;
+       dev_drv->fb1_win_id = (order/10)%10;
+       dev_drv->fb0_win_id = order%10;
+       mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+       printk("fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
+               dev_drv->fb2_win_id);
+
+       return 0;
+}
+
+static int rk30_fb_get_layer(struct rk_lcdc_device_driver *dev_drv,const char *id)
+{
+       int layer_id = 0;
+       mutex_lock(&dev_drv->fb_win_id_mutex);
+       if(!strcmp(id,"fb0")||!strcmp(id,"fb3"))
+       {
+               layer_id = dev_drv->fb0_win_id;
+       }
+       else if(!strcmp(id,"fb1")||!strcmp(id,"fb4"))
+       {
+               layer_id = dev_drv->fb1_win_id;
+       }
+       else if(!strcmp(id,"fb2")||!strcmp(id,"fb5"))
+       {
+               layer_id = dev_drv->fb2_win_id;
+       }
+       mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+       return  layer_id;
+}
+
+static int rk30_read_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+{
+
+	return 0;
+}
+
+static int rk30_set_dsp_lut(struct rk_lcdc_device_driver *dev_drv,int *lut)
+{
+	int i=0;
+	int __iomem *c;
+	int v;
+	int ret = 0;
+
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+	LCDC_REG_CFG_DONE();
+	msleep(25);
+	if(dev_drv->cur_screen->dsp_lut)
+	{
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i] = lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+			
+		}
+	}
+	else
+	{
+		printk(KERN_WARNING "no buffer to backup lut data!\n");
+		ret =  -1;
+	}
+	LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+	LCDC_REG_CFG_DONE();
+
+	return ret;
+}
+int rk30_lcdc_early_suspend(struct rk_lcdc_device_driver *dev_drv)
+{
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	
+	spin_lock(&lcdc_dev->reg_lock);
+	if(likely(lcdc_dev->clk_on))
+	{
+		lcdc_dev->clk_on = 0;
+		LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+		LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(1));
+		LCDC_REG_CFG_DONE();
+		spin_unlock(&lcdc_dev->reg_lock);
+	}
+	else  //clk already disabled
+	{
+		spin_unlock(&lcdc_dev->reg_lock);
+		return 0;
+	}
+	
+		
+	mdelay(1);
+	clk_disable(lcdc_dev->dclk);
+	clk_disable(lcdc_dev->hclk);
+	clk_disable(lcdc_dev->aclk);
+	clk_disable(lcdc_dev->pd);
+
+	return 0;
+}
+
+
+int rk30_lcdc_early_resume(struct rk_lcdc_device_driver *dev_drv)
+{  
+	struct rk30_lcdc_device *lcdc_dev = container_of(dev_drv,struct rk30_lcdc_device,driver);
+	int i=0;
+	int __iomem *c;
+	int v;
+	if(!lcdc_dev->clk_on)
+	{
+		clk_enable(lcdc_dev->pd);
+		clk_enable(lcdc_dev->hclk);
+		clk_enable(lcdc_dev->dclk);
+		clk_enable(lcdc_dev->aclk);
+	}
+	memcpy((u8*)lcdc_dev->preg, (u8*)&lcdc_dev->regbak, 0xc4);  //resume reg
+
+	spin_lock(&lcdc_dev->reg_lock);
+	if(dev_drv->cur_screen->dsp_lut)			//resume dsp lut
+	{
+		LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(0));
+		LCDC_REG_CFG_DONE();
+		mdelay(25);
+		for(i=0;i<256;i++)
+		{
+			v = dev_drv->cur_screen->dsp_lut[i];
+			c = lcdc_dev->dsp_lut_addr_base+i;
+			writel_relaxed(v,c);
+			
+		}
+		LcdMskReg(lcdc_dev,SYS_CTRL1,m_DSP_LUT_RAM_EN,v_DSP_LUT_RAM_EN(1));
+	}
+	if(lcdc_dev->atv_layer_cnt)
+	{
+		LcdMskReg(lcdc_dev, SYS_CTRL0,m_LCDC_STANDBY,v_LCDC_STANDBY(0));
+		LCDC_REG_CFG_DONE();
+	}
+	lcdc_dev->clk_on = 1;
+	spin_unlock(&lcdc_dev->reg_lock);
+	
+    	return 0;
+}
+static irqreturn_t rk30_lcdc_isr(int irq, void *dev_id)
+{
+	struct rk30_lcdc_device *lcdc_dev = (struct rk30_lcdc_device *)dev_id;
+	
+	LcdMskReg(lcdc_dev, INT_STATUS, m_FRM_START_INT_CLEAR, v_FRM_START_INT_CLEAR(1));
+	LCDC_REG_CFG_DONE();
+	//LcdMskReg(lcdc_dev, INT_STATUS, m_LINE_FLAG_INT_CLEAR, v_LINE_FLAG_INT_CLEAR(1));
+ 
+	if(lcdc_dev->driver.num_buf < 3)  //three buffer ,no need to wait for sync
+	{
+		spin_lock(&(lcdc_dev->driver.cpl_lock));
+		complete(&(lcdc_dev->driver.frame_done));
+		spin_unlock(&(lcdc_dev->driver.cpl_lock));
+	}
+	return IRQ_HANDLED;
+}
+
+static struct layer_par lcdc_layer[] = {
+	[0] = {
+		.name  		= "win0",
+		.id		= 0,
+		.support_3d	= true,
+	},
+	[1] = {
+		.name  		= "win1",
+		.id		= 1,
+		.support_3d	= false,
+	},
+	[2] = {
+		.name  		= "win2",
+		.id		= 2,
+		.support_3d	= false,
+	},
+};
+
+static struct rk_lcdc_device_driver lcdc_driver = {
+	.name			= "lcdc",
+	.def_layer_par		= lcdc_layer,
+	.num_layer		= ARRAY_SIZE(lcdc_layer),
+	.open			= rk30_lcdc_open,
+	.init_lcdc		= rk30_lcdc_init,
+	.ioctl			= rk30_lcdc_ioctl,
+	.suspend		= rk30_lcdc_early_suspend,
+	.resume			= rk30_lcdc_early_resume,
+	.set_par       		= rk30_lcdc_set_par,
+	.blank         		= rk30_lcdc_blank,
+	.pan_display            = rk30_lcdc_pan_display,
+	.load_screen		= rk30_load_screen,
+	.get_layer_state	= rk30_lcdc_get_layer_state,
+	.ovl_mgr		= rk30_lcdc_ovl_mgr,
+	.get_disp_info		= rk30_lcdc_get_disp_info,
+	.fps_mgr		= rk30_lcdc_fps_mgr,
+	.fb_get_layer           = rk30_fb_get_layer,
+	.fb_layer_remap         = rk30_fb_layer_remap,
+	.set_dsp_lut            = rk30_set_dsp_lut,
+	.read_dsp_lut           = rk30_read_dsp_lut,
+};
+#ifdef CONFIG_PM
+static int rk30_lcdc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int rk30_lcdc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define rk30_lcdc_suspend NULL
+#define rk30_lcdc_resume NULL
+#endif
+
+static int __devinit rk30_lcdc_probe (struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev=NULL;
+	rk_screen *screen;
+	rk_screen *screen1;
+	struct rk29fb_info *screen_ctr_info;
+	struct resource *res = NULL;
+	struct resource *mem;
+	int ret = 0;
+	
+	/*************Malloc rk30lcdc_inf and set it to pdev for drvdata**********/
+	lcdc_dev = kzalloc(sizeof(struct rk30_lcdc_device), GFP_KERNEL);
+    	if(!lcdc_dev)
+    	{
+        	dev_err(&pdev->dev, ">>rk30 lcdc device kmalloc fail!");
+        	return -ENOMEM;
+    	}
+	platform_set_drvdata(pdev, lcdc_dev);
+	lcdc_dev->id = pdev->id;
+	screen_ctr_info = (struct rk29fb_info * )pdev->dev.platform_data;
+	screen =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+	if(!screen)
+	{
+		dev_err(&pdev->dev, ">>rk30 lcdc screen kmalloc fail!");
+        	ret =  -ENOMEM;
+		goto err0;
+	}
+       screen->lcdc_id = lcdc_dev->id;
+       screen->screen_id = 0;
+
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& defined(CONFIG_RK610_LVDS)
+       screen1 =  kzalloc(sizeof(rk_screen), GFP_KERNEL);
+       if(!screen1)
+       {
+               dev_err(&pdev->dev, ">>rk31 lcdc screen1 kmalloc fail!");
+               ret =  -ENOMEM;
+               goto err0;
+       }
+       screen1->lcdc_id = 1;
+       screen1->screen_id = 1;
+       printk("use lcdc%d and rk610 implemention dual display!\n",lcdc_dev->id);
+               
+#endif
+	/****************get lcdc0 reg  *************************/
+	res = platform_get_resource(pdev, IORESOURCE_MEM,0);
+	if (res == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to get io resource for lcdc%d \n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+    	lcdc_dev->reg_phy_base = res->start;
+	lcdc_dev->len = resource_size(res);
+    	mem = request_mem_region(lcdc_dev->reg_phy_base, resource_size(res), pdev->name);
+    	if (mem == NULL)
+    	{
+        	dev_err(&pdev->dev, "failed to request mem region for lcdc%d\n",lcdc_dev->id);
+        	ret = -ENOENT;
+		goto err1;
+    	}
+	lcdc_dev->reg_vir_base = ioremap(lcdc_dev->reg_phy_base,  resource_size(res));
+	if (lcdc_dev->reg_vir_base == NULL)
+	{
+		dev_err(&pdev->dev, "cannot map IO\n");
+		ret = -ENXIO;
+		goto err2;
+	}
+	
+    	lcdc_dev->preg = (LCDC_REG*)lcdc_dev->reg_vir_base;
+	lcdc_dev->dsp_lut_addr_base = &lcdc_dev->preg->DSP_LUT_ADDR;
+	printk("lcdc%d:reg_phy_base = 0x%08x,reg_vir_base:0x%p\n",pdev->id,lcdc_dev->reg_phy_base, lcdc_dev->preg);
+	lcdc_dev->driver.dev=&pdev->dev;
+	lcdc_dev->driver.screen0 = screen;
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)&& defined(CONFIG_RK610_LVDS)
+       lcdc_dev->driver.screen1 = screen1;
+#endif
+	lcdc_dev->driver.cur_screen = screen;
+	lcdc_dev->driver.screen_ctr_info = screen_ctr_info;
+	spin_lock_init(&lcdc_dev->reg_lock);
+	lcdc_dev->irq = platform_get_irq(pdev, 0);
+	if(lcdc_dev->irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto err3;
+	}
+	ret = request_irq(lcdc_dev->irq, rk30_lcdc_isr, IRQF_DISABLED,dev_name(&pdev->dev),lcdc_dev);
+	if (ret)
+	{
+	       dev_err(&pdev->dev, "cannot requeset irq %d - err %d\n", lcdc_dev->irq, ret);
+	       ret = -EBUSY;
+	       goto err3;
+	}
+	ret = rk_fb_register(&(lcdc_dev->driver),&lcdc_driver,lcdc_dev->id);
+	if(ret < 0)
+	{
+		printk(KERN_ERR "register fb for lcdc%d failed!\n",lcdc_dev->id);
+		goto err4;
+	}
+	printk("rk30 lcdc%d probe ok!\n",lcdc_dev->id);
+
+	return 0;
+
+err4:
+	free_irq(lcdc_dev->irq,lcdc_dev);
+err3:	
+	iounmap(lcdc_dev->reg_vir_base);
+err2:
+	release_mem_region(lcdc_dev->reg_phy_base,resource_size(res));
+err1:
+	kfree(screen);
+err0:
+	platform_set_drvdata(pdev, NULL);
+	kfree(lcdc_dev);
+	return ret;
+    
+}
+static int __devexit rk30_lcdc_remove(struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk30_lcdc_deinit(lcdc_dev);
+	iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);
+	return 0;
+}
+
+static void rk30_lcdc_shutdown(struct platform_device *pdev)
+{
+	struct rk30_lcdc_device *lcdc_dev = platform_get_drvdata(pdev);
+	if(lcdc_dev->driver.cur_screen->standby) //standby the screen if necessary
+		lcdc_dev->driver.cur_screen->standby(1);
+	if(lcdc_dev->driver.screen_ctr_info->io_disable) //power off the screen if necessary
+		lcdc_dev->driver.screen_ctr_info->io_disable();
+	if(lcdc_dev->driver.cur_screen->sscreen_set) //turn off  lvds if necessary
+		lcdc_dev->driver.cur_screen->sscreen_set(lcdc_dev->driver.cur_screen , 0);
+	rk_fb_unregister(&(lcdc_dev->driver));
+	rk30_lcdc_deinit(lcdc_dev);
+	/*iounmap(lcdc_dev->reg_vir_base);
+	release_mem_region(lcdc_dev->reg_phy_base,lcdc_dev->len);
+	kfree(lcdc_dev->screen);
+	kfree(lcdc_dev);*/
+}
+
+
+static struct platform_driver rk30lcdc_driver = {
+	.probe		= rk30_lcdc_probe,
+	.remove		= __devexit_p(rk30_lcdc_remove),
+	.driver		= {
+		.name	= "rk30-lcdc",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= rk30_lcdc_suspend,
+	.resume		= rk30_lcdc_resume,
+	.shutdown   = rk30_lcdc_shutdown,
+};
+
+static int __init rk30_lcdc_module_init(void)
+{
+    return platform_driver_register(&rk30lcdc_driver);
+}
+
+static void __exit rk30_lcdc_module_exit(void)
+{
+    platform_driver_unregister(&rk30lcdc_driver);
+}
+
+
+
+fs_initcall(rk30_lcdc_module_init);
+module_exit(rk30_lcdc_module_exit);
+
+
+
diff --git a/drivers/video/rockchip/lcdc/rk30_lcdc.h b/drivers/video/rockchip/lcdc/rk30_lcdc.h
new file mode 100755
index 0000000..9576ed5
--- /dev/null
+++ b/drivers/video/rockchip/lcdc/rk30_lcdc.h
@@ -0,0 +1,542 @@
+#ifndef RK30_LCDC_H_
+#define RK30_LCDC_H_
+
+#include<linux/rk_fb.h>
+
+#define LcdReadBit(inf, addr, msk)      ((inf->regbak.addr=inf->preg->addr)&(msk))
+#define LcdWrReg(inf, addr, val)        inf->preg->addr=inf->regbak.addr=(val)
+#define LcdRdReg(inf, addr)             (inf->preg->addr)
+#define LcdSetBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) |= (msk))
+#define LcdClrBit(inf, addr, msk)       inf->preg->addr=((inf->regbak.addr) &= ~(msk))
+#define LcdSetRegBit(inf, addr, msk)    inf->preg->addr=((inf->preg->addr) |= (msk))
+#define LcdMskReg(inf, addr, msk, val)  (inf->regbak.addr)&=~(msk);   inf->preg->addr=(inf->regbak.addr|=(val))
+#define LCDC_REG_CFG_DONE()		LcdWrReg(lcdc_dev, REG_CFG_DONE, 0x01); dsb()
+
+/********************************************************************
+**                          结构定义                                *
+********************************************************************/
+/* LCDC的寄存器结构 */
+
+typedef volatile struct tagLCDC_REG
+{
+    /* offset 0x00~0xc0 */
+	unsigned int SYS_CTRL0;               //0x00 system control register 0
+	unsigned int SYS_CTRL1;				  //0x04 system control register 1
+	unsigned int DSP_CTRL0;				 //0x08 display control register 0
+	unsigned int DSP_CTRL1;				 //0x0c display control register 1
+	unsigned int INT_STATUS;             //0x10 Interrupt status register
+	unsigned int MCU_CTRL ;				 //0x14 MCU mode contol register
+	unsigned int BLEND_CTRL;             //0x18 Blending control register
+	unsigned int WIN0_COLOR_KEY_CTRL;     //0x1c Win0 blending control register
+	unsigned int WIN1_COLOR_KEY_CTRL;     //0x20 Win1 blending control register
+	unsigned int WIN2_COLOR_KEY_CTRL;     //0x24 Win2 blending control register
+	unsigned int WIN0_YRGB_MST0;           //0x28 Win0 active YRGB memory start address0
+	unsigned int WIN0_CBR_MST0;            //0x2c Win0 active Cbr memory start address0
+	unsigned int WIN0_YRGB_MST1;           //0x30 Win0 active YRGB memory start address1
+	unsigned int WIN0_CBR_MST1;            //0x34 Win0 active Cbr memory start address1
+	unsigned int WIN0_VIR;                //0x38 WIN0 virtual display width/height
+	unsigned int WIN0_ACT_INFO;           //0x3C Win0 active window width/height
+	unsigned int WIN0_DSP_INFO;           //0x40 Win0 display width/height on panel
+	unsigned int WIN0_DSP_ST;             //0x44 Win0 display start point on panel
+	unsigned int WIN0_SCL_FACTOR_YRGB;    //0x48Win0 YRGB scaling  factor setting
+	unsigned int WIN0_SCL_FACTOR_CBR;     //0x4c Win0 YRGB scaling factor setting
+	unsigned int WIN0_SCL_OFFSET;         //0x50 Win0 Cbr scaling start point offset
+	unsigned int WIN1_YRGB_MST;           //0x54 Win1 active YRGB memory start address
+	unsigned int WIN1_CBR_MST;            //0x58 Win1 active Cbr memory start address
+	unsigned int WIN1_VIR;                //0x5c WIN1 virtual display width/height
+	unsigned int WIN1_ACT_INFO;           //0x60 Win1 active window width/height
+	unsigned int WIN1_DSP_INFO;           //0x64 Win1 display width/height on panel
+	unsigned int WIN1_DSP_ST;             //0x68 Win1 display start point on panel
+	unsigned int WIN1_SCL_FACTOR_YRGB;    //0x6c Win1 YRGB scaling  factor setting
+	unsigned int WIN1_SCL_FACTOR_CBR;     //0x70 Win1 YRGB scaling factor setting
+	unsigned int WIN1_SCL_OFFSET;         //0x74 Win1 Cbr scaling start point offset
+	unsigned int WIN2_MST;		 		  //0x78 win2 memort start address
+	unsigned int WIN2_VIR;				  //0x7c win2 virtual stride
+	unsigned int WIN2_DSP_INFO;           //0x80 Win2 display width/height on panel
+	unsigned int WIN2_DSP_ST;             //0x84 Win2 display start point on panel
+	unsigned int HWC_MST;                 //0x88 HWC memory start address
+	unsigned int HWC_DSP_ST;              //0x8C HWC display start point on panel
+	unsigned int HWC_COLOR_LUT0;          //0x90 Hardware cursor color 2’b01 look up table 0
+	unsigned int HWC_COLOR_LUT1;          //0x94 Hardware cursor color 2’b10 look up table 1
+	unsigned int HWC_COLOR_LUT2;          //0x98 Hardware cursor color 2’b11 look up table 2
+	unsigned int DSP_HTOTAL_HS_END;       //0x9c Panel scanning horizontal width and hsync pulse end point
+	unsigned int DSP_HACT_ST_END;         //0xa0 Panel active horizontal scanning start/end point
+	unsigned int DSP_VTOTAL_VS_END;       //0xa4 Panel scanning vertical height and vsync pulse end point
+	unsigned int DSP_VACT_ST_END;         //0xa8 Panel active vertical scanning start/end point
+	unsigned int DSP_VS_ST_END_F1;        //0xac Vertical scanning start point and vsync pulse end point of even filed in interlace mode
+	unsigned int DSP_VACT_ST_END_F1;      //0xb0 Vertical scanning active start/end point of even filed in interlace mode
+	unsigned int reserved0[(0xc0-0xb4)/4];
+	unsigned int REG_CFG_DONE;            //0xc0 REGISTER CONFIG FINISH
+	unsigned int reserved1[(0x100-0xc4)/4];
+	unsigned int MCU_BYPASS_WPORT;         //0x100 MCU BYPASS MODE, DATA Write Only Port
+	unsigned int reserved2[(0x200-0x104)/4];
+	unsigned int MCU_BYPASS_RPORT;         //0x200 MCU BYPASS MODE, DATA Read Only Port   
+	unsigned int reserved3[(0x400-0x204)/4];
+	unsigned int WIN2_LUT_ADDR;
+	unsigned int reserved4[(0x800-0x404)/4];
+	unsigned int DSP_LUT_ADDR;
+  
+} LCDC_REG, *pLCDC_REG;
+
+
+/* SYS_CONFIG */
+
+#define m_LCDC_DMA_STOP              (1<<0)
+#define m_LCDC_STANDBY               (1<<1)
+#define m_HWC_RELOAD_EN               (1<<2)
+#define m_W0_AXI_OUTSTANDING_DISABLE (1<<3) 
+#define m_W1_AXI_OUTSTANDING_DISABLE (1<<4)
+#define m_W2_AXI_OUTSTANDING_DISABLE (1<<5)
+#define m_DMA_BURST_LENGTH	      (3<<6)
+#define m_WIN0_YRGB_CHANNEL0_ID	      ((0x07)<<8)
+#define m_WIN0_CBR_CHANNEL0_ID	      ((0x07)<<11)
+#define m_WIN0_YRGB_CHANNEL1_ID	      ((0x07)<<14)
+#define m_WIN0_CBR_CHANNEL1_ID	      ((0x07)<<17)
+#define m_WIN1_YRGB_CHANNEL_ID	      ((0x07)<<20)
+#define m_WIN1_CBR_CHANNEL_ID	      ((0x07)<<23)
+#define m_WIN2_CHANNEL_ID	      ((0x07)<<26)
+#define m_HWC_CHANNEL_ID	      ((0x07)<<29)
+
+
+
+
+
+#define v_LCDC_DMA_STOP(x)              (((x)&1)<<0)
+#define v_LCDC_STANDBY(x)              (((x)&1)<<1)
+#define v_HWC_RELOAD_EN(x)             (((x)&1)<<2)
+#define v_W0_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<3)
+#define v_W1_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<4)
+#define v_W2_AXI_OUTSTANDING_DISABLE(x) (((x)&1)<<5)
+#define v_DMA_BURST_LENGTH(x)		(((x)&3)<<6)
+#define v_WIN0_YRGB_CHANNEL0_ID(x)	(((x)&7)<<8)
+#define v_WIN0_CBR_CHANNEL0_ID(x)	(((x)&7)<<11)
+#define v_WIN0_YRGB_CHANNEL1_ID(x)      (((x)&7)<<14)
+#define v_WIN0_CBR_CHANNEL1_ID(x)	(((x)&7)<<17)
+#define v_WIN1_YRGB_CHANNEL_ID(x)	(((x)&7)<<20)
+#define v_WIN1_CBR_CHANNEL_ID(x)	(((x)&7)<<23)
+#define v_WIN2_CHANNEL_ID(x)	        (((x)&7)<<26)
+#define v_HWC_CHANNEL_ID(x)	        (((x)&7)<<29)
+
+
+
+//LCDC_SYS_CTRL1
+#define m_W0_EN          (1<<0)
+#define m_W1_EN          (1<<1)
+#define m_W2_EN         (1<<2)
+#define m_HWC_EN         (1<<3)
+#define m_W0_FORMAT          (7<<4)
+#define m_W1_FORMAT          (7<<7)
+#define m_W2_FORMAT          (7<<10)
+#define m_HWC_COLOR_MODE     (1<<13)
+#define m_HWC_SIZE_SELET     (1<<14)
+#define m_W0_3D_MODE_EN      (1<<15)
+#define m_W0_3D_MODE_SELET    (7<<16)
+#define m_W0_RGB_RB_SWAP      (1<<19)
+#define m_W0_RGB_ALPHA_SWAP   (1<<20)
+#define m_W0_YRGB_M8_SWAP     (1<<21)
+#define m_W0_CBCR_SWAP        (1<<22)
+#define m_W1_RGB_RB_SWAP      (1<<23)
+#define m_W1_RGB_ALPHA_SWAP   (1<<24)
+#define m_W1_YRGB_M8_SWAP     (1<<25)
+#define m_W1_CBCR_SWAP        (1<<26)
+#define m_W2_RGB_RB_SWAP      (1<<27)
+#define m_W2_RGB_ALPHA_SWAP   (1<<28)
+#define m_W2_8pp_PALETTE_ENDIAN_SELECT (1<<29)
+#define m_W2_LUT_RAM_EN       (1<<30)
+#define m_DSP_LUT_RAM_EN      (1<<31)
+
+#define v_W0_EN(x)          (((x)&1)<<0)
+#define v_W1_EN(x)          (((x)&1)<<1)
+#define v_W2_EN(x)          (((x)&1)<<2)
+#define v_HWC_EN(x)         (((x)&1)<<3)
+#define v_W0_FORMAT(x)      (((x)&7)<<4)
+#define v_W1_FORMAT(x)      (((x)&7)<<7)
+#define v_W2_FORMAT(x)      (((x)&7)<<10)
+#define v_HWC_COLOR_MODE(x)     (((x)&1)<<13)
+#define v_HWC_SIZE_SELET(x)     (((x)&1)<<14)
+#define v_W0_3D_MODE_EN(x)     (((x)&1)<<15)
+#define v_W0_3D_MODE_SELET(x)    (((x)&3)<<16)
+#define v_W0_RGB_RB_SWAP(x)      (((x)&1)<<19)
+#define v_W0_RGB_ALPHA_SWAP(x)   (((x)&1)<<20)
+#define v_W0_YRGB_M8_SWAP(x)     (((x)&1)<<21)
+#define v_W0_CBCR_SWAP(x)       (((x)&1)<<22)
+#define v_W1_RGB_RB_SWAP(x)      (((x)&1)<<23)
+#define v_W1_RGB_ALPHA_SWAP(x)   (((x)&1)<<24)
+#define v_W1_YRGB_M8_SWAP(x)     (((x)&1)<<25)
+#define v_W1_CBCR_SWAP(x)       (((x)&1)<<26)
+#define v_W2_RGB_RB_SWAP(x)      (((x)&1)<<27)
+#define v_W2_RGB_ALPHA_SWAP(x)   (((x)&1)<<28)
+#define v_W2_8pp_PALETTE_ENDIAN_SELECT (((x)&1)<<29)
+#define v_W2_LUT_RAM_EN(x)      (((x)&1)<<30)
+#define v_DSP_LUT_RAM_EN(x)      (((x)&1)<<31)
+
+//LCDC_DSP_CTRL_REG0
+#define m_DISPLAY_FORMAT             (0x0f<<0)
+#define m_HSYNC_POLARITY             (1<<4)
+#define m_VSYNC_POLARITY             (1<<5)
+#define m_DEN_POLARITY               (1<<6)
+#define m_DCLK_POLARITY              (1<<7)
+#define m_W0W1_POSITION_SWAP         (1<<8)
+#define m_DITHER_UP_EN               (1<<9)
+#define m_DITHER_DOWN_MODE           (1<<10)
+#define m_DITHER_DOWN_EN             (1<<11)
+#define m_INTERLACE_DSP_EN           (1<<12)
+#define m_INTERLACE_FIELD_POLARITY   (1<<13)
+#define m_W0_INTERLACE_READ_MODE     (1<<14)
+#define m_W1_INTERLACE_READ_MODE     (1<<15)
+#define m_W2_INTERLACE_READ_MODE     (1<<16)
+#define m_W0_YRGB_DEFLICK_MODE       (1<<17)
+#define m_W0_CBR_DEFLICK_MODE        (1<<18)
+#define m_W1_YRGB_DEFLICK_MODE       (1<<19)
+#define m_W1_CBR_DEFLICK_MODE        (1<<20)
+#define m_W0_ALPHA_MODE              (1<<21)
+#define m_W1_ALPHA_MODE              (1<<22)
+#define m_W2_ALPHA_MODE              (1<<23)
+#define m_W0_COLOR_SPACE_CONVERSION  (3<<24)
+#define m_W1_COLOR_SPACE_CONVERSION  (3<<26)
+#define m_W2_COLOR_SPACE_CONVERSION  (1<<28)
+#define m_YCRCB_CLIP_EN              (1<<29)
+#define m_CBR_FILTER_656             (1<<30)
+#define m_LCDC_AXICLK_AUTO_ENABLE 	(1<<31) //eanble for low power
+
+#define v_DISPLAY_FORMAT(x)            (((x)&0xf)<<0)
+#define v_HSYNC_POLARITY(x)             (((x)&1)<<4)
+#define v_VSYNC_POLARITY(x)             (((x)&1)<<5)
+#define v_DEN_POLARITY(x)               (((x)&1)<<6)
+#define v_DCLK_POLARITY(x)              (((x)&1)<<7)
+#define v_W0W1_POSITION_SWAP(x)			(((x)&1)<<8)		
+#define v_DITHER_UP_EN(x)               (((x)&1)<<9)
+#define v_DITHER_DOWN_MODE(x)           (((x)&1)<<10)
+#define v_DITHER_DOWN_EN(x)             (((x)&1)<<11)
+#define v_INTERLACE_DSP_EN(x)             (((x)&1)<<12)
+#define v_INTERLACE_FIELD_POLARITY(x)   (((x)&1)<<13)
+#define v_W0_INTERLACE_READ_MODE(x)     (((x)&1)<<14)
+#define v_W1_INTERLACE_READ_MODE(x)     (((x)&1)<<15)
+#define v_W2_INTERLACE_READ_MODE(x)     (((x)&1)<<16)
+#define v_W0_YRGB_DEFLICK_MODE(x)       (((x)&1)<<17)
+#define v_W0_CBR_DEFLICK_MODE(x)        (((x)&1)<<18)
+#define v_W1_YRGB_DEFLICK_MODE(x)       (((x)&1)<<19)
+#define v_W1_CBR_DEFLICK_MODE(x)        (((x)&1)<<20)
+#define v_W0_ALPHA_MODE(x)             (((x)&1)<<21)
+#define v_W1_ALPHA_MODE(x)              (((x)&1)<<22)
+#define v_W2_ALPHA_MODE(x)             (((x)&1)<<23)
+#define v_W0_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<24)
+#define v_W1_COLOR_SPACE_CONVERSION(x)  (((x)&3)<<26)
+#define v_W2_COLOR_SPACE_CONVERSION(x)  (((x)&1)<<28)
+#define v_YCRCB_CLIP_EN(x)            (((x)&1)<<29)
+#define v_CBR_FILTER_656(x)             (((x)&1)<<30)
+#define v_LCDC_AXICLK_AUTO_ENABLE(x) 	(((x)&1)<<31) //eanble for low power
+
+//LCDC_DSP_CTRL_REG1
+#define m_BG_COLOR                    (0xffffff<<0)
+#define m_BG_B                        (0xff<<0)
+#define m_BG_G                        (0xff<<8)
+#define m_BG_R                        (0xff<<16)
+#define m_BLANK_MODE                  (1<<24)
+#define m_BLACK_MODE                  (1<<25)
+#define m_OUTPUT_BG_SWAP        	  (1<<26)
+#define m_OUTPUT_RB_SWAP        	  (1<<27)
+#define m_OUTPUT_RG_SWAP        	  (1<<28)
+#define m_DELTA_SWAP            	  (1<<29)
+#define m_DUMMY_SWAP            	  (1<<30)
+
+#define v_BG_COLOR(x)                 (((x)&0xffffff)<<0)
+#define v_BG_B(x)                     (((x)&0xff)<<0)
+#define v_BG_G(x)                     (((x)&0xff)<<8)
+#define v_BG_R(x)                     (((x)&0xff)<<16)
+#define v_BLANK_MODE(x)               (((x)&1)<<24)
+#define v_BLACK_MODE(x)               (((x)&1)<<25)
+#define v_OUTPUT_BG_SWAP(x)        	  (((x)&1)<<26)
+#define v_OUTPUT_RB_SWAP(x)        	  (((x)&1)<<27)
+#define v_OUTPUT_RG_SWAP(x)        	  (((x)&1)<<28)
+#define v_DELTA_SWAP(x)            	  (((x)&1)<<29)
+#define v_DUMMY_SWAP(x)            	  (((x)&1)<<30)
+
+
+//LCDC_INT_STATUS
+#define v_HOR_START_INT_STA        (1<<0)  //status
+#define v_FRM_START_INT_STA        (1<<1)
+#define v_LINE_FLAG_INT_STA        (1<<2)
+#define v_BUS_ERR_INT_STA	   (1<<3)
+#define m_HOR_START_INT_EN     	   (1<<4)  //enable
+#define m_FRM_START_INT_EN          (1<<5)
+#define m_LINE_FLAG_INT_EN         (1<<6)
+#define m_BUS_ERR_INT_EN	   (1<<7)
+#define m_HOR_START_INT_CLEAR      (1<<8) //auto clear
+#define m_FRM_START_INT_CLEAR      (1<<9)
+#define m_LINE_FLAG_INT_CLEAR      (1<<10)
+#define m_BUS_ERR_INT_CLEAR        (1<<11)
+#define m_LINE_FLAG_NUM		   (0xfff<<12)
+#define v_HOR_START_INT_EN(x)      (((x)&1)<<4)
+#define v_FRM_START_INT_EN(x)      (((x)&1)<<5)
+#define v_LINE_FLAG_INT_EN(x)      (((x)&1)<<6)
+#define v_BUS_ERR_INT_EN(x)	   (((x)&1)<<7)
+#define v_HOR_START_INT_CLEAR(x)      (((x)&1)<<8)
+#define v_FRM_START_INT_CLEAR(x)     (((x)&1)<<9)
+#define v_LINE_FLAG_INT_CLEAR(x)     (((x)&1)<<10)
+#define v_BUS_ERR_INT_CLEAR(x)        (((x)&1)<<11)
+#define v_LINE_FLAG_NUM(x)	   (((x)&0xfff)<<12)
+
+
+
+//LCDC_MCU_TIMING_CTRL
+#define m_MCU_WRITE_PERIOD      (0x3f<<0)
+#define m_MCU_CS_ST             (0xf<<6)
+#define m_MCU_CS_END            (0x3f<<10)
+#define m_MCU_RW_ST             (0xf<<16)
+#define m_MCU_RW_END            (0x3f<<20)
+#define m_MCU_BPS_CLK_SEL		(1<<26)
+#define m_MCU_HOLDMODE_SELECT     (1<<27)
+#define m_MCU_HOLDMODE_FRAME_ST   (1<<28)
+#define m_MCU_RS_SELECT            (1<<29)
+#define m_MCU_BYPASSMODE_SELECT   (1<<30)
+#define m_MCU_OUTPUT_SELECT        (1<<31)
+#define v_MCU_WRITE_PERIOD(x)      (((x)&0x3f)<<0)
+#define v_MCU_CS_ST(x)          (((x)&0xf)<<6)
+#define v_MCU_CS_END(x)         (((x)&0x3f)<<10)
+#define v_MCU_RW_ST(x)          (((x)&0xf)<<16)
+#define v_MCU_RW_END(x)         (((x)&0x3f)<<20)
+#define v_MCU_BPS_CLK_SEL	(((x)&1)<<26)
+#define v_MCU_HOLDMODE_SELECT(x)     (((x)&1)<<27)
+#define v_MCU_HOLDMODE_FRAME_ST(x)   (((x)&1)<<28)
+#define v_MCU_RS_SELECT(x)            (((x)&1)<<29)
+#define v_MCU_BYPASSMODE_SELECT(x)   (((x)&1)<<30)
+#define v_MCU_OUTPUT_SELECT(x)        (((x)&1)<<31)
+
+//LCDC_ BLEND_CTRL
+#define m_HWC_BLEND_EN         (1<<0)
+#define m_W2_BLEND_EN          (1<<1)
+#define m_W1_BLEND_EN          (1<<2)
+#define m_W0_BLEND_EN          (1<<3)
+#define m_HWC_BLEND_FACTOR     (15<<4)
+#define m_W2_BLEND_FACTOR     (0xff<<8)
+#define m_W1_BLEND_FACTOR     (0xff<<16)
+#define m_W0_BLEND_FACTOR     (0xff<<24)
+
+#define v_HWC_BLEND_EN(x)         (((x)&1)<<0)
+#define v_W2_BLEND_EN(x)          (((x)&1)<<1)
+#define v_W1_BLEND_EN(x)          (((x)&1)<<2)
+#define v_W0_BLEND_EN(x)          (((x)&1)<<3)
+#define v_HWC_BLEND_FACTOR(x)    (((x)&15)<<4)
+#define v_W2_BLEND_FACTOR(x)     (((x)&0xff)<<8)
+#define v_W1_BLEND_FACTOR(x)     (((x)&0xff)<<16)
+#define v_W0_BLEND_FACTOR(x)     (((x)&0xff)<<24)
+
+
+//LCDC_WIN0_COLOR_KEY_CTRL / LCDC_WIN1_COLOR_KEY_CTRL
+#define m_KEYCOLOR          (0xffffff<<0)
+#define m_KEYCOLOR_B          (0xff<<0)
+#define m_KEYCOLOR_G          (0xff<<8)
+#define m_KEYCOLOR_R          (0xff<<16)
+#define m_COLORKEY_EN         (1<<24)
+#define v_KEYCOLOR(x)          (((x)&0xffffff)<<0)
+#define v_KEYCOLOR_B(x)          (((x)&0xff)<<0)
+#define v_KEYCOLOR_G(x)         (((x)&0xff)<<8)
+#define v_KEYCOLOR_R(x)          (((x)&0xff)<<16)
+#define v_COLORKEY_EN(x)         (((x)&1)<<24)
+
+//LCDC_DEFLICKER_SCL_OFFSET
+#define m_W0_YRGB_VSD_OFFSET      (0xff<<0)
+#define m_W0_YRGB_VSP_OFFSET      (0xff<<8)
+#define m_W1_VSD_OFFSET           (0xff<<16)
+#define m_W1_VSP_OFFSET           (0xff<<24)
+#define v_W0_YRGB_VSD_OFFSET(x)      (((x)&0xff)<<0)
+#define v_W0_YRGB_VSP_OFFSET(x)      (((x)&0xff)<<8)
+#define v_W1_VSD_OFFSET(x)           (((x)&0xff)<<16)
+#define v_W1_VSP_OFFSET(x)           (((x)&0xff)<<24)
+
+
+
+
+
+//AXI MS ID
+#define m_W0_YRGB_CH_ID        (0xF<<0)
+#define m_W0_CBR_CH_ID         (0xF<<4)
+#define m_W1_YRGB_CH_ID        (0xF<<8)
+#define m_W2_CH_ID             (0xF<<12)
+#define m_HWC_CH_ID            (0xF<<16)
+#define v_W0_YRGB_CH_ID(x)        (((x)&0xF)<<0)
+#define v_W0_CBR_CH_ID(x)         (((x)&0xF)<<4)
+#define v_W1_YRGB_CH_ID(x)        (((x)&0xF)<<8)
+#define v_W2_CH_ID(x)             (((x)&0xF)<<12)
+#define v_HWC_CH_ID(x)            (((x)&0xF)<<16)
+
+
+/* Low Bits Mask */
+#define m_WORDLO            (0xffff<<0)
+#define m_WORDHI            (0xffff<<16)
+#define v_WORDLO(x)         (((x)&0xffff)<<0)
+#define v_WORDHI(x)         (((x)&0xffff)<<16)
+
+
+//LCDC_WINx_SCL_FACTOR_Y/CBCR
+#define v_X_SCL_FACTOR(x)  ((x)<<0)
+#define v_Y_SCL_FACTOR(x)  ((x)<<16)
+
+//LCDC_DSP_HTOTAL_HS_END
+#define v_HSYNC(x)  ((x)<<0)   //hsync pulse width
+#define v_HORPRD(x) ((x)<<16)   //horizontal period
+
+
+//LCDC_DSP_HACT_ST_END
+#define v_HAEP(x) ((x)<<0)  //horizontal active end point
+#define v_HASP(x) ((x)<<16) //horizontal active start point
+
+//LCDC_DSP_VTOTAL_VS_END
+#define v_VSYNC(x) ((x)<<0)
+#define v_VERPRD(x) ((x)<<16)
+
+//LCDC_DSP_VACT_ST_END
+#define v_VAEP(x) ((x)<<0)
+#define v_VASP(x) ((x)<<16)
+
+
+//LCDC_WINx_VIR ,x is number of words of win0 virtual width
+#define v_ARGB888_VIRWIDTH(x) (x)
+#define v_RGB888_VIRWIDTH(x) (((x*3)>>2)+((x)%3))
+#define v_RGB565_VIRWIDTH(x) (((x)>>1) + ((x%2)?1:0))
+#define v_YUV_VIRWIDTH(x)    (((x)>>2) +((x%4)?1:0))
+
+#define m_ACTWIDTH       (0xffff<<0)
+#define m_ACTHEIGHT      (0xffff<<16)
+#define v_ACTWIDTH(x)       (((x)&0xffff)<<0)
+#define v_ACTHEIGHT(x)      (((x)&0xffff)<<16)
+
+#define m_VIRST_X      (0xffff<<0)
+#define m_VIRST_Y      (0xffff<<16)
+#define v_VIRST_X(x)      (((x)&0xffff)<<0)
+#define v_VIRST_Y(x)      (((x)&0xffff)<<16)
+
+#define m_PANELST_X      (0x3ff<<0)
+#define m_PANELST_Y      (0x3ff<<16)
+#define v_PANELST_X(x)      (((x)&0x3ff)<<0)
+#define v_PANELST_Y(x)      (((x)&0x3ff)<<16)
+
+#define m_PANELWIDTH       (0x3ff<<0)
+#define m_PANELHEIGHT      (0x3ff<<16)
+#define v_PANELWIDTH(x)       (((x)&0x3ff)<<0)
+#define v_PANELHEIGHT(x)      (((x)&0x3ff)<<16)
+
+#define m_HWC_B                 (0xff<<0)
+#define m_HWC_G                 (0xff<<8)
+#define m_HWC_R                 (0xff<<16)
+#define m_W0_YRGB_HSP_OFFSET    (0xff<<24)
+#define m_W0_YRGB_HSD_OFFSET    (0xff<<24)
+#define v_HWC_B(x)                 (((x)&0xff)<<0)
+#define v_HWC_G(x)                 (((x)&0xff)<<8)
+#define v_HWC_R(x)                 (((x)&0xff)<<16)
+#define v_W0_YRGB_HSP_OFFSET(x)    (((x)&0xff)<<24)
+#define v_W0_YRGB_HSD_OFFSET(x)    (((x)&0xff)<<24)
+
+//LCDC_WIN0_ACT_INFO
+#define v_ACT_WIDTH(x)     ((x-1)<<0)
+#define v_ACT_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_INFO
+#define v_DSP_WIDTH(x)     ((x-1)<<0)
+#define v_DSP_HEIGHT(x)    ((x-1)<<16)
+
+//LCDC_WIN0_DSP_ST    //x,y start point of the panel scanning
+#define v_DSP_STX(x)      (x<<0)
+#define v_DSP_STY(x)      (x<<16)
+
+//Panel display scanning
+#define m_PANEL_HSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_HORIZONTAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_HSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_HORIZONTAL_PERIOD(x)       (((x)&0x3ff)<<16)
+
+#define m_PANEL_END              (0x3ff<<0)
+#define m_PANEL_START            (0x3ff<<16)
+#define v_PANEL_END(x)              (((x)&0x3ff)<<0)
+#define v_PANEL_START(x)            (((x)&0x3ff)<<16)
+
+#define m_PANEL_VSYNC_WIDTH             (0x3ff<<0)
+#define m_PANEL_VERTICAL_PERIOD       (0x3ff<<16)
+#define v_PANEL_VSYNC_WIDTH(x)             (((x)&0x3ff)<<0)
+#define v_PANEL_VERTICAL_PERIOD(x)       (((x)&0x3ff)<<16)
+//-----------
+
+#define m_HSCALE_FACTOR        (0xffff<<0)
+#define m_VSCALE_FACTOR        (0xffff<<16)
+#define v_HSCALE_FACTOR(x)        (((x)&0xffff)<<0)
+#define v_VSCALE_FACTOR(x)        (((x)&0xffff)<<16)
+
+#define m_W0_CBR_HSD_OFFSET   (0xff<<0)
+#define m_W0_CBR_HSP_OFFSET   (0xff<<8)
+#define m_W0_CBR_VSD_OFFSET   (0xff<<16)
+#define m_W0_CBR_VSP_OFFSET   (0xff<<24)
+#define v_W0_CBR_HSD_OFFSET(x)   (((x)&0xff)<<0)
+#define v_W0_CBR_HSP_OFFSET(x)   (((x)&0xff)<<8)
+#define v_W0_CBR_VSD_OFFSET(x)   (((x)&0xff)<<16)
+#define v_W0_CBR_VSP_OFFSET(x)   (((x)&0xff)<<24)
+
+
+
+#define CalScale(x, y)	             (((u32)x*0x1000)/y)
+struct rk30_lcdc_device{
+	int id;
+	struct rk_lcdc_device_driver driver;
+	rk_screen *screen;
+	
+	LCDC_REG *preg;         // LCDC reg base address and backup reg 
+    	LCDC_REG regbak;
+	int __iomem *dsp_lut_addr_base;
+
+	void __iomem *reg_vir_base;  	// virtual basic address of lcdc register
+	u32 reg_phy_base;       	// physical basic address of lcdc register
+	u32 len;               		// physical map length of lcdc register
+	spinlock_t  reg_lock;		//one time only one process allowed to config the register
+	bool clk_on;			//if aclk or hclk is closed ,acess to register is not allowed
+	u8 atv_layer_cnt;		//active layer counter,when  atv_layer_cnt = 0,disable lcdc
+
+	unsigned int		irq;
+
+	struct clk		*pd;				//lcdc power domain
+	struct clk		*hclk;				//lcdc AHP clk
+	struct clk		*dclk;				//lcdc dclk
+	struct clk		*aclk;				//lcdc share memory frequency
+	struct clk		*aclk_parent;		//lcdc aclk divider frequency source
+	struct clk		*aclk_ddr_lcdc; 	//DDR LCDC AXI clock disable.
+	struct clk		*aclk_disp_matrix;	//DISPLAY matrix AXI clock disable.
+	struct clk		*hclk_cpu_display;	//CPU DISPLAY AHB bus clock disable.
+	struct clk		*pd_display;		// display power domain
+	u32	pixclock;
+};
+
+struct lcdc_info{
+/*LCD CLK*/
+	struct rk30_lcdc_device lcdc0;
+	struct rk30_lcdc_device lcdc1;
+
+};
+
+
+struct win_set {
+	volatile u32 y_offset;
+	volatile u32 c_offset;
+};
+
+struct win0_par {
+    u32 refcount;
+    u32	pseudo_pal[16];
+    u32 y_offset;
+    u32 c_offset;
+    u32 xpos;         //size in panel
+    u32 ypos;
+    u32 xsize;        //start point in panel
+    u32 ysize;
+    enum data_format format;
+
+    wait_queue_head_t wait;
+    struct win_set mirror;
+    struct win_set displ;
+    struct win_set done;
+
+    u8 par_seted;
+    u8 addr_seted;
+};
+
+#endif
+
+
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
index d526cdb..73bf027 100644
--- a/drivers/video/rockchip/rk_fb.c
+++ b/drivers/video/rockchip/rk_fb.c
@@ -31,8 +31,9 @@
 #include<linux/rk_fb.h>
 #include <plat/ipp.h>
 #include "hdmi/rk_hdmi.h"
+#include <linux/linux_logo.h>
 
-
+void rk29_backlight_set(bool on);
 
 #ifdef	FB_WIMO_FLAG
 
@@ -103,7 +104,7 @@ static int rk_fb_open(struct fb_info *info,int user)
     struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
     int layer_id;
   
-    layer_id = get_fb_layer_id(&info->fix);
+    layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
     if(dev_drv->layer_par[layer_id]->state)
     {
     	return 0;    // if this layer aready opened ,no need to reopen
@@ -178,7 +179,7 @@ static int rk_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 	u32 xvir = var->xres_virtual;
 	u8 data_format = var->nonstd&0xff;
 	
-	layer_id = get_fb_layer_id(fix);
+	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
 	if(layer_id < 0)
 	{
 		return  -ENODEV;
@@ -215,13 +216,13 @@ static int rk_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
             		return -EINVAL;
     	}
 
-	#if defined(CONFIG_HDMI_RK30)
-		#if defined(CONFIG_DUAL_DISP_IN_KERNEL)
+	#if defined(CONFIG_RK_HDMI)
+		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
 			if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED)
 			{
 				if(inf->num_fb >= 2)
 				{
-					info2 = inf->fb[2];
+					info2 = inf->fb[inf->num_fb>>1];
 					dev_drv1 = (struct rk_lcdc_device_driver * )info2->par;
 					par2 = dev_drv1->layer_par[layer_id];
 					par2->y_offset = par->y_offset;
@@ -248,7 +249,7 @@ static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,unsigned long arg)
 	struct fb_fix_screeninfo *fix = &info->fix;
 	struct rk_lcdc_device_driver *dev_drv = (struct rk_lcdc_device_driver * )info->par;
 	u32 yuv_phy[2];
-	int layer_id = get_fb_layer_id(&info->fix);
+	int  layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
 	int enable; // enable fb:1 enable;0 disable 
 	int ovl;	//overlay:0 win1 on the top of win0;1,win0 on the top of win1
 	int num_buf; //buffer_number
@@ -317,7 +318,7 @@ static int rk_fb_blank(int blank_mode, struct fb_info *info)
 	struct fb_fix_screeninfo *fix = &info->fix;
 	int layer_id;
 	
-	layer_id = get_fb_layer_id(fix);
+	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
 	if(layer_id < 0)
 	{
 		return  -ENODEV;
@@ -343,7 +344,7 @@ static int rk_fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	 }
  
 	 if( ((var->xoffset+var->xres) > info->var.xres_virtual) ||
-	     ((var->yoffset+var->yres) > (info->var.yres_virtual*2)) )
+	     ((var->yoffset+var->yres) > (info->var.yres_virtual)) )
 	 {
 		 printk("%s check_var fail 2!!! \n",info->fix.id);
 		 printk("xoffset:%d>>xres:%d>>xres_vir:%d\n",var->xoffset,var->xres,info->var.xres_virtual);
@@ -362,7 +363,7 @@ static int rk_fb_set_par(struct fb_info *info)
     	struct fb_fix_screeninfo *fix = &info->fix;
     	struct rk_lcdc_device_driver * dev_drv = (struct rk_lcdc_device_driver * )info->par;
     	struct layer_par *par = NULL;
-   	rk_screen *screen =dev_drv->screen;
+   	rk_screen *screen =dev_drv->cur_screen;
 	struct fb_info * info2 = NULL;
 	struct rk_lcdc_device_driver * dev_drv1  = NULL;
 	struct layer_par *par2 = NULL;
@@ -377,19 +378,20 @@ static int rk_fb_set_par(struct fb_info *info)
 	u32 yvir = var->yres_virtual;
 	u8 data_format = var->nonstd&0xff;
 	var->pixclock = dev_drv->pixclock;
-	#if defined(CONFIG_HDMI_RK30)
-		#if defined(CONFIG_DUAL_DISP_IN_KERNEL)
+ 	
+	#if defined(CONFIG_RK_HDMI)
+		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
 			if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED)
 			{
 				if(inf->num_fb >= 2)
 				{
-					info2 = inf->fb[2];
+					info2 = inf->fb[inf->num_fb>>1];
 					dev_drv1 = (struct rk_lcdc_device_driver * )info2->par;
 				}
 			}
 		#endif 
 	#endif
-	layer_id = get_fb_layer_id(fix);
+	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
 	if(layer_id < 0)
 	{
 		return  -ENODEV;
@@ -413,7 +415,23 @@ static int rk_fb_set_par(struct fb_info *info)
 		xsize = screen->x_res;
               	ysize = screen->y_res;
 	}
-		
+
+#if defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
+	if(screen->screen_id == 0) //this is for device like rk2928 ,whic have one lcdc but two display outputs
+	{			   //save parameter set by android
+		dev_drv->screen0->xsize = xsize;
+		dev_drv->screen0->ysize = ysize;
+		dev_drv->screen0->xpos  = xpos;
+		dev_drv->screen0->ypos = ypos;
+	}
+	else
+	{
+		dev_drv->screen1->xsize = xsize;
+		dev_drv->screen1->ysize = ysize;
+		dev_drv->screen1->xpos  = xpos;
+		dev_drv->screen1->ypos = ypos;
+	}
+#endif
 	/* calculate y_offset,c_offset,line_length,cblen and crlen  */
 #if 1
 	switch (data_format)
@@ -488,8 +506,8 @@ static int rk_fb_set_par(struct fb_info *info)
 	par->xvir =  var->xres_virtual;		// virtual resolution	 stride --->LCDC_WINx_VIR
 	par->yvir =  var->yres_virtual;
 
-	#if defined(CONFIG_HDMI_RK30)
-		#if defined(CONFIG_DUAL_DISP_IN_KERNEL)
+	#if defined(CONFIG_RK_HDMI)
+		#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
 			if(hdmi_get_hotplug() == HDMI_HPD_ACTIVED)
 			{
 				if(info != info2)
@@ -560,15 +578,19 @@ static struct fb_ops fb_ops = {
 
 
 static struct fb_var_screeninfo def_var = {
-    .red    = {11,5,0},//default set to rgb565,the boot logo is rgb565
-    .green  = {5,6,0},
-    .blue   = {0,5,0},
-    .transp = {0,0,0},	
-    .nonstd      = HAL_PIXEL_FORMAT_RGB_565,   //(ypos<<20+xpos<<8+format) format
-    .grayscale   = 0,  //(ysize<<20+xsize<<8)
-    .activate    = FB_ACTIVATE_NOW,
-    .accel_flags = 0,
-    .vmode       = FB_VMODE_NONINTERLACED,
+	.red    = {11,5,0},//default set to rgb565,the boot logo is rgb565
+	.green  = {5,6,0},
+	.blue   = {0,5,0},
+	.transp = {0,0,0},	
+#ifdef  CONFIG_LOGO_LINUX_BMP
+	.nonstd      = HAL_PIXEL_FORMAT_RGBA_8888,
+#else
+	.nonstd      = HAL_PIXEL_FORMAT_RGB_565,   //(ypos<<20+xpos<<8+format) format
+#endif
+	.grayscale   = 0,  //(ysize<<20+xsize<<8)
+	.activate    = FB_ACTIVATE_NOW,
+	.accel_flags = 0,
+	.vmode       = FB_VMODE_NONINTERLACED,
 };
 
 static struct fb_fix_screeninfo def_fix = {
@@ -642,11 +664,55 @@ int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
 	}
 	else if((lcdc_id == 1)&&(inf->num_lcdc == 2))
 	{
-		info = inf->fb[2];
+		info = inf->fb[dev_drv->num_layer]; //the main fb of lcdc2
+	}
+
+	if(dev_drv->screen1) //device like rk2928 ,have only one lcdc but two outputs
+	{
+		if(enable)
+		{
+			memcpy(dev_drv->screen1,screen,sizeof(rk_screen ));
+			dev_drv->screen1->lcdc_id = 0; //connect screen1 to output interface 0
+			dev_drv->screen1->screen_id = 1;
+			dev_drv->screen0->lcdc_id = 1; //connect screen0 to output interface 1
+			dev_drv->cur_screen = dev_drv->screen1;
+			if(dev_drv->screen0->sscreen_get)
+			{
+				dev_drv->screen0->sscreen_get(dev_drv->screen0,
+					dev_drv->cur_screen->hdmi_resolution);
+			}
+			if(dev_drv->screen0->sscreen_set)
+			{
+				dev_drv->screen0->sscreen_set(dev_drv->screen0,enable);
+			}
+		}
+		else
+		{
+			dev_drv->screen1->lcdc_id = 1; //connect screen1 to output interface 1
+			dev_drv->screen0->lcdc_id = 0; //connect screen0 to output interface 0
+			dev_drv->cur_screen = dev_drv->screen0;		
+			dev_drv->screen_ctr_info->set_screen_info(dev_drv->cur_screen,
+			dev_drv->screen_ctr_info->lcd_info);
+
+			if(dev_drv->screen0->sscreen_set)
+			{
+				dev_drv->screen0->sscreen_set(dev_drv->screen0,enable);
+			}
+			
+		}
+	}
+	else
+	{
+if(enable)
+		{
+			memcpy(dev_drv->cur_screen,screen,sizeof(rk_screen ));
+		}
 	}
 
-	layer_id = get_fb_layer_id(&info->fix);
-	if(!enable)
+	
+	layer_id = dev_drv->fb_get_layer(dev_drv,info->fix.id);
+	
+	if(!enable && !dev_drv->screen1) //only double lcdc device need to close
 	{
 		if(dev_drv->layer_par[layer_id]->state) 
 		{
@@ -657,7 +723,7 @@ int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
 	
 	hdmi_var = &info->var;
 	hdmi_fix = &info->fix;
-	#if defined(CONFIG_DUAL_DISP_IN_KERNEL)
+	#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
 		if(likely(inf->num_lcdc == 2))
 		{
 			pmy_var = &inf->fb[0]->var;
@@ -675,11 +741,20 @@ int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
 		}
 	#endif
 	hdmi_var->grayscale &= 0xff;
-	hdmi_var->grayscale |= (dev_drv->screen->x_res<<8) + (dev_drv->screen->y_res<<20);
+	hdmi_var->grayscale |= (dev_drv->cur_screen->x_res<<8) + (dev_drv->cur_screen->y_res<<20);
+
+	if(dev_drv->screen1)  //device like rk2928,whic have one lcdc but two outputs
+	{
+	
+		info->var.nonstd &= 0xff;
+		info->var.nonstd |= (dev_drv->cur_screen->xpos<<8) + (dev_drv->cur_screen->ypos<<20);
+		info->var.grayscale &= 0xff;
+		info->var.grayscale |= (dev_drv->cur_screen->x_res<<8) + (dev_drv->cur_screen->y_res<<20);
+	}
 	ret = info->fbops->fb_open(info,1);
 	ret = dev_drv->load_screen(dev_drv,1);
 	ret = info->fbops->fb_set_par(info);
-	#if defined(CONFIG_DUAL_DISP_IN_KERNEL)
+	#if defined(CONFIG_DUAL_LCDC_DUAL_DISP_IN_KERNEL)
 		if(likely(inf->num_lcdc == 2))
 		{
 			pmy_info = inf->fb[0];
@@ -691,6 +766,9 @@ int rk_fb_switch_screen(rk_screen *screen ,int enable ,int lcdc_id)
 		}
 	#endif 
 
+#if defined(CONFIG_NO_DUAL_DISP)  //close backlight for device whic do not support dual display
+	rk29_backlight_set(!enable);
+#endif
 	return 0;
 
 }
@@ -730,12 +808,12 @@ int rk_fb_disp_scale(u8 scale_x, u8 scale_y,u8 lcdc_id)
 	}
 	else if( (inf->num_lcdc == 2)&&(lcdc_id == 1))
 	{
-		info = inf->fb[2];
+		info = inf->fb[dev_drv->num_layer];
 	}
 
 	var = &info->var;
-	screen_x = dev_drv->screen->x_res;
-	screen_y = dev_drv->screen->y_res;
+	screen_x = dev_drv->cur_screen->x_res;
+	screen_y = dev_drv->cur_screen->y_res;
 	xpos = (screen_x-screen_x*scale_x/100)>>1;
 	ypos = (screen_y-screen_y*scale_y/100)>>1;
 	xsize = screen_x*scale_x/100;
@@ -757,57 +835,43 @@ static int rk_request_fb_buffer(struct fb_info *fbi,int fb_id)
 	struct resource *mem;
 	int ret = 0;
 	struct rk_fb_inf *fb_inf = platform_get_drvdata(g_fb_pdev);
-	switch(fb_id)
+	if (!strcmp(fbi->fix.id,"fb0"))
 	{
-        	case 0:
-            		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb0 buf");
-            		if (res == NULL)
-            		{
-                		dev_err(&g_fb_pdev->dev, "failed to get win0 memory \n");
-                		ret = -ENOENT;
-            		}
-		 	fbi->fix.smem_start = res->start;
-	            	fbi->fix.smem_len = res->end - res->start + 1;
-		    	mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
-	            	fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
-	            	memset(fbi->screen_base, 0, fbi->fix.smem_len);
-		    	printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
-				fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);
-        	#ifdef CONFIG_FB_WORK_IPP // alloc ipp buf for rotate
-	            	res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "ipp buf");
-	            	if (res == NULL)
-	            	{
-	                	dev_err(&g_fb_pdev->dev, "failed to get win1 ipp memory \n");
-	               		ret = -ENOENT;
-	            	}
-	            	fbi->fix.mmio_start = res->start;
-	            	fbi->fix.mmio_len = res->end - res->start + 1;
-	 	#endif
-		    	break;
-        	case 2:
-			#if !defined(CONFIG_THREE_FB_BUFFER)
-            		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb2 buf");
-			if (res == NULL)
-			{
+		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb0 buf");
+		if (res == NULL)
+		{
+			dev_err(&g_fb_pdev->dev, "failed to get memory for fb0 \n");
+			ret = -ENOENT;
+		}
+		fbi->fix.smem_start = res->start;
+		fbi->fix.smem_len = res->end - res->start + 1;
+		mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
+		fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
+		memset(fbi->screen_base, 0, fbi->fix.smem_len);
+		printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
+		fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);
+	}
+	else
+	{	
+#if !defined(CONFIG_THREE_FB_BUFFER)
+		res = platform_get_resource_byname(g_fb_pdev, IORESOURCE_MEM, "fb2 buf");
+		if (res == NULL)
+		{
 			dev_err(&g_fb_pdev->dev, "failed to get win0 memory \n");
 			ret = -ENOENT;
-			}
-			fbi->fix.smem_start = res->start;
-			fbi->fix.smem_len = res->end - res->start + 1;
-			mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
-			fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
-			memset(fbi->screen_base, 0, fbi->fix.smem_len);
-			#else    //three buffer no need to copy
-			fbi->fix.smem_start = fb_inf->fb[0]->fix.smem_start;
-			fbi->fix.smem_len   = fb_inf->fb[0]->fix.smem_len;
-			fbi->screen_base    = fb_inf->fb[0]->screen_base;
-			#endif
-			printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
-				fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);
-			break;
-        	default:
-            		ret = -EINVAL;
-            		break;		
+		}
+		fbi->fix.smem_start = res->start;
+		fbi->fix.smem_len = res->end - res->start + 1;
+		mem = request_mem_region(res->start, resource_size(res), g_fb_pdev->name);
+		fbi->screen_base = ioremap(res->start, fbi->fix.smem_len);
+		memset(fbi->screen_base, 0, fbi->fix.smem_len);
+#else    //three buffer no need to copy
+		fbi->fix.smem_start = fb_inf->fb[0]->fix.smem_start;
+		fbi->fix.smem_len   = fb_inf->fb[0]->fix.smem_len;
+		fbi->screen_base    = fb_inf->fb[0]->screen_base;
+#endif
+		printk("fb%d:phy:%lx>>vir:%p>>len:0x%x\n",fb_id,
+			fbi->fix.smem_start,fbi->screen_base,fbi->fix.smem_len);	
 	}
     return ret;
 }
@@ -884,14 +948,54 @@ static int init_lcdc_device_driver(struct rk_lcdc_device_driver *dev_drv,
 	dev_drv->get_disp_info  = def_drv->get_disp_info;
 	dev_drv->ovl_mgr	= def_drv->ovl_mgr;
 	dev_drv->fps_mgr	= def_drv->fps_mgr;
+	if(def_drv->fb_get_layer)
+		dev_drv->fb_get_layer   = def_drv->fb_get_layer;
+	if(def_drv->fb_layer_remap)
+		dev_drv->fb_layer_remap = def_drv->fb_layer_remap;
+	if(def_drv->set_dsp_lut)
+		dev_drv->set_dsp_lut    = def_drv->set_dsp_lut;
+	if(def_drv->read_dsp_lut)
+		dev_drv->read_dsp_lut   = def_drv->read_dsp_lut;
 	init_layer_par(dev_drv);
 	init_completion(&dev_drv->frame_done);
 	spin_lock_init(&dev_drv->cpl_lock);
+	mutex_init(&dev_drv->fb_win_id_mutex);
+	dev_drv->fb_layer_remap(dev_drv,FB_DEFAULT_ORDER); //102
 	dev_drv->first_frame = 1;
 	
 	return 0;
 }
 
+#ifdef CONFIG_LOGO_LINUX_BMP
+static struct linux_logo *bmp_logo;
+static int fb_prepare_bmp_logo(struct fb_info *info, int rotate)
+{
+	bmp_logo = fb_find_logo(24);
+	if (bmp_logo == NULL) {
+		printk("%s error\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static void fb_show_bmp_logo(struct fb_info *info, int rotate)
+{
+	unsigned char *src=bmp_logo->data;
+	unsigned char *dst=info->screen_base;
+	int i;
+
+	if(bmp_logo->width>info->var.xres)
+		bmp_logo->width=info->var.xres;
+
+	if(bmp_logo->height>info->var.yres)
+		bmp_logo->height=info->var.yres;
+
+	for(i=0;i<bmp_logo->height;i++)
+		memcpy(dst+info->var.xres*i*4, src+bmp_logo->width*i*4, bmp_logo->width*4);
+	
+}
+#endif
+
 int rk_fb_register(struct rk_lcdc_device_driver *dev_drv,
 	struct rk_lcdc_device_driver *def_drv,int id)
 {
@@ -923,9 +1027,9 @@ int rk_fb_register(struct rk_lcdc_device_driver *dev_drv,
 	init_lcdc_device_driver(dev_drv, def_drv,id);
 	if(dev_drv->screen_ctr_info->set_screen_info)
 	{
-		dev_drv->screen_ctr_info->set_screen_info(dev_drv->screen,
+		dev_drv->screen_ctr_info->set_screen_info(dev_drv->cur_screen,
 			dev_drv->screen_ctr_info->lcd_info);
-		if(SCREEN_NULL==dev_drv->screen->type)
+		if(SCREEN_NULL==dev_drv->cur_screen->type)
 		{
 			printk(KERN_WARNING "no display device on lcdc%d!?\n",dev_drv->id);
 			fb_inf->num_lcdc--;
@@ -945,61 +1049,80 @@ int rk_fb_register(struct rk_lcdc_device_driver *dev_drv,
 	dev_drv->load_screen(dev_drv,1);
 	/************fb set,one layer one fb ***********/
 	dev_drv->fb_index_base = fb_inf->num_fb;
-    for(i=0;i<dev_drv->num_layer;i++)
-    {
-        fbi= framebuffer_alloc(0, &g_fb_pdev->dev);
-        if(!fbi)
-        {
-            dev_err(&g_fb_pdev->dev,">> fb framebuffer_alloc fail!");
-            fbi = NULL;
-            ret = -ENOMEM;
-        }
-	fbi->par = dev_drv;
-        fbi->var = def_var;
-        fbi->fix = def_fix;
-        sprintf(fbi->fix.id,"fb%d",fb_inf->num_fb);
-        fbi->var.xres = fb_inf->lcdc_dev_drv[lcdc_id]->screen->x_res;
-        fbi->var.yres = fb_inf->lcdc_dev_drv[lcdc_id]->screen->y_res;
-	fbi->var.grayscale |= (fbi->var.xres<<8) + (fbi->var.yres<<20);
-        fbi->var.bits_per_pixel = 16;
-        fbi->var.xres_virtual = fb_inf->lcdc_dev_drv[lcdc_id]->screen->x_res;
-        fbi->var.yres_virtual = fb_inf->lcdc_dev_drv[lcdc_id]->screen->y_res;
-        fbi->var.width = fb_inf->lcdc_dev_drv[lcdc_id]->screen->width;
-        fbi->var.height = fb_inf->lcdc_dev_drv[lcdc_id]->screen->height;
-        fbi->var.pixclock = fb_inf->lcdc_dev_drv[lcdc_id]->pixclock;
-        fbi->var.left_margin = fb_inf->lcdc_dev_drv[lcdc_id]->screen->left_margin;
-        fbi->var.right_margin = fb_inf->lcdc_dev_drv[lcdc_id]->screen->right_margin;
-        fbi->var.upper_margin = fb_inf->lcdc_dev_drv[lcdc_id]->screen->upper_margin;
-        fbi->var.lower_margin = fb_inf->lcdc_dev_drv[lcdc_id]->screen->lower_margin;
-        fbi->var.vsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->screen->vsync_len;
-        fbi->var.hsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->screen->hsync_len;
-        fbi->fbops			 = &fb_ops;
-        fbi->flags			 = FBINFO_FLAG_DEFAULT;
-        fbi->pseudo_palette  = fb_inf->lcdc_dev_drv[lcdc_id]->layer_par[i]->pseudo_pal;
-        rk_request_fb_buffer(fbi,fb_inf->num_fb);
-        ret = register_framebuffer(fbi);
-        if(ret<0)
-        {
-            printk("%s>>fb%d register_framebuffer fail!\n",__func__,fb_inf->num_fb);
-            ret = -EINVAL;
-        }
-	rkfb_create_sysfs(fbi);
-        fb_inf->fb[fb_inf->num_fb] = fbi;
-        printk("%s>>>>>%s\n",__func__,fb_inf->fb[fb_inf->num_fb]->fix.id);
-        fb_inf->num_fb++;	
+	for(i=0;i<dev_drv->num_layer;i++)
+	{
+		fbi= framebuffer_alloc(0, &g_fb_pdev->dev);
+		if(!fbi)
+		{
+		    dev_err(&g_fb_pdev->dev,">> fb framebuffer_alloc fail!");
+		    fbi = NULL;
+		    ret = -ENOMEM;
+		}
+		fbi->par = dev_drv;
+		fbi->var = def_var;
+		fbi->fix = def_fix;
+		sprintf(fbi->fix.id,"fb%d",fb_inf->num_fb);
+		fbi->var.xres = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->x_res;
+		fbi->var.yres = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->y_res;
+		fbi->var.grayscale |= (fbi->var.xres<<8) + (fbi->var.yres<<20);
+#ifdef  CONFIG_LOGO_LINUX_BMP
+		fbi->var.bits_per_pixel = 32; 
+#else
+		fbi->var.bits_per_pixel = 16; 
+#endif
+		fbi->fix.line_length  = (fbi->var.xres)*(fbi->var.bits_per_pixel>>3);
+		fbi->var.xres_virtual = fbi->var.xres;
+		fbi->var.yres_virtual = fbi->var.yres;
+		fbi->var.width =  fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->width;
+		fbi->var.height = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->height;
+		fbi->var.pixclock = fb_inf->lcdc_dev_drv[lcdc_id]->pixclock;
+		fbi->var.left_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->left_margin;
+		fbi->var.right_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->right_margin;
+		fbi->var.upper_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->upper_margin;
+		fbi->var.lower_margin = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->lower_margin;
+		fbi->var.vsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->vsync_len;
+		fbi->var.hsync_len = fb_inf->lcdc_dev_drv[lcdc_id]->cur_screen->hsync_len;
+		fbi->fbops			 = &fb_ops;
+		fbi->flags			 = FBINFO_FLAG_DEFAULT;
+		fbi->pseudo_palette  = fb_inf->lcdc_dev_drv[lcdc_id]->layer_par[i]->pseudo_pal;
+		if (i == 0) //only alloc memory for main fb
+		{
+			rk_request_fb_buffer(fbi,fb_inf->num_fb);
+		}
+		ret = register_framebuffer(fbi);
+		if(ret<0)
+		{
+		    printk("%s>>fb%d register_framebuffer fail!\n",__func__,fb_inf->num_fb);
+		    ret = -EINVAL;
+		}
+		rkfb_create_sysfs(fbi);
+		fb_inf->fb[fb_inf->num_fb] = fbi;
+	        printk("%s>>>>>%s\n",__func__,fb_inf->fb[fb_inf->num_fb]->fix.id);
+	        fb_inf->num_fb++;	
 	}
 #if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)
 
     if(id == 0)
     {
-	    fb_inf->fb[fb_inf->num_fb-2]->fbops->fb_open(fb_inf->fb[fb_inf->num_fb-2],1);
-	    fb_inf->fb[fb_inf->num_fb-2]->fbops->fb_set_par(fb_inf->fb[fb_inf->num_fb-2]);
-	    if(fb_prepare_logo(fb_inf->fb[fb_inf->num_fb-2], FB_ROTATE_UR)) {
-	        /* Start display and show logo on boot */
-	        fb_set_cmap(&fb_inf->fb[fb_inf->num_fb-2]->cmap, fb_inf->fb[fb_inf->num_fb-2]);
-	        fb_show_logo(fb_inf->fb[fb_inf->num_fb-2], FB_ROTATE_UR);
-		fb_inf->fb[fb_inf->num_fb-2]->fbops->fb_pan_display(&(fb_inf->fb[fb_inf->num_fb-2]->var), fb_inf->fb[fb_inf->num_fb-2]);
-	    }
+	    fb_inf->fb[0]->fbops->fb_open(fb_inf->fb[0],1);
+	    fb_inf->fb[0]->fbops->fb_set_par(fb_inf->fb[0]);
+
+#if  defined(CONFIG_LOGO_LINUX_BMP)
+		if(fb_prepare_bmp_logo(fb_inf->fb[0], FB_ROTATE_UR)) {
+			/* Start display and show logo on boot */
+			fb_set_cmap(&fb_inf->fb[0]->cmap, fb_inf->fb[0]);
+			fb_show_bmp_logo(fb_inf->fb[0], FB_ROTATE_UR);
+			fb_inf->fb[0]->fbops->fb_pan_display(&(fb_inf->fb[0]->var), fb_inf->fb[0]);
+		}
+#else
+		if(fb_prepare_logo(fb_inf->fb[0], FB_ROTATE_UR)) {
+			/* Start display and show logo on boot */
+			fb_set_cmap(&fb_inf->fb[0]->cmap, fb_inf->fb[0]);
+			fb_show_logo(fb_inf->fb[0], FB_ROTATE_UR);
+			fb_inf->fb[0]->fbops->fb_pan_display(&(fb_inf->fb[0]->var), fb_inf->fb[0]);
+		}
+#endif
+		
     }
 #endif
 	return 0;
@@ -1056,11 +1179,10 @@ static void rkfb_early_suspend(struct early_suspend *h)
 	{
 		if (!inf->lcdc_dev_drv[i])
 			continue;
+		if(inf->lcdc_dev_drv[i]->screen0->standby)
+			inf->lcdc_dev_drv[i]->screen0->standby(1);
 		if(inf->lcdc_dev_drv[i]->screen_ctr_info->io_disable)
 			inf->lcdc_dev_drv[i]->screen_ctr_info->io_disable();
-		if(inf->lcdc_dev_drv[i]->screen->standby)
-			inf->lcdc_dev_drv[i]->screen->standby(1);
-		
 		inf->lcdc_dev_drv[i]->suspend(inf->lcdc_dev_drv[i]);
 	}
 }
@@ -1074,12 +1196,15 @@ static void rkfb_early_resume(struct early_suspend *h)
 	{
 		if (!inf->lcdc_dev_drv[i])
 			continue;
-		if(inf->lcdc_dev_drv[i]->screen_ctr_info->io_enable)
+		if(inf->lcdc_dev_drv[i]->screen_ctr_info->io_enable) 		//power on
 			inf->lcdc_dev_drv[i]->screen_ctr_info->io_enable();
-		if(inf->lcdc_dev_drv[i]->screen->standby)
-			inf->lcdc_dev_drv[i]->screen->standby(0);
 		
-		inf->lcdc_dev_drv[i]->resume(inf->lcdc_dev_drv[i]);
+		inf->lcdc_dev_drv[i]->resume(inf->lcdc_dev_drv[i]);	       // data out
+		
+		if(inf->lcdc_dev_drv[i]->screen0->standby)
+			inf->lcdc_dev_drv[i]->screen0->standby(0);	      //screen wake up
+		
+		
 	}
 
 }
@@ -1106,12 +1231,6 @@ static int __devinit rk_fb_probe (struct platform_device *pdev)
         	ret = -ENOMEM;
     	}
 	platform_set_drvdata(pdev,fb_inf);
-#if defined(CONFIG_HDMI_RK30)
-		#if defined(CONFIG_DUAL_DISP_IN_KERNEL)		
-			fb_inf->workqueue = create_singlethread_workqueue("hdmi_post");
-			INIT_DELAYED_WORK(&(fb_inf->delay_work), hdmi_post_work);
-		#endif
-#endif
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	suspend_info.inf = fb_inf;
diff --git a/drivers/video/rockchip/rkfb_sysfs.c b/drivers/video/rockchip/rkfb_sysfs.c
index 46bd772..4e148fe 100644
--- a/drivers/video/rockchip/rkfb_sysfs.c
+++ b/drivers/video/rockchip/rkfb_sysfs.c
@@ -40,7 +40,7 @@ static ssize_t show_screen_info(struct device *dev,
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	struct rk_lcdc_device_driver * dev_drv = 
 		(struct rk_lcdc_device_driver * )fbi->par;
-	rk_screen * screen = dev_drv->screen;
+	rk_screen * screen = dev_drv->screen0;
 	int fps;
 	u64 ft = (u64)(screen->upper_margin + screen->lower_margin + screen->y_res +screen->vsync_len)*
 		(screen->left_margin + screen->right_margin + screen->x_res + screen->hsync_len)*
@@ -56,9 +56,9 @@ static ssize_t show_disp_info(struct device *dev,
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	struct rk_lcdc_device_driver * dev_drv = 
 		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = get_fb_layer_id(&fbi->fix);
+	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
 	if(dev_drv->get_disp_info)
-		dev_drv->get_disp_info(dev_drv,layer_id);
+		return dev_drv->get_disp_info(dev_drv,buf,layer_id);
 
 	return 0;
 }
@@ -86,7 +86,7 @@ static ssize_t show_fb_state(struct device *dev,
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	struct rk_lcdc_device_driver * dev_drv = 
 		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = get_fb_layer_id(&fbi->fix);
+	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
 	int state = dev_drv->get_layer_state(dev_drv,layer_id);
 	return snprintf(buf, PAGE_SIZE, "%s\n",state?"enabled":"disabled");
 	
@@ -97,7 +97,7 @@ static ssize_t set_fb_state(struct device *dev,struct device_attribute *attr,
 	struct fb_info *fbi = dev_get_drvdata(dev);
 	struct rk_lcdc_device_driver * dev_drv = 
 		(struct rk_lcdc_device_driver * )fbi->par;
-	int layer_id = get_fb_layer_id(&fbi->fix);
+	int layer_id = dev_drv->fb_get_layer(dev_drv,fbi->fix.id);
 	int state;
 	int ret;
 	ret = kstrtoint(buf, 0, &state);
@@ -188,6 +188,108 @@ static ssize_t set_fps(struct device *dev,struct device_attribute *attr,
 	return count;
 }
 
+static ssize_t show_fb_win_map(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ret;
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_lcdc_device_driver * dev_drv = 
+		(struct rk_lcdc_device_driver * )fbi->par;
+
+	mutex_lock(&dev_drv->fb_win_id_mutex);
+	ret = snprintf(buf, PAGE_SIZE,"fb0:win%d\nfb1:win%d\nfb2:win%d\n",dev_drv->fb0_win_id,dev_drv->fb1_win_id,
+		dev_drv->fb2_win_id);
+	mutex_unlock(&dev_drv->fb_win_id_mutex);
+
+	return ret;
+	
+}
+
+static ssize_t set_fb_win_map(struct device *dev,struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_lcdc_device_driver * dev_drv = 
+		(struct rk_lcdc_device_driver * )fbi->par;
+	int order;
+	int ret;
+	ret = kstrtoint(buf, 0, &order);
+	if((order != FB0_WIN2_FB1_WIN1_FB2_WIN0) && (order != FB0_WIN1_FB1_WIN2_FB2_WIN0 ) &&
+	   (order != FB0_WIN2_FB1_WIN0_FB2_WIN1) && (order != FB0_WIN0_FB1_WIN2_FB2_WIN1 ) &&
+	   (order != FB0_WIN0_FB1_WIN1_FB2_WIN2) && (order != FB0_WIN1_FB1_WIN0_FB2_WIN2 ))
+	{
+		printk(KERN_ERR "un support map\nyou can use the following order: \
+			\n201:\nfb0-win1\nfb1-win0\nfb2-win2\n			   \
+			\n210:\nfb0-win0\nfb1-win1\nfb2-win2\n			  \
+			\n120:\nfb0-win0\nfb1-win2\nfb2-win1\n			  \
+			\n102:\nfb0-win2\nfb1-win0\nfb2-win1\n			   \
+			\n021:\nfb0-win1\nfb1-win2\nfb2-win0\n			   \
+			\n012:\nfb0-win2\nfb1-win1\nfb2-win0\n");
+		return count;
+	}
+	else
+	{
+		dev_drv->fb_layer_remap(dev_drv,order);
+	}
+
+	return count;
+	
+	
+}
+
+static ssize_t show_dsp_lut(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	
+}
+static ssize_t set_dsp_lut(struct device *dev,struct device_attribute *attr,
+	const char *buf, size_t count)
+{
+	int dsp_lut[256];
+	char *start = buf;
+	int i=256,j,temp;
+	int space_max = 10;
+
+	struct fb_info *fbi = dev_get_drvdata(dev);
+	struct rk_lcdc_device_driver * dev_drv = 
+		(struct rk_lcdc_device_driver * )fbi->par;
+	
+	for(i=0;i<256;i++)
+	{
+		temp = i;
+		dsp_lut[i] = temp + (temp<<8) + (temp<<16);  //init by default value
+	}
+	//printk("count:%d\n>>%s\n\n",count,start);
+	for(i=0;i<256;i++)
+	{
+		space_max = 10;  //max space number 10;
+		temp = simple_strtoul(start,NULL,10);
+		dsp_lut[i] = temp;
+		do
+		{
+			start++;
+			space_max--;
+		}while ((*start != ' ')&&space_max);
+		
+		if(!space_max)
+			break;
+		else
+			start++;
+	}
+#if 0
+	for(i=0;i<16;i++)
+	{
+		for(j=0;j<16;j++)
+			printk("0x%08x ",dsp_lut[i*16+j]);
+		printk("\n");
+	}
+#endif
+	dev_drv->set_dsp_lut(dev_drv,dsp_lut);
+
+	return count;
+	
+}
+
 static struct device_attribute rkfb_attrs[] = {
 	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
 	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
@@ -196,6 +298,8 @@ static struct device_attribute rkfb_attrs[] = {
 	__ATTR(enable, S_IRUGO | S_IWUSR, show_fb_state, set_fb_state),
 	__ATTR(overlay, S_IRUGO | S_IWUSR, show_overlay, set_overlay),
 	__ATTR(fps, S_IRUGO | S_IWUSR, show_fps, set_fps),
+	__ATTR(map, S_IRUGO | S_IWUSR, show_fb_win_map, set_fb_win_map),
+	__ATTR(dsp_lut, S_IRUGO | S_IWUSR, show_dsp_lut, set_dsp_lut),
 };
 
 int rkfb_create_sysfs(struct fb_info *fbi)
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index 1b86636..efda1ac 100644
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -25,7 +25,7 @@
 
 #define RK30_MAX_LCDC_SUPPORT	4
 #define RK30_MAX_LAYER_SUPPORT	4
-#define RK_MAX_FB_SUPPORT     4
+#define RK_MAX_FB_SUPPORT       8
 
 
 
@@ -142,6 +142,16 @@ enum data_format{
 	YUV444,
 };
 
+enum fb_win_map_order{
+	FB_DEFAULT_ORDER	   = 0,
+	FB0_WIN2_FB1_WIN1_FB2_WIN0 = 012,
+	FB0_WIN1_FB1_WIN2_FB2_WIN0 = 021, 
+	FB0_WIN2_FB1_WIN0_FB2_WIN1 = 102,
+	FB0_WIN0_FB1_WIN2_FB2_WIN1 = 120,
+	FB0_WIN0_FB1_WIN1_FB2_WIN2 = 210,
+	FB0_WIN1_FB1_WIN0_FB2_WIN2 = 201,       
+};
+
 struct rk_fb_rgb {
 	struct fb_bitfield	red;
 	struct fb_bitfield	green;
@@ -193,9 +203,17 @@ struct rk_lcdc_device_driver{
 	int num_layer;
 	int num_buf;				//the num_of buffer
 	int fb_index_base;                     //the first fb index of the lcdc device
-	rk_screen *screen;
+	rk_screen *screen0;		      //some platform have only one lcdc,but extend
+	rk_screen *screen1;		      //two display devices for dual display,such as rk2918,rk2928
+	rk_screen *cur_screen;		     //screen0 is primary screen ,like lcd panel,screen1 is  extend screen,like hdmi
 	u32 pixclock;
 
+	
+        char fb0_win_id;
+        char fb1_win_id;
+        char fb2_win_id;
+        struct mutex fb_win_id_mutex;
+	
 	struct completion  frame_done;		  //sync for pan_display,whe we set a new frame address to lcdc register,we must make sure the frame begain to display
 	spinlock_t  cpl_lock; 			 //lock for completion  frame done
 	int first_frame ;
@@ -209,11 +227,15 @@ struct rk_lcdc_device_driver{
 	int (*blank)(struct rk_lcdc_device_driver *dev_drv,int layer_id,int blank_mode);
 	int (*set_par)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
 	int (*pan_display)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
-	int (*get_disp_info)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
+	ssize_t (*get_disp_info)(struct rk_lcdc_device_driver *dev_drv,char *buf,int layer_id);
 	int (*load_screen)(struct rk_lcdc_device_driver *dev_drv, bool initscreen);
 	int (*get_layer_state)(struct rk_lcdc_device_driver *dev_drv,int layer_id);
 	int (*ovl_mgr)(struct rk_lcdc_device_driver *dev_drv,int swap,bool set);  //overlay manager
 	int (*fps_mgr)(struct rk_lcdc_device_driver *dev_drv,int fps,bool set);
+	int (*fb_get_layer)(struct rk_lcdc_device_driver *dev_drv,const char *id);                                      //find layer for fb
+	int (*fb_layer_remap)(struct rk_lcdc_device_driver *dev_drv,enum fb_win_map_order order);
+	int (*set_dsp_lut)(struct rk_lcdc_device_driver *dev_drv,int *lut);
+	int (*read_dsp_lut)(struct rk_lcdc_device_driver *dev_drv,int *lut);
 	
 };
 
diff --git a/include/linux/rk_screen.h b/include/linux/rk_screen.h
index 2409ddc..8ad6725 100644
--- a/include/linux/rk_screen.h
+++ b/include/linux/rk_screen.h
@@ -1,52 +1,6 @@
 #ifndef _SCREEN_H
 #define _SCREEN_H
 
-#ifdef CONFIG_HDMI_DUAL_DISP
-/* Scaler PLL CONFIG */
-#define S_PLL_NO_1	0
-#define S_PLL_NO_2	1
-#define S_PLL_NO_4	2
-#define S_PLL_NO_8	3
-#define S_PLL_M(x)  (((x)&0xff)<<8)
-#define S_PLL_N(x)  (((x)&0xf)<<4)
-#define S_PLL_NO(x) ((S_PLL_NO_##x)&0x3)
-
-enum{
-    HDMI_RATE_148500000,
-    HDMI_RATE_74250000,
-    HDMI_RATE_27000000,
-};
-/*     Scaler   clk setting */
-#define SCALE_PLL(_parent_rate,_rate,_m,_n,_no) \
-        HDMI_RATE_ ## _parent_rate ##_S_RATE_ ## _rate \
-        =  S_PLL_M(_m) | S_PLL_N(_n) | S_PLL_NO(_no)    
-#define SCALE_RATE(_parent_rate , _rate) \
-        (HDMI_RATE_ ## _parent_rate ## _S_RATE_ ## _rate)
-        
-enum{
-    SCALE_PLL(148500000,    66000000,   16, 9,  4),
-    SCALE_PLL(148500000,    57375000,   17, 11, 4),
-    SCALE_PLL(148500000,    54000000,   16, 11, 4),    
-    SCALE_PLL(148500000,    33000000,   16, 9,  8),
-    SCALE_PLL(148500000,    30375000,   18, 11, 8),
-    SCALE_PLL(148500000,    29700000,   16, 10, 8),
-    SCALE_PLL(148500000,    25312500,   15, 11, 8),
-
-    SCALE_PLL(74250000,     66000000,   32, 9,  4),
-    SCALE_PLL(74250000,     57375000,   34, 11, 4),
-    SCALE_PLL(74250000,     54000000,   32, 11, 4),
-    SCALE_PLL(74250000,     33000000,   32, 9,  8),
-    SCALE_PLL(74250000,     30375000,   36, 11, 8),
-    SCALE_PLL(74250000,     25312500,   30, 11, 8),
-
-    SCALE_PLL(27000000,     75000000,   100, 9,  4),
-    SCALE_PLL(27000000,     72000000,   32, 3,  4),
-    SCALE_PLL(27000000,     63281250,   75, 4,  8),
-    SCALE_PLL(27000000,     54375000,   145, 9,  8),
-    SCALE_PLL(27000000,     31500000,   28, 3,  8),
-    SCALE_PLL(27000000,     30000000,   80, 9,  8),
-};
-#endif
 typedef enum _SCREEN_TYPE {
     SCREEN_NULL = 0,
     SCREEN_RGB,
@@ -103,6 +57,8 @@ typedef struct rk29fb_screen {
 	u16 type;
 	u16 hw_format;
 	u16 face;
+	u8 lcdc_id;    //which output interface the screeen connect to
+	u8 screen_id; //screen number
 
 	/* Screen size */
 	u16 x_res;
@@ -120,7 +76,8 @@ typedef struct rk29fb_screen {
 	u16 lower_margin;
 	u16 vsync_len;
 	u8  ft;	//the time need to display one frame,in ms
-#ifdef CONFIG_HDMI_DUAL_DISP
+	int *dsp_lut; //display lut 
+#if defined(CONFIG_HDMI_DUAL_DISP) || defined(CONFIG_ONE_LCDC_DUAL_OUTPUT_INF)
     /* Scaler mode Timing */
 	u32 s_pixclock;
 	u16 s_left_margin;
@@ -156,6 +113,10 @@ typedef struct rk29fb_screen {
 	u8 swap_delta;
 	u8 swap_dumy;
 
+	int xpos;  //horizontal display start position on the sceen ,then can be changed by application
+	int ypos;
+	int xsize; //horizontal and vertical display size on he screen,they can be changed by application
+	int ysize;
 	/* Operation function*/
 	int (*init)(void);
 	int (*standby)(u8 enable);
